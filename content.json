{"meta":{"title":"自由を渇望する","subtitle":"ひとりぼっち","description":"Konjak_ldx's blog","author":"ldxcaicai","url":"http://ldxcaicai.github.io","root":"/"},"pages":[{"title":"标签","date":"2019-10-11T13:58:52.069Z","updated":"2019-10-11T13:58:52.069Z","comments":false,"path":"tags/index.html","permalink":"http://ldxcaicai.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-11T13:19:45.009Z","updated":"2019-10-11T13:19:45.009Z","comments":false,"path":"categories/index.html","permalink":"http://ldxcaicai.github.io/categories/index.html","excerpt":"","text":"Githubgithub: username: ldxcaicai # github username"},{"title":"友情链接","date":"2019-10-11T13:48:25.405Z","updated":"2019-10-11T13:48:25.405Z","comments":true,"path":"links/index.html","permalink":"http://ldxcaicai.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"常见积分，求导的公式和法则","slug":"integ","date":"2019-12-28T06:52:26.000Z","updated":"2019-12-28T07:39:51.670Z","comments":true,"path":"integ/","link":"","permalink":"http://ldxcaicai.github.io/integ/","excerpt":"","text":"由于博主太菜了经常忘记积分的公式于是在这里发一篇博便于自己查询 觉得早就记熟了的可以右上角溜了（ 求导常见公式与法则 \\begin{aligned} (C)'=&0\\\\ (x^n)'=&nx^{n-1}\\ (n\\not=0)\\\\ (\\sin x)'=&\\cos x\\\\ (\\cos x)'=&-\\sin x\\\\ (a^x)'=&a^x\\ln a\\ (a>0,a\\not=1)\\\\ (e^x)'=&e^x\\\\ (\\log_ax)'=&\\frac1{x\\ln a}\\ (a>0,a\\not=1)\\\\ (\\ln x)'=&\\frac1x\\\\ (f\\pm g)'=&f'\\pm g'\\\\ (f\\times g)'=&f'g+g'f\\\\ (\\frac fg)'=&\\frac{f'g+g'f}{g^2}\\\\ (f\\circ g)'=&(f'\\circ g)\\times g'\\\\ \\frac{\\text dy}{\\text dx}=&\\frac{\\text dy}{\\text du}\\cdot\\frac{\\text du}{\\text dx}\\\\ (f^{-1})'=&\\frac1{f'}\\\\ (反函数的导数等于直接函数&导数的倒数，即 \\frac{\\text dy}{\\text dx}=\\frac{1}{\\frac{\\text dx}{\\text dy}}\\\\ 莱布尼兹公式:(uv)^{(n)}=&\\sum\\limits_{i=0}^n\\binom nku^{(n-k)}v^{(k)} \\end{aligned} 不定积分常见公式与法则 \\begin{aligned} \\int k\\text dx=&kx+C\\ (k是常数)\\\\ \\int x^a\\text dx=&\\frac{x^{a+1}}{a+1}+C\\ (a\\not=-1)\\\\ \\int\\frac{\\text dx}x=&\\ln|x|+C\\\\ \\int\\frac{\\text dx}{1+x^2}=&\\arctan x+C\\\\ \\int\\frac{\\text dx}{\\sqrt{1-x^2}}=&\\arcsin x+C\\\\ \\int\\cos x\\text dx=&\\sin x+C\\\\ \\int\\sin x\\text dx=&-\\cos x+C\\\\ \\int\\frac{\\text dx}{\\cos^2x}=&\\tan x+C\\\\ \\int\\frac{\\text dx}{\\sin^2x}=&-\\cot x+C\\\\ \\int e^x\\text dx=&e^x+C\\\\ \\int a^x\\text dx=&\\frac{a^x}{\\ln a}+C\\\\ \\int(f\\pm g)\\text dx=&\\int f\\text dx\\pm\\int g\\text dx\\\\ \\int kf\\text dx=&k\\int f\\text dx\\\\ \\end{aligned} 换元积分法第一类换元积分法 \\begin{aligned} 利用的公式：&\\int(f\\circ \\varphi)\\varphi'\\text dx=(\\int f\\circ\\mu\\ \\text d\\mu)_{\\mu=\\varphi}\\\\ 使用方法：&假设求\\int g\\ \\text dx，尝试构造出函数f,\\varphi使得g=(f\\circ\\varphi)\\varphi'\\\\ 然后&问题转化为求f的积分 \\end{aligned}第二类换元积分法 \\begin{aligned} 利用的公式：&\\int f\\ \\text dx=[\\int(f\\circ\\psi)\\psi'\\text dt]_{t=\\psi^{-1}}\\\\ 使用要求：&等式右边有原函数且\\psi函数有存在且可导的反函数\\\\ \\end{aligned}","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"追忆","slug":"remembrance","date":"2019-12-26T02:08:32.000Z","updated":"2019-12-26T02:56:37.844Z","comments":true,"path":"remembrance/","link":"","permalink":"http://ldxcaicai.github.io/remembrance/","excerpt":"","text":"About Backseat_Stargazer初识在初三的时候 zgs 请了 rxdoi 到 cdss 讲课，我和 yk 都前往听课，期间在 zgs 的介绍下认识了 zxy 和 cyk ，听说了 cyk 一个下午+晚上从零基础学完简单图论以及成实外三校区文化课 rk 前10 的神仙事迹。但当时由于 cyk 一直在睡觉，于是他两边的我和 zxy 就常常一脸懵逼的望着他睡觉然后继续听课或者讨论题目 后来本人说是生病了，我倒是认为他觉得太简单了索性不听了 就这样，短暂的认识又马上忘记了 cyk 之后，我开始颓废生活准备中考 再会中考之后果然在 cdsszx 又见面了，这次 zgs 干脆直接钦定 cyk 成为未来的金牌选手了 Orz ，让他跟我们几个一起混学习 OI ，然后中考成绩出来之后 yk 和 zyj 就溜了，我因为 cdqz 神仙太多的原因就留下了，发现厉害的就只剩下了 cyk 和 zxy （当然暑假快结束时 lmy 突然变强以至于比较厉害的变成了四个人），之后由于 cyk 前置知识学过的太少于是跟我们分成了两个教室听课，后面大家集中在一起考试感觉 cyk 的考试乘积虽然不怎么稳定但是实力开始指数级上升现在看来可能 cyk 当时在战略性犯一些小错误以隐藏实力，但由于他乘积时高时低我当时觉得这个 cyk 好像没 zgs 吹那么厉害后来我就被吊起来锤了于是就开始 diss 他现在他有能力 diss 我但一直不 diss。暑假末的时候，cyk 来找我说他想入门线段树，我沉思许久之后给他推荐了一道 siano ，结果由于代码能力还没有起来的原因， cyk 翻了三页的车（指提交代码）才过，搞得现在每次我推题都会被他吐槽==，然后开学学了一个月文化课之后就开始停课冲刺 NOIp ，期间我由于初中做过的 sb 多以及手速相对快一点的原因拿了几次 rk1 ，感觉心态稳健， cyk 仍然是波动曲线不过看起来比原来强好多了。感觉停课的时间算是机房群体所有人感情增进最迅速的时间段了废话本来就不是一个班的只有这个时候才有那么多时间拿来交流，让我印象深刻的是我和 cyk 有几次周末都留下来上晚自习讨论问题到 10 点过才走，印象最深刻的还是有一次讨论概率期望 dp 入门题，貌似激动地差点吵起来了，然后就 NOIp 了发现自己菜的一批的同时已经被 cyk 吊起来锤了 然后我就学会了看番 然后去雅礼和绍兴集训感觉我可能相对其他几个更擅长打暴力分貌似还是高一点，有点高兴，那段时间感觉 cyk 和 zxy 实力还是指数级提升，然后就有了排名交换的感觉吧，感觉实力排名从刚进校的 ldx&amp;zxy,lmy&amp;cyk ，变成了 zxy,cyk,ldx&amp;lmy ，然后就 scoi 了，我 day2MLE的事情大家都知道不然排名跟zxy差不多（虽然可能也进不了D） ，得了，现在分数排名也成 zxy,cyk,ldx&amp;lmy 了 之后休息了一段时间上了一段时间文化课之后去ez集训，慢慢感觉实力水平变回了 zxy,ldx,cyk,lmy ，推测原因是因为 cyk 和 lmy 有一些算法没学以及有一些暴力不想打，但是由于本人太颓了以至于后半段集训不怎么改题，慢慢的实力变成了 zxy,cyk,lmy,ldx 大哭，网络赛由于其余三个发挥失误了好像又拿了个四人里的 rk1 ，事后比较心怀侥幸 noi 过后就请人讲课了，然后开学开始停课，发现 zxy 实力比我们仨高了几个档，于是之后的实力评比 zxy 不再参与，用学弟 fsy 的水平拿来替代 cdss 的集训策略大概是考两天休息一天的样子，这导致我这种经常熬夜的第二天考试不清醒，因此往往考出来的乘积排名是 cyk&amp;fsy,lmy,ldx ，但我实际感觉我应该还是跟 lmy 水平差不多吧，结果 CSP-S 2019 前我的状态崩的更厉害了，基本场场考不过联赛组神仙，吓得我 CSP-S 前几天开始莽之前的 NOIp 真题 我 CSP-S 和 NOIp 有个 P 的关系，在 day0 上午终于莽完了，心态好了一点感觉还是有希望上 450 的，NMD,最后还真就没上 450 ，然后就是联赛了，考完感觉考了个大众分估计只能排 30~50 名了， lmy 因为翻车严重可能要退役了， cyk 应该分数跟我差不多， zxy 应该稳了。 直到下午 cyk 告诉我他 d1t2 只有 50 了 然后当时我的心情是难以置信，感觉实力比我强的 cyk 不可能翻在这种 sbt 上面 最后还真就翻了，NMDWSM 感觉生活就像多米诺骨牌一样，打翻了最开始的那一张，就会产生一系列的连锁反应： cyk 没有跟我们一起去ez参加冬令营集训 cyk 考了 pkuwc 一等奖的线但由于是非正式营员不能领奖 cyk 现在回去上了文化课 MD PKU 这个操作真 TMZZ，明明都跟 cyk 约好了 day2 翻盘（并且我俩还真翻了）结果突然来个不能拿奖？？？ 可能这就是命运对强者的惩罚吧 所幸的是 cyk 寒假复役，还能一起战斗，还能问 cyk 沙雕问题，还能有机会和他互相口吐芬芳，在此之前，我还是得提升自己水平以至于到时候不会听不懂 cyk 和 zxy 在讲什么神仙东西 （不过你看看我现在写这篇不知道在写什么的东西的时候 zxy 又做了好几道题了，我还啥都没做，实力差距没法弥补啊）","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://ldxcaicai.github.io/tags/随笔/"}]},{"title":"PKUWC2020游记","slug":"pkuwc2020","date":"2019-12-23T23:34:57.000Z","updated":"2019-12-24T00:10:02.650Z","comments":true,"path":"pkuwc2020/","link":"","permalink":"http://ldxcaicai.github.io/pkuwc2020/","excerpt":"","text":"所以这次冬令营到底叫啥啊这不还是19年吗== Day0坐飞机去首都，然后感觉人被冻没了233 这次参加 pkuwc 的有我,cyk,fsy,hwj 中午和教练吃完饭下午跑去报到，结果 zxy 因为没事干跟着我们去报到（其实是准备嘲讽我们） ，结果排队的人太多我,cyk,fsy直接开始欢乐斗地主然后被 zxy 无情吐槽了😭😭😭 回去之后给 cyk 放卢姥爷的斗地主神仙名场面集锦（大雾）然后写了几道题就睡了，感觉啥都没干药丸 Day1上午开营仪式结果请了一个 thu 毕业的 pku 老师来给我们吹水做讲座 开营仪式结束后刘姐和 D Z Yo 带我们在 pku 旅游了一圈讲了一下比赛事项，结果我们和他们那届赛制不一样？？？最后还真成旅游了 中午比较困但一直没睡着，喝了一瓶咖啡就去上机测试了 开题 三道计数，真棒 看题三道都不会。。。。 $A$ 想了半天不会最低档暴力 $B$ 想了半天只会最低档暴力 $C$ 想了半天只会 $100pts$ 那就写吧， $90min$ 之后我发现自己看错题了，心态爆炸，然后发现 $mobius$ 反演能有 $42pts$ ，那就写吧，终于有分了.jpg 然后发现 $B$ 会 $50pts$ , $A$ 可能会最低档暴力了，然后就开始写 $B$ 的 $50pts$ ，写法发现又假掉了，结果想了一会儿又会了一个算法，氪命 rush 了一波还是没调出来，最后交了一个 $10pts$ 没评出来就结束了 然后下来一问大家都比我高😱😱😱😱😱那这不是完蛋了吗，所幸的是所有 正式营员都进了面试，结果 cyk 貌似是因为 CSP-S 考低了一点就没面试资格？然后学弟告诉我他旁边那个考了 $241$ ，我？？？人都傻了，晚上被学弟拖去未名湖走了一圈，回去之后 zgs 说 cyk 只要考得高还是能拿奖，于是我们兴高采烈的回房间开始颓废，我才不会告诉你我因为太丧直接把吞食鱼打通关然后看小说看到两点半的事呢 Day2早上去面试，由于有三场面试而我以为只有一场，于是 $8:55$ 才到文史楼，结果去了才知道我还有一场 $8:35$ 和一场 $9:50$ 的，由于面试比较无聊所以这里就不多讲，唯一让我放不下心的是第三场面试离开的时候面试我的老师说：你还得多多努力才行啊。 人都傻了.jpg，这是在说让我下次再来的意思吧😱😱😱😱😱 比较神仙的是学弟 fsy 第一场面试的时候面试老师问了一句：成都石室中学？没听说过啊，你来简单介绍一下。 回去之后感觉非常郁闷，吃完饭之后和 cyk 说今天一定要翻盘然后就进考场了，还有 5min 开始的时候打完了多项式全家桶的板子，然后慢慢等待考试开始，打开一看，NMD今天怎么一道计数都没有啊！然后确认了 5min 自己没把 $A$ 读错题之后写了一发交上去就过了，然后想了一下 $B$ 发现直接建出笛卡尔树然后加一个广义线段树查询区间信息做法就过了，然后想了一下 $C$ ，嗯？这个无向图怎么求最小割啊？？？我居然连最低档暴力都不会，前两道还是送分的，凉了。 过了 $5min$ 反应过来是个二维数点问题，然后会了 $68$ 分，写了个四分树一交发现被卡了只有 $42$ 分，冷静了一下把第一个四分树改成了二维 $bit$ 结果又 TLE 了，又冷静了一下把第二个四分树改成了树套树准备交一发，仔细想了一想貌似第一棵直接用二维前缀和即可，这次如果过不了就换成二维前缀和吧！结果交上去就过了。。。最后由于冷静了很久不会优化后面一个树套树于是人没了。出来一问好像一坨人阿克，那我没了。。。对了一下分发现 cyk 总分跟我差不多， fsy 和 hwj 要稍微低一点点，晚上和 fsy 和 cyk 在房间里斗地主， cyk 直接输封顶了 Day3发奖日 上午酒店里颓废，下午去领奖感觉慌得一批，希望能苟一个二等奖回家 然后先是敦敦敦来讲题，发现讲了我还是不会，另外那个 d1t3 也得吐槽一下，敦敦敦：这个题我也不是很会，你们想知道可以下来联系一下他（指吉老师）。 MD有毒 然后就发奖了，结果一二等奖发完之后我和 cyk 都没领到， fsy 和 hwj 都有二等奖，感觉自己成最大输家。然后最后发现是一等？？？我拿到之后就开始等 cyk 的，结果到了最后也没发？？？然后去找老师一问说的是非正式营员无法发奖？？？这操作太😁😁😁了吧？？？引起我们极度不适。 zgs 联系了一下感觉也不是很能补一个奖，于是简单安慰了一下 cyk 就准备去 thu 等 zxy 他们发奖了，然后成功给到了 hjk 和 yk ，听见 yk 在那儿一直假感觉有毒，最后发下来 CDQZ 高二三个一等奖， zxy 也一等了。于是马上我们就去机场准备回家感觉zgs又会发个什么神奇的喜报","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://ldxcaicai.github.io/tags/游记/"}]},{"title":"burnside引理简单证明","slug":"burnside","date":"2019-12-16T13:56:40.000Z","updated":"2019-12-16T14:19:29.268Z","comments":true,"path":"burnside/","link":"","permalink":"http://ldxcaicai.github.io/burnside/","excerpt":"","text":"前言：由于博主时不时会忘记这个定理以及它是咋证明的，所以为了方便就干脆自己写一个放 $blog$ 上面 现在给出集合 $\\text{X}$ ，设 $\\text G$ 是其置换群， $\\text C$ 是其着色集，且 $\\text G$ 作用在 $\\text C$ 下 那么定义 $G(c)=\\{f:f\\in \\text G,f\\times c=c\\},C(f)=\\{c:c\\in \\text C,f\\times c=c\\}$ 然后有一个显然的推论: 设 $c$ 是 $\\text C$ 中的一种着色，那么 $|\\{f\\times c:f\\in \\text G\\}|=\\frac{|\\text G|}{|G(c)|}$ ,证明显然 然后就能证明 $Burnside$ 引理了： \\begin{aligned} \\sum\\limits_{f\\in \\text G}|C(f)|=&\\sum\\limits_{c\\in \\text C}|G(c)|\\\\ \\sum\\limits_{f\\in \\text G}|C(f)|=&\\sum\\limits_{c\\in\\text C}\\frac{|\\text G|}{与c等价的着色数}\\\\ \\sum\\limits_{f\\in\\text G}|C(f)|=&|\\text G|\\sum\\limits_{c\\in\\text C}\\frac{1}{与c等价的着色数}\\\\ 由于在一个等价类中&每种着色的贡献都是\\frac{1}{与c等价的着色数}\\\\ 所以\\sum\\limits_{f\\in \\text G}|C(f)|=&|G|\\times N(\\text G,\\text C)\\\\ N(\\text G,\\text C)=&\\frac{\\sum\\limits_{f\\in \\text G}|C(f)|}{|\\text G|} \\end{aligned}得证","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"Powerful Number 筛学习笔记","slug":"PN","date":"2019-11-30T13:12:34.000Z","updated":"2019-11-30T13:27:30.102Z","comments":true,"path":"PN/","link":"","permalink":"http://ldxcaicai.github.io/PN/","excerpt":"","text":"NMD我怎么现在才会这沙雕玩意儿.jpg 感觉挺简单的，主要是适用范围比较小，大概能筛某些性质比较奇妙的上界在 $10^{13}$ ~ $10^{14}$的积性函数 首先介绍 $\\text{Powerful}$ $\\text{Number}$ 是啥，当一个数满足其所有质因数的指数都大于 $1$ 的时候我们称其为 $\\text{Powerful}$ $\\text{Number}$ ，下面简单说明其重要性质： $n$ 以内的 $\\text{Powerful}$ $\\text{Number}$ 的数量为 $\\sqrt n$ 级别的，首先发现每个 $\\text{Powerful}$ $\\text{Number}$ 都能表示成 $x^2y^3$ 的形式 \\begin{aligned} |\\text{PowerfulNumber}\\le n|=&\\sum\\limits_{x=1}^{\\sqrt n}\\lfloor\\sqrt[3]{\\frac nx}\\rfloor\\\\ =&n^{\\frac13}\\sum\\limits_{x=1}^{\\sqrt n}x^{-\\frac23}\\\\","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"Linear algebra","slug":"LA","date":"2019-11-26T14:38:38.000Z","updated":"2019-11-26T14:40:03.123Z","comments":true,"path":"LA/","link":"","permalink":"http://ldxcaicai.github.io/LA/","excerpt":"","text":"相似矩阵 定义：若对于矩阵 $\\text A$ 存在矩阵 $\\text B$ 和可逆矩阵 $\\Phi$ 满足 $\\text B=\\Phi^{-1}\\text A\\Phi$ ，那么我们称 $\\text A$ 相似于 $\\text B$ ，记做 $\\text A\\sim\\text B$相似有如下性质： 反身性： $\\text A\\sim\\text A$ 对称性： 如果 $\\text A\\sim\\text B$ ，那么 $\\text B\\sim\\text A$ 传递性： 如果 $\\text A\\sim\\text B,\\text B\\sim\\text C$ ，那么 $\\text A\\sim\\text C$ 相似矩阵有如下性质： 两者的秩相等 两者的行列式值相等 两者拥有同样的特征值，尽管相应的特征向量一般不同 两者拥有同样的特征多项式 两者可逆性相同，若均可逆，那么两者的逆矩阵同样相似 博主仅对第四点进行证明： \\begin{aligned} 0=|\\lambda\\text E-\\text B|=&|\\Phi^{-1}\\lambda\\Phi-\\Phi^{-1}\\text A\\Phi|\\\\ =&|\\Phi^{-1}(\\lambda\\text E-\\text A)\\Phi|\\\\ =&|\\Phi^{-1}|\\times|\\lambda\\text E-\\text A|\\times|\\Phi|\\\\ =&0\\\\ \\Rightarrow&|\\lambda\\text E-\\text A|=0 \\end{aligned} 用途可以用于解决关于对角化矩阵的问题，假设一个矩阵 $\\text A$ 与对角矩阵 $\\text B$ 相似，那么有 \\begin{aligned} \\text A^m=&(\\Phi^{-1}\\text B\\Phi)^m\\\\ =&\\Phi^{-1}\\text B(\\Phi\\text A\\Phi^{-1})^{m-1}\\Phi\\\\ =&\\Phi^{-1}\\text B^m\\Phi \\end{aligned}问题转化为求桥接矩阵 $\\Phi$ ，这个就各凭本事了 好吧还有一个定理如下：若 $\\text A$ 与对角矩阵 $\\text B$ 相似，那么 $\\text A$ 有 $n$ 个线性无关的特征向量，设为 $v_i$ ，那么 $\\Phi$ 就是将 $v_1\\cdots v_n$ 横向拼接起来得到的矩阵 问题转化为求逆矩阵 $\\Phi^{-1}$ ，这回是真的各凭本事了","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"CSP-S 2019 泪奔记","slug":"csp2019","date":"2019-11-17T06:40:02.000Z","updated":"2019-11-18T08:50:47.013Z","comments":true,"path":"csp2019/","link":"","permalink":"http://ldxcaicai.github.io/csp2019/","excerpt":"","text":"希望这不是博主发出来的最后一篇blog2333 Day 0上午写完了 $NOIP$ 的最后一部分真题，这里是以往的 $NOIP\\ TG$ 的题解链接 然后中午写完题解和 $Dad$ 一起去了酒店，在滴滴上听歌听到一半播放器就没电了， $sad$ 在酒店颓废了一下午之后跟 $Dad$ 出门吃晚饭结果遇见了 $Jun$ ，发现住的是同一家酒店（惊了$\\times 1$），吃了半碗米线，感觉没有食欲，然后去买面包发现 $jmr$ 也在和他爸买面包（惊了 $\\times 2$），然后去买了碗泡面准备晚上吃，回去之后跟 $Jun$ 谈了一个多小时人生，然后又颓废了一会儿冲个澡就睡了 Day 1起床之后套了个耳机和 $Dad$ 一起去考场，然后发现其余选手貌似都已经进场了，赶快去拿了两瓶农夫山泉然后进了考场，发现没人拦着我写板子于是把板子码完了，然后开题，发现前两道都比较菜感觉阿克稳了，结果 $9:00$ 过了大样例之后发现完全不会 $T3$ ，感觉没救了，一直肝到 $11:00$ 都没有想清楚细节果断准备搞暴力，然后发现暴力只会第一档，自闭了，最后一分钟又加上了一个刚过编译的假贪心交了上去说不定原本的暴力分都没了，想题期间把 $T3$ 题意看错两次 出考场之后突然听说 $T1$ 要 $ULL$ ，自闭了，感觉退役稳了，算了一下 $day1$ 貌似最高才 $205$ 被其余人按在地上暴打 然后下午听说 $romiqi$ 爆炸了感觉有点遗憾，简单聊了几句之后跑去睡觉，起来之后跟 $hjk1030$ 聊天结果得知 $zyj$ 也跟我住一个酒店？？？（惊了 $\\times 3$），然后跑去串门聊了很久的天，之后跟 $Jun$ 两个人一起去电子科大打羽毛球，结果两个铁憨憨不认路找了 $30min$ 才找到场子，打的时候旁边还有一对 $cp$ 在花式虐狗，更6p的是我俩在篮球场里看见一堆人在直播电竞比赛，跟 $Jun$ 在电子科大里走路的时候又聊了好久人生 晚上回酒店发现 $Mom$ 来了（惊了 $\\times 4$ ），吃完晚饭之后听说 $CDQZ$ 在一个一个面谈于是下去面基，发现 $buzhibujue,sjkmost,jmr$ 在下面转圈，看起来都好稳的样子，大概聊了一下最后不知道怎么变成 $mod\\ jerome$_ $wei$ 和 $mod\\ zxyoi$ _$dreamer$ 大会了，然后找到 $yangkai$ 和 $hjk1030$ 聊了一小会儿又回房了，结果回去之后 $yangkai$ 突然问我他 $d1t2$ 的正确性，想了一下发现没啥锅跟他说了几句然后小颓一会儿又睡了 Day 2早上爬起来洗个澡，感觉美滋滋，然后去考场的时候遇到了 $yangkai$ ，然后听说司机差点没调出来 $d1t3$ 。进考场打完板子之后一开题就蒙蔽了，居然没送分题？？？不对 $T2$ 好像是送的，然后想了 $20min$ 无果发现看错题了，然后倒回去看 $T1$ ，想了一会儿发现是个补集转化入门题，过完样例就跑去想 $T2$ ，然后感觉越想越不行，准备先写 $T3$ 暴力然后把 $T2$ 鈤出来，但由于写 $T3$ 暴力的时候我 $dev$ 又死掉了于是心态小崩，（这么说来我目前参加过的大赛 $day2$ 都死机了）结果开 $T2$ 的时候已经 $11:00$ 了，想了 $30min$ 无果之后 $rush$ 了一个 $32pts$ 暴力，发现能优化到 $64pt$ 并且在结束前 $5min$ 的时候调出来了，然后考试结束了 出来之后听说 $romiqi$ 翻车二连， $T2$ 切 $88pts$ 是真的强，没调出来就有点可惜，主要是因为今年两天都没有区分度，只要暴力打好即可。这样对我们这种准备很久的 $oier$ 完全没有优势，不过 $CCF$ 也让很多分数相近的选手看到希望从而赚更多钱。 现在博主慌得一批感觉会 $FST$ 一堆，希望运气好点吧，不过 $WC$ 和 $PKUWC$ 是百分百无望了，如果我去莽个 $d1t3$ 的暴力也就不至于成现在这鬼样子了，唉 UPD:19.11.18: 貌似民间数据测出来没有挂分，大概还能苟延残喘一段时间？希望 $CCF$ 的机子对我的代码友好一点","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://ldxcaicai.github.io/tags/游记/"}]},{"title":"Linear programming","slug":"LP","date":"2019-09-27T02:20:44.000Z","updated":"2019-10-11T15:33:21.577Z","comments":true,"path":"LP/","link":"","permalink":"http://ldxcaicai.github.io/LP/","excerpt":"","text":"线性规划两种常见形式的转化标准型： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j\\le b_i\\\\ &x_i\\ge0 \\end{aligned}松弛型： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j= b_i\\\\ &x_i\\ge0 \\end{aligned}下面是一个常用的标准型转松弛型套路： 原线性规划： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j\\le b_i\\\\ &x_i\\ge0 \\end{aligned}令 $x_{i+m}=b_i-\\sum\\limits_{j=1}^na_{i,j}x_j\\ge 0$ 那么有新的线性规划： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j+x_{i+m}=b_i\\\\ &x_i\\ge0 \\end{aligned}单纯形法求解线性规划将上面的松弛型线性规划进行移项： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&x_{i+m}=b_i-\\sum\\limits_{j=1}^na_{i,j}x_j\\\\ &x_i\\ge0 \\end{aligned}然后一直重复下面的操作： 在目标函数中找出一个 $c_e&gt;0$ 的 $e$ 在约束条件中找出满足 $a_{l,e}&gt;0且\\frac{a_{l,0}}{a_{l,e}}最大$ 的 $l$ 将第 $l$ 个约束等式移项变形： $x_e=\\frac{b_i}{a_{l,e}}-\\sum\\limits_{j=1,j\\not=e}^n\\frac{a_{l,j}}{a_{l,e}}x_j-\\frac1{a_{l,e}}x_{l+m}$ 将移项得到的等式带入其余的约束等式和目标函数中，消去所有的 $x_e$ ，添加上 $x_{l+m}$ ，并更新剩余项的系数 讨论下面几种边界情况： 当第一步无法找到合法的 $e$ 时，说明求出了最优解 当第二步无法找到合法的 $l$ 时，说明该线性规划无界 复杂度指数级，但跑的比谁都快 正确性:线性规划有界时解空间是一个凸形区域，因此单纯形算法求出的局部最优值即为全局最优值 当然有时候需要构造一组初始解出来（大部分时候不需要），可以使用如下技巧构造辅助线性规划： \\begin{aligned} maximize:&-x_0\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j+x_0=b_i\\\\ &x_i\\ge0 \\end{aligned}容易看出如果该情况无解那么原问题无解 例题： UVA Happiness CC Flight Distance TCO precious stones 整数线性规划本来应该是 $NP-hard$ 问题 但是如果证明最优解一定是在整数解时可以取得的话可以用单纯形 原因还是来源于上面说过的凸形区域 或者可以一眼看出该线性规划的 $\\boldsymbol A$ 是一个全幺模矩阵也行 对偶原理考虑现在有如下线性规划： \\begin{aligned} minimize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j\\ge b_i\\\\ &x_i\\ge0 \\end{aligned}利用待定系数法的思想可以知道，该线性规划的任意可行解$(x_1^{\\times},x_2^\\times,…,x_n^\\times)$一定能表示成如下形式： \\begin{aligned} \\sum\\limits_{i=1}^nc_ix_i^\\times=&\\sum\\limits_{i=1}^my_i(\\sum\\limits_{j=1}^na_{i,j}x_j^\\times)\\ge\\sum\\limits_{i=1}^mb_iy_i\\\\ \\sum\\limits_{i=1}^my_ia_{i,j}\\le&c_j\\\\ y_i\\ge&0 \\end{aligned}现在要找出 $\\sum\\limits_{i=1}^nc_ix_i$ 的下界，等价于找出 $\\sum\\limits_{i=1}^mb_iy_i$ 的上界 于是我们得到了一个新的线性规划： \\begin{aligned} maximize:&\\sum_{i=1}^mb_iy_i\\\\ limits:&\\sum_{j=1}^ma_{j,i}y_j\\le c_j\\\\ &y_j\\ge0 \\end{aligned}同样的，将新得到的线性规划做类似转化可以转回原来的线性规划，我们称这两个线性规划互为对偶问题 互相转化的关键是这个等式： $\\sum\\limits_{i=1}^nc_ix_i\\ge\\sum\\limits_{i=1}^mb_iy_i$ ，即等号右边的上界不超过等号左边的下界 上述等式即是线性规划弱对偶性，即对于两个线性规划的任意可行解 $\\boldsymbol x^\\times,\\boldsymbol y^\\times$，均满足 $\\sum\\limits_{i=1}^nc_ix_i^\\times\\ge\\sum\\limits_{i=1}^mb_iy_i^\\times$ 线性规划的对偶原理用矩阵的形式可以简单表示为： \\min\\{\\boldsymbol{c}^T \\boldsymbol x|\\boldsymbol A\\boldsymbol x\\ge \\boldsymbol b,\\boldsymbol x\\ge\\boldsymbol0\\}\\Longleftrightarrow\\max\\{\\boldsymbol b^T\\boldsymbol x|\\boldsymbol A^T\\boldsymbol y\\ge\\boldsymbol c,\\boldsymbol y\\ge \\boldsymbol 0\\}下面证明一个重要定理： 线性规划对偶性：对于两个线性规划的任意最优解解 $\\boldsymbol x^\\times,\\boldsymbol y^\\times$，均满足 $\\sum\\limits_{i=1}^nc_ix_i^\\times=\\sum\\limits_{i=1}^mb_iy_i^\\times$ 证明： 对于第一个线性规划，考虑构造一个函数 $f(\\boldsymbol y)=\\boldsymbol c^T\\boldsymbol x+\\boldsymbol y^T(\\boldsymbol b-\\boldsymbol A\\boldsymbol x),\\boldsymbol y\\ge\\boldsymbol0$ 令 $g(\\boldsymbol y)=\\min\\{f(\\boldsymbol y)|\\boldsymbol A\\boldsymbol x\\ge \\boldsymbol b,\\boldsymbol x\\ge\\boldsymbol0\\}$ 显然$\\forall \\boldsymbol y,g(\\boldsymbol y)\\le \\boldsymbol c^T\\boldsymbol x^\\times$ 即$\\max\\{g(\\boldsymbol y)\\}=\\boldsymbol c^T\\boldsymbol x^\\times$ 转化问题： \\begin{aligned} \\boldsymbol c^T\\boldsymbol x^\\times=&\\max\\{g(\\boldsymbol y)\\}\\\\ =&\\max\\{\\boldsymbol y^T\\boldsymbol b+\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}\\}\\\\ =&\\max\\{\\boldsymbol b^T\\boldsymbol y+\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}\\} \\end{aligned}当 $\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A\\ge \\boldsymbol0$ 时，$\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}=0$ 当 $\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A\\not\\ge \\boldsymbol0$ 时，$\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}=-inf$ 简单分析与变形后可知： \\begin{aligned} \\boldsymbol c^T\\boldsymbol x^\\times=&\\max\\{\\boldsymbol b^T\\boldsymbol y|\\boldsymbol A^T\\boldsymbol y\\le\\boldsymbol c,\\boldsymbol y\\ge\\boldsymbol0\\} \\end{aligned}得证 而且容易知道原问题和对偶问题同时取到目标取值~ 利用上述两个定理容易证明出线性规划的互相松弛定理： 对于原问题和对偶问题的可行解 $\\boldsymbol x^\\times,\\boldsymbol y^\\times$ ，它们均为问题的最优解当前仅当如下条件被满足： $\\forall 1\\le j\\le n,s.t.\\ x_j^\\times=0或\\sum\\limits_{i=1}^ma_{i,j}y_i^\\times=c_j$ $\\forall 1\\le i\\le m,s.t.\\ y_i^\\times=0或\\sum\\limits_{j=1}^na_{i,j}x_i^\\times=b_i$ 对偶原理的几个性质： 对于无限制变量 $x_i$ ，对偶后对应限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j=c_i$ 对于变量 $x_i=0$ ，对偶后对应 $\\sum\\limits_{j=1}^ma_{j,i}y_j$ 无限制 对于变量 $x_i\\ge0$ ，对偶后对应限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j\\ge0$ 对于变量 $x_i\\le0$ ，对偶后对应限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j\\le0$ 对于限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j=c_i$ ，对偶后对应无限制变量 $x_i$ 对于限制$\\sum\\limits_{j=1}^ma_{j,i}y_j$ ，对偶后对应变量 $x_i=0$ 对于限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j\\ge0$ ，对偶后对应变量 $x_i\\le0$ 对于限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j\\le0$ ，对偶后对应变量 $x_i\\ge0$ 对偶原理在网络问题中的运用利用上述定理和性质可以很快证明如下两个结论： 最小割和最大流是对偶问题 二分图最大权匹配和最小费用流是对偶问题 证明比较容易，这里略去 例题： [SHOI2004]最小生成树 CC Flight Distance 线性规划与半平面交的转化 对于只有两个变量的线性规划，可以通过移项变成半平面交问题 对于只用两个限制的线性规划，可以通过对偶原理+移项变成半平面交问题 例题： poj equations 线性规划与网络流问题的转化考虑到网络流问题的最优解都是整数解，因此在转化的时候务必记住判定列出的线性规划是不是全幺模矩阵否则不一定解出的最优解是整数最优解~ 例题： CC Chefbook bzoj Orz the MST [ZJOI2013]战线防守 线性规划与博弈一个基本不可能填的坑 好难啊我不会纳什均衡，还是得cyktxdy学会了之后给我讲","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"Berlekamp-Massey algorithm","slug":"bm-algorithm","date":"2019-09-25T14:25:20.000Z","updated":"2019-12-04T03:42:43.671Z","comments":true,"path":"bm-algorithm/","link":"","permalink":"http://ldxcaicai.github.io/bm-algorithm/","excerpt":"","text":"算法引入Berlekamp-Massey算法可以在$O(n^2)$的时间内求出长度为$n$的已知数列的最短递推式，再配合常系数齐次线性递推就可以快速求出数列的任意项。 现在给你一个数列，考虑如何构造出其最短递推式。 算法流程对于一个$n$项的数列 $A=\\{a_1,a_2,…,a_n\\}$ 和另一个$m$项的数列 $R=\\{r_1,r_2,…,r_m\\}(m\\le n)$ ，当$\\forall k&gt;m$，都满足$a_k=\\sum\\limits_{i=1}^mr_ia_{k-i}$时，我们称$R是$A的一个递推式，对于所有满足条件的$R$，我们将$m$最小的$R$称为$A$的最短线性递推式。 现在我们考虑用增量构造法构造一个$N$项的数列$A$的最短线性递推式$R$ 假设我们当前处理到位置$n$，$\\{a_1,a_2,…,a_{n-1}\\}$的最短线性递推式为$\\{r_1,r_2,…,r_m\\}$，记第$i$次更改最短线性递推式为$R_i$，特别的，$R_0=\\{\\emptyset\\},R_{cur}=\\{r_1,r_2,…,r_m\\}$即为当前最短线性递推式。 设$\\Delta n=a_n-\\sum\\limits_{i=1}^mr_ia_{n-i}$，现在按$\\Delta n$的取值分两种情况考虑 $\\Delta n=0$，则$R_{cur}$为$\\{a_1,a_2,…,a_n\\}$的最短线性递推式 $\\Delta n\\not=0$，则$R_{cur}$在位置$n$出错，我们要构造出$R_{cur+1}$来修正这个递推式。 修正递推式时又要分两种情况 $cur=0$，我们直接构造一个递推式 $R_1=\\{r_1,r_2,r_3,…,r_n\\}$，其中 $r_1=r_2=\\cdot\\cdot\\cdot=r_n=0$ $cur\\not=0$，考虑构造一个增量构造式$R_{\\Delta}$满足$R_{cur+1}=R_{cur}+R_{\\Delta}$，接下来我们将对如何构造$R_{\\Delta}$展开讨论。 定义$fail_{i}$表示递推式$R_{i}$出错的最早位置，那么此时按照定义$fail_{cur}=n$。 假设$R_{\\Delta}$一共有$m’$项，考虑$R_{\\Delta}$要满足的条件： $\\Delta n=\\sum\\limits_{i=1}^{m’}R_{\\Delta,i}a_{n-i}$ $\\forall m’&lt;k&lt;n,0=\\sum\\limits_{i=1}^{m’}R_{\\Delta,i}a_{k-i}$ 考虑到$R_{best}$这个递推式满足类似的条件，其中 $best$ 是满足 $fail_{best}-len_{best}$ 最小的一项： $\\Delta fail_{best}=a_{fail_{best}}-\\sum\\limits_{i=1}^{m_{best}}R_{best,i}a_{fail_{best}-i}$ $\\forall m_{best}&lt;k&lt;fail_{best},0=a_k-\\sum\\limits_{i=1}^{m_{best}}R_{best,i}a_{k-i}$ 我们设$t=\\frac{\\Delta n}{\\Delta fail_{best}},b=\\{t,-t\\times r_{best,1},-t\\times r_{best,2},…,-t\\times r_{best,m_{best}}\\}$ 这启示我们按照如下方式构造$R_{\\Delta}$： $\\forall fail_{best}&lt;k&lt;n$，我们给$a_{n-k}$分配$0$作为系数 $\\forall fail_{best}-m_{best}\\le k\\le fail_{best}$,我们给$a_{n-k}$分配$b_{fail_{best}-k+1}$作为系数。 这样构造出来的数列 R_{\\Delta}=\\{0,0,...,0,t,-t\\times r_{best,1},-t\\times r_{best,2},...,-t\\times r_{best,m_{best}}\\}满足条件 再让$R_{cur+1}=R_{cur}+R_{\\Delta}$即可。 由于最坏情况下可能会修改$O(n)$次，所以复杂度$O(n^2)$","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"old driver tree","slug":"ODT","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-11T15:33:20.414Z","comments":true,"path":"ODT/","link":"","permalink":"http://ldxcaicai.github.io/ODT/","excerpt":"","text":"ODT简介ODT(old driver tree 老驱动树)又名珂朵莉树 是由$codeforces$上一位叫做$ODT$的用户提出的一种基于平衡树的暴力数据结构。（实际上就是 $lxl$ 这个数据结构的玄妙之处在于它并没有稳定的时间复杂度，因此只有在数据随机/水的情况下才会有较好的表现。 实现前提&amp;&amp;实现原理前提是必须要有区间覆盖操作且数据较随机/水 实现原理：将元素相同的区间推平一起处理，即如果区间$[l,r]$中的所有数$[a_l,a_{l+1}…a_r]$全部相同的话就将这个区间的信息用一个节点表示。 从上述描述可以看出这个数据结构是非常暴力玄学的 初始化然后对于每段区间我们可以用一个三元组$[l,r,v]$来表示它的左/右端点和整个区间的值，然后对于这些区间的信息可以用一个$set$来维护。 下面谈谈$ODT$两个重要的操作$split$和$assign$ split操作$ODT$的$split$函数$split(pos)$表示把$pos$所在的这个区间$[l,r,v]$分成$[l,pos-1,v]$和$[pos,r,v]$并且返回后者的迭代器。 实现很简单直接二分找出$pos$所在的区间然后加几个小特判。 assign操作$ODT$最核心的操作$assign$，$assign(l,r,v)$表示把区间$[l,r]$全部赋值为$v$并且会将这$r-l+1$个点合并成一个$ODT$节点插入到$ODT$中，由于数据随机的时候$ODT$中节点会快速减少，因此$ODT$复杂度此时十分接近$O(n\\log n)$具体实现可以通过上面提到的$split$函数。 其它操作至此，与$ODT$相关的操作已经基本讲完了。 剩下的操作与$ODT$本身关系并不大，相当于就是遍历每一个$ODT$节点暴力进行修改和查询。它可以支持的操作（懒得放代码了）： 区间第k小区间加区间所有数的k次方和区间…","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"AAA tree","slug":"AAA-tree","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-15T14:31:38.445Z","comments":true,"path":"AAA-tree/","link":"","permalink":"http://ldxcaicai.github.io/AAA-tree/","excerpt":"","text":"AAA树引入在学习了 $LCT$ 之后，树上一些常见的问题已经不能满足选手们的需求，从而出现了这样一道题： [bzoj3153]Sone1 它要求选手们维护子树覆盖，子树加，子树最值，子树和，链覆盖，链加，链最值，链和，换父亲，换根这十二个基本操作 假如没有换父亲的确是树链剖分的基本操作 假如没有子树修改与查询的确是 $LCT$ 的基本操作 然而现在都有了 于是就有了 $AAA$ 树和 $toptree$ 来解决上述问题，由于笔者现在并不会后者，因此该篇文章主要讲述 $AAA$ 树的原理与实现 原理 $LCT$ 无法解决子树问题的原因是它只维护了实链的信息而子树问题要涉及到虚子树的信息 在静态树问题中，有链分治这种分治方法，其原理是用不同的数据结构对重链和实链分开进行维护并及时合并轻重链信息 考虑对每个 $LCT$ 上的点建一个数据结构来统计其虚子树的信息，它要具备如下功能： 能够快速删除与加入新的节点 能够快速合并其管辖点的信息 不难想到建出一棵平衡树来维护其虚子树的信息，在这里笔者选择使用 $splay$ ，我们将原树进行改造，使得每个点 $p$ 有四个儿子，其中 $son_{p,0/1}$ 表示维护其实链 $LCT$ 的儿子，而 $son_{p,2/3}$ 分别是维护其虚子树的 $splay$ 的根，对于维护虚子树的节点，我们强制其在 $splay$ 的叶节点，下面是一个简单的例子： 原树：$AAA$ 树： 现在要实现加点和删点进其虚儿子所在的 $splay$ 加点：将该点插入 $splay$ 中（可能会新建一个如上图中的 $A$ 节点）删点：若该点父亲是 $A$ 点，就删掉该点和其父亲，并将自己的兄弟放到父亲的位置，否则直接删掉该点即可 然后 $access$ 操作就直接在换右儿子的时候利用上述两个函数即可，加点对应将实边换成虚边，删点对应将虚边换成实边 维护标记： 每个节点记录以下三种信息： $cha,sub,all$ 表示实链的信息，整棵实 $splay$ 上面挂着的所有虚子树的信息，以及整棵子树的信息 $pushup$ 操作： \\begin{aligned} cha=&son[0]->cha+son[1]->cha\\\\ sub=&son[0]->sub+son[1]->sub+son[2]->all+son[3]->all\\\\ all=&cha+sub\\\\ \\end{aligned}简单易懂 先要维护两个维护树形态的标记： $rev,inr$ 分别表示翻转标记以及其是否是 $A$ 点 然后要维护两个标记 $All,Cha$ $All$ 表示对整棵子树进行的修改，但不修改实链的信息， $Cha$ 表示对实链进行修改 $All$ 标记在传实儿子的时候不修改链，在传虚儿子的时候要修改链 $cut(v)$ 操作： $access(fa_v)$ ，然后在其虚 $splay$ 中删掉 $v$ $link(u,v)$ 操作：$access(v)$ ，然后把 $u$ 加进其虚 $splay$ 中 链操作同 $LCT$ ，不过只跟 $cha$ 有关 子树操作：修改/查询点 $u$ 的时候，直接 $access(u)$ ，然后其子树信息都在虚 $splay$ 中，用 $u$ 的单点信息和其虚子树信息拼接起来即可 这样就可以尝试解决该题或者直接去世了","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"segement tree trick","slug":"SGTtrick","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-11T15:30:11.450Z","comments":true,"path":"SGTtrick/","link":"","permalink":"http://ldxcaicai.github.io/SGTtrick/","excerpt":"","text":"SGTtrick$By\\ 蒟蒻\\ ldxcaicai$ Chapter 1.关于线段树操作的一些分析我们知道，线段树有两个核心的函数$pushdown$和$pushup$。 以及两类对于一段区间进行操作的函数$update$和$query$ 博主在这里简单讲一下几个函数的功能： 首先我们假设用$Val$表示维护信息的类型，$Tag$表示懒标记的类型。 显然一个线段树节点（类型为$Node$）是由一个$Val$元素和一个$Tag$以及表示区间管辖范围的$l,r$构成的。 123struct Tag&#123;...&#125;;struct Val&#123;...&#125;;struct Node&#123;Val val;Tag tag;int l,r;&#125;T[N&lt;&lt;2]; $pushdown(int\\ p)$表示将$p$的标记下传给$p$的儿子并更新它们的信息和标记 $pushup(int\\ p)$表示把$p$儿子的信息合并成$p$的信息 $query(int\\ p,int\\ ql,int\\ qr)$表示查询区间$[ql,qr]$的一些信息 $update(int\\ p,int\\ ql,int\\ qr,Tag\\ v)$表示用标记$v$对区间$[ql,qr]$的信息和标记进行更新 可以看出来这些函数分成两类： 父亲朝儿子转移：$update,pushdown$ 儿子朝父亲转移：$query,pushup$ 而我们继续将这几个函数的功能进行拆分并取上并集（雾，发现它其实是这几个东西的组合： 两个$Val$类型的元素的合并 一个$Tag$类型的元素对一个$Val$类型的元素的更新 一个$Tag$类型的元素对一个$Tag$类型的元素的更新123456inline Tag operator+(const Tag&amp;a,const Tag&amp;b)&#123;...&#125;inline void operator+=(Tag&amp;a,const Tag&amp;b)&#123;a=a+b;&#125;inline Val operator+(const Val&amp;a,const Tag&amp;b)&#123;...&#125;inline void operator+=(Val&amp;a,const Tag&amp;b)&#123;a=a+b&#125;inline Val operator+(const Val&amp;a,const Val&amp;b)&#123;...&#125;inline void operator+=(Val&amp;a,const Val&amp;b)&#123;a=a+b;&#125; 如果我们对这几个操作重载运算符的话，那么上述函数的实现就很简单了，为了让实现更加简便可以设计一个$pushnow函数$。 $pushup$函数：把儿子的$Val$合并成自己的$Val$。 123inline void pushup(int p)&#123; T[p].val=T[lc].val+T[rc].val;&#125; $pushnow$函数：$pushnow(int\\ p,Tag\\ v)$表示用标记$v$更新节点$p$的信息和标记。代码： 123inline void pushnow(int p,Tag v)&#123; T[p].val+=v,T[p].tag+=v;&#125; $pushdown$函数：用自己的$Tag$去更新儿子的$Val$和$Tag$ 12345inline void pushdown(int p)&#123; if(check(T[p].tag))return; pushnow(lc,T[p].tag),pushnow(rc,T[p].tag); T[p].tag=tag_empty;&#125; $query$函数：把要查询的区间拆成线段树上至多$log$个区间把它们的$Val$按一定顺序合并起来。 12345678inline Val query(int p,int ql,int qr)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return val_empty; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)return T[p].val; pushdown(p); if(qr&lt;=mid)return query(lc,ql,qr); if(qr&gt;mid)return query(rc,ql,qr); return query(lc,ql,qr)+query(rc,ql,qr);&#125; $update$函数：把要修改的区间拆成线段树上至多$log$个区间分别用给出的$Tag$更新它们的$Tag$和$Val$。 123456789inline void update(int p,int ql,int qr,Tag v)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)return pushnow(p,v); pushdown(p); if(qr&lt;=mid)update(lc,ql,qr,v); else if(ql&gt;mid)update(rc,ql,qr,v); else update(lc,ql,qr,v),update(rc,ql,qr,v); pushup(p);&#125; 所以当你拿到一道线段树题的时候，思考上述三种运算符如何重载即可$qwq$。 那么最后我们给上一波上述所有内容合起来的伪代码：才不会告诉你这是一个通用的框架呢 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859namespace SGT&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (T[p].l+T[p].r&gt;&gt;1) struct Tag&#123;...&#125;; struct Val&#123;...&#125;; const Tag tag_empty=(Tag)&#123;...&#125;; const Val val_empty=(Val)&#123;...&#125;; inline Tag operator+(const Tag&amp;a,const Tag&amp;b)&#123;...&#125; inline void operator+=(Tag&amp;a,const Tag&amp;b)&#123;a=a+b;&#125; inline Val operator+(const Val&amp;a,const Tag&amp;b)&#123;...&#125; inline void operator+=(Val&amp;a,const Tag&amp;b)&#123;a=a+b&#125; inline Val operator+(const Val&amp;a,const Val&amp;b)&#123;...&#125; inline void operator+=(Val&amp;a,const Val&amp;b)&#123;a=a+b;&#125; struct Node&#123;Val val;Tag tag;int l,r;&#125;T[N&lt;&lt;2]; inline bool check(const Tag&amp;v)&#123;...&#125; inline void pushdown(int p)&#123; if(check(T[p].tag))return; T[lc].val+=T[p].tag,T[lc].tag+=T[p].tag; T[rc].val+=T[p].tag,T[rc].tag+=T[p].tag; T[p].tag=tag_empty; &#125; inline void pushup(int p)&#123; T[p].val=T[lc].val+T[rc].val; &#125; inline void build(int p,int l,int r)&#123; T[p]=(Node)&#123;val_empty,tag_empty,l,r&#125;; if(l==r)&#123; T[p].val=(Val)&#123;...&#125;; return; &#125; build(lc,l,mid); build(rc,mid+1,r); pushup(p); &#125; inline void update(int p,int ql,int qr,Tag v)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)&#123; T[p].val+=v,T[p].tag+=v; return; &#125; pushdown(p); if(qr&lt;=mid)update(lc,ql,qr,v); else if(ql&gt;mid)update(rc,ql,qr,v); else update(lc,ql,qr,v),update(rc,ql,qr,v); pushup(p); &#125; inline Val query(int p,int ql,int qr)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return val_empty; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)return T[p].val; pushdown(p); if(qr&lt;=mid)return query(lc,ql,qr); if(qr&gt;mid)return query(rc,ql,qr); return query(lc,ql,qr)+query(rc,ql,qr); &#125; #undef lc #undef rc #undef mid&#125; Chapter 2.线段树的两种写法吐槽：我吐我自己这里简单谈一谈线段树的两种实现方法：$dfs$版和$bfs$版，其中后者为我瞎$yy$的，经过测试实际效果跟$dfs$版差距不大。 我才不会告诉你们我测出来很多题用第二种写法要慢一些呢 好吧我承认我发现的这种$bfs$版写法很鸡肋。 正题众所周知，搜索有几种顺序，其中有两种很著名分别叫做$dfs$和$bfs$。 而我们的常规线段树就是使用的$dfs$序。 然而在博主的努力尝试下，$bfs$序也是可以处理的。 为什么呢？ 因为在$Chapter\\ 1$中我们已经谈到过线段树的$query$和$update$操作的本质了： $query$函数：把要查询的区间拆成线段树上至多$log$个区间把它们的$Val$按顺序合并起来。 $update$函数：把要修改的区间拆成线段树上至多$log$个区间分别用给出的$Tag$更新它们的$Tag$和$Val$。 这样的话，只要按照顺序把这$log$段区间找到再合起来一定就可以维护所有的操作。 因为按照$bfs$版本的顺序来合并也是正确的。 如何维护顺序？用一个队列即可。 于是我们可以给出$bfs$版的一些框架，这里跟$dfs$版本相同的函数就不拿上来了。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152namespace SGT&#123; ... int q[N&lt;&lt;2],hd,tl; inline void build(int n)&#123; q[hd=tl=1]=1,T[1]=(Node)&#123;val_empty,tag_empty,1,n&#125;; while(hd&lt;=tl)&#123; int p=q[hd++]; if(T[p].l==T[p].r)&#123; T[p].val=(Val)&#123;...&#125;; continue; &#125; T[lc]=(Node)&#123;val_empty,tag_empty,T[p].l,mid&#125;; T[rc]=(Node)&#123;val_empty,tag_empty,mid+1,T[p].r&#125;; q[++tl]=lc,q[++tl]=rc; &#125; for(ri i=tl;i^1;--i)T[q[i]&gt;&gt;1].val+=T[q[i]].val; &#125; inline void update(int p,int ql,int qr,Tag v)&#123; q[hd=tl=1]=1; while(hd&lt;=tl)&#123; int p=q[hd++]; if(ql&gt;T[p].r||qr&lt;T[p].l)continue; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)&#123; pushnow(p,v); continue; &#125; pushdown(p); if(qr&lt;=mid)q[++tl]=lc,T[p].val=T[rc].val; else if(ql&gt;mid)q[++tl]=rc,T[p].val=T[lc].val; else q[++tl]=lc,q[++tl]=rc,T[p].val=val_empty; &#125; for(ri i=tl;i^1;--i)T[q[i]&gt;&gt;1].val+=T[q[i]].val; &#125; inline Val update(int p,int ql,int qr,Tag v)&#123; Val ret=val_empty; q[hd=tl=1]=1; while(hd&lt;=tl)&#123; int p=q[hd++]; if(ql&gt;T[p].r||qr&lt;T[p].l)continue; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)&#123; ret+=T[p].val; continue; &#125; pushdown(p); if(qr&lt;=mid)q[++tl]=lc; else if(ql&gt;mid)q[++tl]=rc; else q[++tl]=lc,q[++tl]=rc; &#125; return ret; &#125; ...&#125; 经过我们的努力改动，代码量成功翻了一倍！！！(滑稽$That’s\\ all$$Thank\\ you$","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"polynomial","slug":"poly","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-16T00:18:56.688Z","comments":true,"path":"poly/","link":"","permalink":"http://ldxcaicai.github.io/poly/","excerpt":"","text":"多项式的运算多项式的加减法，数乘这个大家应该都会吧不推了。 多项式乘法这个大家应该都会吧还是推一推吧。已知的：$A(x)=\\sum_{i=0}^na_ix^i$$B(x)=\\sum_{i=0}^mb_ix^i$要求的：$C(x)=A(x)B(x)=\\sum_{i=0}^{n+m}(\\sum_{j=0}^{min\\{i,n\\}}a_j\\times b_{i-j})x^i$ 显然直接暴力做是$O(n^2)$的，考虑如何优化。 那么我们使用$fft$或者$ntt$来实现点值表示法和系数表示法之间的快速转化。 为了方便起见，我们将$A,B$的最高次数统一成一个$2$的幂（对于超过$n/m$的项的系数看成0即可） 所谓的系数表示法就是我们平常用的那种。 而点值表示法，就是把这个多项式理解成一个函数，用这个函数上的若干个点的坐标来描述这个多项式:$f(x)=(x_0,y_0),(x_1,y_1),…,(x_n,y_n)=p_0,p_1,p_2,…,p_n$ 假设我们已经将$A,B$两个函数转化成了点值表示，于是就可以马上求出$C$的点值表示：$A(x)=(x_{a,0},y_{a,0}),(x_{a,1},y_{a,1}),…,(x_{a,n-1},y_{a,n-1})=p_{a,0},p_{a,1},…,p_{a,n-1}$$B(x)=(x_{b,0},y_{b,0}),(x_{b,1},y_{b,1}),…,(x_{b,n-1},y_{b,n-1})=p_{b,0},p_{b,1},…,p_{b,n-1}$那么$C(x)=p_{a,0}\\times p_{b,0}, p_{a,1}\\times p_{b,1},…,p_{a,n-1}\\times p_{b,n-1}=p_{c,0},p_{c,1},…,p_{c,n-1}$然后再把$C(x)$还原成系数表达式即可。注意：我们需要保证$x_{ai},x_{bi}$互不相同 现在就只用考虑如何实现点值表示和系数表示的互换了。也就是如何用更少的计算次数来求出$n$个不同的$x$值对应的$y$值。考虑有一个具有特殊性质的东西：单位根单位根保证了$w_n^0,w_n^1,…,w_n^{n-1}$是互不相同的并且有$w_n^{ij}=(w_n^i)^j$而原根在模数为质数$p$的时候也有$g^0,g^1,g^2,…,g^{n-1}$是互不相同的并且$g^{ij}\\equiv (g^i)^j \\mod p$这满足了我们上面的性质，因此我们考虑将$w_n^0,w_n^1,…w_n^{n-1}$作为$x_0,x_1,…x_{n-1}$带入求点值。 然后要用到两个引理： 折半引理：$w_n^{k\\times 2}=w_{\\frac n2}^k$(n为偶数 ) 消去引理：$w_n^{k}=-w_n^{k+\\frac n2}$ 这两个引理可以画个单位圆简单证明 然后利用按照下标的奇偶性来进行分治处理： $f(x)=\\sum_{i=0}^na_ix^i$$\\Rightarrow f(w_n^k)=\\sum_{i=0}^na_i w_n^{ik}$$\\Rightarrow f(w_n^k)=\\sum_{i=0}^{\\frac n2-1}a_{2i}w_n^{2ik}+w_n^k\\sum_{i=0}^{\\frac n2-1}a_{2i+1}w_n^{2ik}$ 同时又有： $f(w_n^{k+\\frac n2})=\\sum_{i=0}^{\\frac n2-1}a_{2i}w_n^{2ik}-w_n^k\\sum_{i=0}^{\\frac n2-1}a_{2i+1}w_n^{2ik}$ 这一步需要用到引理 所以我们只要算出两个重新分配了系数的多项式的值就可以了。显然一直分下去只有$log$层。于是总时间复杂度$O(nlogn)$ 注意到递归的效率很低，我们可以预处理最后一层的系数的位置然后用迭代的方式还原回去来优化常数 原理：我们发现分治完之后相当于将$i$和$i$对应的二进制数在$lim$下反转之后对应的新二进制数$i’$这两个位置的系数$a_i,a_i’$交换了位置。这就成功的实现了系数转点值。 下面来看点值转系数： 注：下面的图片有几点没写清楚： 最后的时候$e_{i,i}=0,e_{i,j|i\\not=j}$ 那个$I_n$指的就是 $n\\times n$ 的单位矩阵。 以上是$fft$的证明，$ntt$同理。 多项式求逆 定义：对于一个多项式$A(x)$，如果存在一个多项式$B(x)$，满足$B(x)$的次数小于等于$A(x)$且$A(x)B(x)≡1 \\mod x^n$，那么我们称B(x)为$A(x)$在模$x^n$意义下的逆元，简单记作$A^{−1}(x)$ 求法：$n=1?$那不就是$c$的逆元么。 $n&gt;1?$我们令$B(x)=A^{-1}(x)$ 那么有$A(x)B(x)\\equiv 1 \\mod x^n$然后可以用类似倍增的方法求。 假设我们已经知道$C(x)$满足$A(x)C(x)\\equiv 1\\mod x^{\\frac n2}$（这里的$\\frac n2$都是向上取整） 显然$A(x)B(x)\\equiv 1\\mod x^{\\frac n2}$是成立的。 我们将两式相减： $A(x)(B(x)-C(x))\\equiv 0\\mod x^{\\frac n2}$ 所以$B(x)-C(x)\\equiv 0\\mod x^{\\frac n2}$ 然后将两边平方： $B^2(x)-2B(x)C(x)+C^2(x)\\equiv 0\\mod x^{\\frac n2}$ =&gt;$B^2(x)-2B(x)C(x)+C^2(x)\\equiv 0\\mod x^n$ 这一步很关键，请神犇们仔细思考原因 然后两边同时乘上$A(x)$ =&gt;$B(x)-2C(x)+A(x)C^2(x)\\equiv 0\\mod x^n)$ 于是$B(x)\\equiv2C(x)-A(x)C^2(x)\\mod x^n$ 乘法可以用$fft/ntt$加速，因为每次递归的时候多项式最高次项都减少一半，所以总复杂度仍然是 $O(nlogn)$ 一道板题：洛谷4238 多项式求导默认大家都会函数求导 这个多项式求导属于最简单的那一种 对于一个多项式$f(x)=\\sum_{i=0}^na_ix^i$ 它求导的结果$f’(x)=\\sum_{i=0}^{n-1}(i+1)a_{i+1}x^i$ 于是直接模拟即可。 多项式积分相当于是多项式求导的逆运算。对于一个多项式$f(x)=\\sum_{i=0}^na_ix^i$ 它求导的结果$\\int\\mathrm f(x)dx=\\sum_{i=1}^{n+1}\\frac{a_{i-1}}ix^i$ 可以看出来一个函数的导函数积分起来等价于自己。 多项式取对我们令$g(x)=lnf(x)$那么根据链式法则求导知：$g’(x)=\\frac{f’(x)}{f(x)}$我们已经会多项式求逆和多项式积分，多项式求导了，于是就成功解决了多项式取对。 多项式取exp这个时候我们要提到一个重要的方法：牛顿迭代法 假设我们要求$h(B(x))\\equiv A(x) \\mod x^n$中的$B(x)$ 现在考虑构造有一个以多项式为变量的函数$g(f)=h(f)-A$ 那么要求的就是$g(f)$模$x^n$意义下的零点。 假设已经求出了$g(f)$模$x^{\\left\\lfloor\\frac x 2\\right\\rfloor}$的零点$f_0$那么现在$g(f_a)=g(f_0)+g’(f_0)(f_a-f_0)+\\frac{g’’(f_0)}2(f_a-f_0)^2+…$ 由于$f_0$是模$x^{\\left\\lfloor\\fracx 2\\right\\rfloor}$的零点，所以有：$g(f_a)\\equiv g(f_0)+g’(f_0)(f_a-f_0)\\equiv0\\mod x^{n}$ 所以移项后发现$f_a=f_0-\\frac{g(f_0)}{g’(f_0)}$ 这个东西有什么用呢？ 我们简单举个例子： 比如说多项式求逆，可以构造$g(f)=\\frac1f-A$，算出来$f_a=2f_0-Af_0^2$。 再比如说现在要求的多项式取$exp$:构造$g(f)=e^f-A$，算出来$f_a=f_0(1-lnf_0+A)$ 然后就做完了。 多项式开方直接使用上面所说的牛顿迭代的结论，令$g(x)=f^2-A$，带入得到:$f_a=\\frac{f_0^2+A}{2f_0}$ 然后用多项式求逆搞一搞即可。 多项式的除法/取模现在有两个多项式: $A(x)=\\sum_{i=0}^na_ix^i,B(x)=\\sum_{i=0}^mb_ix^i,n&gt;m$ 要求出$C(x)=\\sum_{i=0}^{n-m}c_ix^i,D(x)=\\sum_{i=0}^td_ix^i,d&lt;m$，满足$A(x)=B(x)C(x)+D(x)$，其中$C(x)$类比商,$D(x)$类比余数。 感觉想法比较神奇。 对于一个多项式$f(x)$，我们定义一个$f_R(x)$表示将这个多项式的系数翻转之后得到的新多项式，如$f(x)=2x^3+3x^2+x+5$时，$f_R(x)=5x^3+x^2+3x+2$然后可以惊奇的发现：$f_R(x)=x^nf(\\frac1x)$ 然后就有$A(\\frac 1x)=B(\\frac 1x)C(\\frac 1x)+D(\\frac 1x)$ 所以$x^nA(\\frac 1x)=x^nB(\\frac 1x)C(\\frac 1x)+x^mD(\\frac 1x)$ 所以$A_R(x)=B_R(x)C_R(x)+D_R(x)\\times x^{n-m}$ 因此$A_R(x)\\equiv B_R(x)C_R(x)\\mod x^{n-m}$ 所以$C_R(x)\\equiv A_R(x) (B_R(x))^{-1} \\mod x^{n-m}$ $D(x)=A(x)-B(x)C(x)$ 分治FFT一个\\times 听起来挺高大上\\times 的东西，然而很简单。 前置知识：cdq分治，fft 考虑这样一个转移式子$f_0=0,f_i=\\sum_{j=1}^if_{i-j}g_j$，其中$g$数组已知，让你求$f$数组。 容易观察到，这个转移式是一个卷积的形式。 然而并不能直接$fft$因为$f$的转移跟自身有关，当然你可以使用我们马上下面讲的生成函数秒掉。 生成函数做法 我们对$f,g$构造生成函数$F(x),G(x)$那么$F(x)-f_0=G(x)F(x)$ 所以$F(x)=\\frac{f_0}{G(x)-1}$，直接上多项式求逆即可，时间复杂度为$O(nlog_n)$吊打分治FFT。 新的做法：分治FFT 假设现在要求的$f$值的下标为$[l,r]$，我们可以利用类似$cdq$分治的思想，先递归求出$[l,mid]$这一段的$f$值，然后考虑$[l,mid]$对$[mid+1,r]$的贡献，最后递归$[mid+1,r]$即可。 那么现在要考虑的就只有$[l,mid]$对$[mid+1,r]$的贡献啦！ 对于$f_i,i\\in[mid+1,r],f_j,j\\in[l,mid],f_i+=f_j\\times g_{i-j}$，然后把所有的放在一起考虑就成了一个卷积的形式。 于是我们将$f_{l,l+1,…,mid}$构成的多项式和$g_{0,1,…,r-l}$构成的多项式乘起来更新$f_{mid+1,mid+2,…,r}$即可。 然而时间复杂度为$O(nlog^2_n)$ 生成函数 前置知识：泰勒展开我对于生成函数的理解：生成函数就相当于对一个集合的表示： 一般生成函数(Ordinary Generating Function) 也就是大家常说的$OGF$: $F(x)=\\sum_{i=0}^{\\infty}a_ix^i$ 指数生成函数(Exponential Generating Function) 也就是大家常说的$EGF$: $F(x)=\\sum_{i=0}^{\\infty}a_i\\frac{x^i}{i!}$ 它们可以帮助我们处理一些组合问题。 两个经常用到的公式： $1+x+x^2+…=\\frac{1}{1-x}$ $1+x+x^3+…+x^n=\\frac{1-x^{n+1}}{1-x}$小学的等比数列求和公式 以及我们的泰勒展开公式。 解决组合问题的时候我们通常将$x^i$的系数看成值为$i$的数被凑出的方案数 事实上，我认为加法原理和乘法原理在生成函数上同样对应了具体的运算。 比如说现在我们要从集合$A_1,A_2,A_3,..,A_n$中选一个值为$i$的数出来问有多少种选法（加法原理），那么考虑这$n$个生成函数的和$C$，$C$中$x^i$的系数就是答案。 再比如说我们要从$A_1,A_2,A_3,…,A_n$中各选一个数加起来，问加和为$i$的方案数（乘法原理），那么考虑这$n$个生成函数的积$C$，$C$中$x^i$的系数就是答案。 是不是有点感觉了？ 我们举一个例子：正整数集$N=\\{1,2,3,4,…\\}$，元素的大小定义为它的数值，定义$SEQ(A)$ 是由$A$的元素排成的序列组成的集合，一个序列的大小定义为其元素大小总和，现在让我们求一求$SEQ(N)$。 $SEQ(N) = \\{正整数有序拆分\\}=\\{0,1,1+1,2,1+1+1,1+2, 2+1,3\\}$ 考虑构造一个函数$N(x)=x+x^2+…=\\frac x{1-x}$ 于是$SEQ(N)=1+N(x)+N^2(x)+…=\\frac 1{1-N(x)}=1+\\frac x{1-2x}=1+x+2x+4x^2+…$ 是不是感觉挺好用的 两道板题：bzoj3028,poj3734 多项式多点求值现在已知$f(x)=\\sum_{i=0}^na_ix^i$与$m$个数$b_1,b_2,…,b_m$。 求$f(b_1),f(b_2),…,f(b_m)$ 有很显然的$O(nm)$暴力做法，这里直接略过。 考虑构造一个函数$g_{l,r}(x)=\\prod_{i=l}^r(x-b_i)$ 那么$\\forall x_0\\in[l,r]$，有$f(x_0)=(f\\%g_{l,r})(x_0)$ 证明： 令$f(x)=g_{l,r}(x)\\times B(x)+R(x)=(x-x_0)\\times (\\frac{g_{l,r}(x)}{x-x_0}\\times B(x))+R(x)$当$x=x_0$时：$f(x_0)=0+R(x_0)=R(x_0)=(f\\%g_{l,r})(x_0)$ 有了这个结论就可以分治处理了。 多项式快速插值给出$n$个点$(x_i,y_i)$，求对应多项式。 有一种叫做拉格朗日插值的东西需要了解一下。 并且要会上面的多项式多点求值。 仔细观察拉格朗日插值的代数式： f(x)=\\sum_{i=1}^ny_i\\prod_{j=\\not i}\\frac{x-x_j}{x_i-x_j}\\\\考虑如何快速求$val_i=\\prod_{j=\\not i}(x_i-x_j)$ 构造函数$M(x)=\\prod_i(x-x_i)$ 则$val_i=\\lim\\limits_{x\\rightarrow x_i}\\frac{M(x)}{x-x_i}=\\lim\\limits_{x\\rightarrow x_i}\\frac{M’(x)}{(x-x_i)’}=\\lim\\limits_{x\\rightarrow x_i}M’(x)=M’(x_i)$ 于是我们可以用多点求值求出$val$数组。 现在讲拉格朗日插值的代数式恒等变形： f(x)=\\sum_{i=1}^ny_i\\prod_{j=\\not i}\\frac{x-x_j}{x_i-x_j}\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\sum_{i=1}^n\\frac{y_i}{val_i}\\prod_{j=\\not i}(x-x_j)\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =(\\sum_{i=1}^{mid}\\frac{y_i}{val_i}\\prod_{j=\\not i}(x-x_j))(\\prod_{i=mid+1}^n(x-x_i))\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ +(\\sum_{i=mid+1}^{n}\\frac{y_i}{val_i}\\prod_{j=\\not i}(x-x_j))(\\prod_{i=1}^{mid}(x-x_i))用分治$ntt$解决即可。 下降幂多项式乘法考虑求出如下两个多项式的乘积： $A(x)=\\sum_{i=0}^na_ix^{\\underline i},B(x)=\\sum_{i=0}^mb_ix^{\\underline i}$ 然后考虑把它们转成点值形式然后乘起来再转回去。 设现在$F(x)=\\sum_{i=0}^nf_ix^{\\underline i}，\\hat F(x)$为其点值的生成函数。 现在先考虑$x^{\\underline n}$的$EGF$ =\\sum_{i=0}^{\\infty}\\frac{i^{\\underline n}}{i!}x^i=\\sum_{i=0}^{\\infty}\\frac{1}{(i-n)!}x^i=\\sum_{i=n}^{\\infty}\\frac{1}i!x^{i+n}=x^ne^x然后有 \\hat F(x)=\\sum_{i=0}^{\\infty}\\frac{F(i)}{i!}x^i\\hat F(x)=\\sum_{i=0}^{\\infty}\\frac{x^i}{i!}\\sum_{j=0}^{\\infty}f_jj^{\\underline i}\\hat F(x)=\\sum_{i=0}^{\\infty}f_i\\sum_{j=0}^{\\infty}\\frac{x^j}{j!}i^{\\underline j}\\hat F(x)=\\sum_{i=0}^{\\infty}f_x^ie^x\\hat F(x)=e^x\\sum_{i=0}^{\\infty}f_ix^i于是就转化成了常规多项式乘法问题。 我们把$\\sum_{i=0}^{n}f_ix^i$这个多项式与$e^x$相乘就能得到点值的生成函数，同理，点值的生成函数乘上$e^{-x}$就能还原多项式。 因此可以结合$ntt/$暴力多项式乘法在$O(n\\log n)/O(n^2)$的时间内完成下降幂多项式乘法。 普通多项式转下降幂多项式已知普通多项式$A(x)=\\sum_{i=0}^na_ix^i$ 现在求下降幂多项式$B(x)=\\sum_{i=0}^nb_ix^{\\underline i}$使得$A(x)=B(x)$ 思路：考虑先多点求值，然后$iffp$即可求出对应的下降幂多项式。 下降幂多项式转普通多项式已知下降幂多项式$A(x)=\\sum_{i=0}^na_ix^{\\underline i}$ 现在求普通多项式$B(x)=\\sum_{i=0}^nb_ix^i$使得$A(x)=B(x)$ 思路：考虑先$ffp$转点值，然后快速插值即可求出对应的普通多项式。","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"Generating function","slug":"gf","date":"2019-09-25T14:25:20.000Z","updated":"2019-11-27T14:37:49.752Z","comments":true,"path":"gf/","link":"","permalink":"http://ldxcaicai.github.io/gf/","excerpt":"","text":"生成函数定义： 一般生成函数（OGF）一般用于处理组合问题（无标号） $F(x)=\\sum_{i=0}^{\\infty}f_ix^i$ OGF的运算假设现在有两类组合对象$A,B$ 首先考虑如何对它们取并 显然对于一个元素$t$，在$A$中出现了$a_t$次，在$B$中出现了$b_t$次，一共会出现$a_t+b_t$次 记为$C(x)=A(x)+B(x)$ 那么对应标号的系数相加即可 然后考虑如何求它们的笛卡尔积 假设$A,B$笛卡尔积为$C$，那么表示$C$中每个元素$c$都是由$A$中的一个元素$a$和$B$中的一个元素$b$拼成的二元组$(a,b),|c|=|a|+|b|$ 记为$C(x)=A(x)B(x)$ 在生成函数为有限项的时候用$FFT/NTT$多项式乘法即可 OGF生成序列现在有一类组合对象$A$，定义$seq(A)$ 是由$A$的元素排列成的序列组成的集合，一个序列的大小定义为其元素大小总和。$eg1:A=\\{“0”,”1”\\}$，$seq(A)=\\{all\\ 01\\ string\\}$$eg2:N^\\times=\\{1,2,3,…\\}$，元素的大小定义为它的数值，则$seq(N)=\\{正整数的有序拆分\\}$规定A 中不含大小为0 的元素，则$seq(A)=1+A+A^2+A^3+…=\\frac1{1-A}$ 指数生成函数(EGF)一般用于处理组合问题（有标号）常见带标号的组合对象：标号图，置换将两个元素$a,b$拼接起来，$|a|=n,|b|=m$无标号时，只有一种方法；带标号时，规定拼接时拼接对象内部相对标号顺序不变，而互相的标号可以改变，则有$\\frac{(n+m)!}{n!m!}=C_{n+m}^n$种方法 $F(x)=\\sum_{i=0}^{\\infty}f_i\\frac{x^i}{i!}$ EGF的运算并集：$C(x)=A(x)+B(x)$笛卡尔积：$C(x)=A(x)B(x)$对比系数后很好理解 EGF生成序列同$OGF$，$seq(A)=\\frac1{1-A}$ EGF生成集合集合与序列的区别：同样由$i$个$EGF$生成，集合的顺序不重要，序列的顺序确实确定的。因此由$i$个$EGF$生成的集合应该有一个$\\frac1{i!}$的系数。$set(A)=\\sum_{i=0}^{\\infty}\\frac{A^i}{i!}=e^{A}$ 生成函数计数置换计数一个置换是由若干轮换组成的集合。$k$轮换的个数有$(k-1)!$个，对应$EGF$为$(k-1)!\\frac{x^k}{k!}=\\frac{x^k}k$于是全体轮换的$EGF=\\sum_{i=0}^{\\infty}\\frac{x^k}k$设$f(x)=\\sum_{i=0}^{\\infty}\\frac{x^k}k$那么$f’(x)=\\sum_{i=0}^{\\infty}x^k=\\frac1{1-x}$那么$f(x)=\\int f’(x)\\,dx=\\int\\frac1{1-x}\\,dx=-\\ln(1-x)$根据定义，全体置换的$EGF$为$e^{f(x)}=e^{-\\ln(1-x)}=\\frac1{1-x}$这样看来，$k$置换的个数有$k!$个符合事实。如果限制每个轮换的大小都在集合$S$内呢？那么可生成置换的$EGF=e^{\\sum_{k\\in S}\\frac{x^k}k}$ 多项式$exp$即可 背包计数 有$\\sum_{i=1}^na_i$种物品，体积为$i$的物品有$a_i$种，每种物品有无限个。 有$\\sum_{i=1}^na_i$种物品，体积为$i$的物品有$a_i$种，每种物品有无限个。 有$n$种物品，第$i$种物品体积为$i$，第$i$种物品有$a_i$个。 对于所有$1\\le i\\le n$，回答选取物品体积为$i$的方案数。 均可在$O(n\\log n)$的时间内求解。 Q1体积为$i$的物品的生成函数为$\\sum_{j=0}^{\\infty}(x^i)^j=1+x^i+x^{2i}+\\cdot\\cdot\\cdot$那么答案的生成函数为$F(x)=\\prod_{i=1}^n(1+x^i+x^{2i}+\\cdot\\cdot\\cdot)^{a_i}=\\prod_{i=1}^n(\\frac1{1-x^i})^{a_i}$ 构造生成函数$A(x)=\\sum_{i=1}^na_ix^i$ 考虑用$ln$和$exp$转化。 \\begin{aligned}\\ln F(x)=&\\sum_{i=1}^na_i\\times(-\\ln(1-x^i))\\\\=&\\sum_{i=1}^na_i\\times(\\int(\\sum_{j=0}^{\\infty}(x^i)^j)\\,dx)\\\\=&\\sum_{i=1}^na_i\\times(\\sum_{j=1}^{\\infty}\\frac{(x^i)^j}j)\\\\=&\\sum_{j=1}^{\\infty}\\frac1jA(x^j)\\\\F(x)=&e^{\\ln F(x)}\\\\=&e^{\\sum_{j=1}^{\\infty}\\frac1jA(x^j)}\\end{aligned}$A(x^j)$中只有$\\left\\lfloor\\frac nj\\right\\rfloor$项有贡献。所以暴力调和计数算出幂对应的多项式然后加一个多项式$exp$即可。复杂度$O(n\\log n)$ Q2\\begin{aligned}F(x)=&\\prod_{i=1}^n(1+x^i)^{a_i}\\\\\\ln F(x)=&\\sum_{i=1}^na_i\\times\\ln(1+x^i)\\\\=&\\sum_{i=1}^na_i\\times(\\sum_{j=1}^{\\infty}(-1)^{j+1}\\frac{(x^i)^j}j)\\\\=&\\sum_{j=1}^{\\infty}\\frac{(-1)^{j+1}}jA(x^j)\\\\F(x)=&e^{\\ln F(x)}\\\\=&e^{\\sum_{j=1}^{\\infty}\\frac{(-1)^{j+1}}jA(x^j)}\\end{aligned}同$Q1$处理即可。 Q3\\begin{aligned}A(x)=&\\sum_{i=1}^{n}x^i\\\\B(x)=&\\sum_{i=1}^nx^{a_ii}\\\\F(x)=&\\prod\\limits_{i=1}^n(1+x^i+x^{2i}+\\cdot\\cdot\\cdot+x^{a_ii})\\\\=&\\prod\\limits_{i=1}^n\\frac{1-x^{(a_i+1)i}}{1-x^i}\\\\\\ln F(x)=&\\sum_{i=1}^n(\\ln(1-x^{(a_i+1)i})-\\ln(1-x^i))\\\\=&\\sum_{j=1}^{\\infty}\\frac 1j(A(x^j)-B(x^j))\\\\F(x)=&e^{\\ln F(x)}\\\\=&e^{\\sum_{j=1}^{\\infty}\\frac 1j(A(x^j)-B(x^j))}\\end{aligned}$A(x^j),B(x^j)$中只有$\\left\\lfloor\\frac nj\\right\\rfloor$项有贡献。于是同$Q1,2$处理即可。 树的计数求$n$个点的树的个数。 有标号无根树计数利用$prufer$数列可以知道答案为$n^{n-2}$ 有标号有根树计数先生成有标号无根树，然后有$n$种方案选出根节点，答案为$n^{n-2}\\times n=n^{n-1}$ 无标号有根树计数我们设出答案的生成函数$F(x)=\\sum_{i=0}^{\\infty}f_ix^i$，那么$f_i$对应$i$个点的答案。现在假设已经推出$f_{1,2,3,…,n}$，要推$f_{n+1}$。 考虑到$n+1$个点的有根树相当于$n$个点的森林加上一个根。那么我们只需要求出$n$个点森林的方案数。 由于点无标号，因此相同大小的树之间没有顺序，我们应当按照树的大小归类分别求出其生成函数然后来拼接这个森林。 由于大小为$k$的树对应的生成函数为$\\sum\\limits_{i}x^{ik}=\\frac1{1-x^k}$所以所有大小为$k$的树形成森林的生成函数为$c$ 那么$F(x)=x\\prod\\limits_{i=1}^{\\infty}(\\frac1{1-x^i})^{f_i}$ 果断上多项式取对： \\begin{aligned}F(x)=&x\\prod\\limits_{i=1}^{\\infty}(\\frac1{1-x^i})^{f_i}\\\\\\ln F(x)=&\\ln x-\\sum_{i=1}^{\\infty}f_i\\ln (1-x^i)\\\\ (\\ln F(x))'=&(\\ln x-\\sum_{i=1}^{\\infty}f_i\\ln (1-x^i))'\\\\\\frac{F'(x)}{F(x)}=&\\frac1x+\\sum_{i=1}^{\\infty}f_ii\\frac{x^{i-1}}{1-x^i}\\\\xF'(x)=&F(x)+F(x)(\\sum_{i=1}^{\\infty}f_ii\\frac{x^i}{1-x^i})\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj([x^{n-i}]\\frac{x^j}{1-x^j})\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj([x^{n-i}](\\sum_{k=1}^{\\infty}[j|k]x^k))\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj[j|n-i]\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj[j|n-i]\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j|n-i}f_jj\\\\f_n=&\\frac{\\sum_{i=1}^{n-1}f_i\\sum_{j|n-i}f_jj}{n-1}\\end{aligned}考虑令$g_n=\\sum_{i|n}f_ii$那么$f_n=\\frac{\\sum_{i=1}^{n-1}f_ig_{n-i}}{n-1}$于是可以分治$fft$处理$f$，枚举倍数更新$g$。时间复杂度$O(n\\log^2n)$ 无标号无根树计数你需要计算出有根树的答案，然后去世容斥。记$n$个点答案为$h_n$。 发现只有根节点是树的质心时我们才计算的话就不会算重。 若一个根不为质心，那么有且仅有一个子树大小大于$\\left\\lfloor\\frac n2\\right\\rfloor$，考虑容斥掉这些不合法的。然后要按$n$的奇偶性分类讨论一波： $n$为奇数：$h_n=f_n-\\sum\\limits_{i=1}^{\\left\\lfloor\\frac{n}2\\right\\rfloor}f_if_{n-i}$ $n$为偶数：此时可能存在两个质心，因此枚举到$i=\\frac n2$时只能减去两边不一样的情况，即$h_n=f_n-\\sum\\limits_{i=1}^{\\frac{n}2-1}f_if_{n-i}-\\binom{f_\\frac n2}2$ 时间复杂度$O(n\\log^2n)$ 概率生成函数对于一个随机离散变量 $X$ ，我们定义其概率生成函数 $f(z)=\\mathbb{E}(z^{X})=\\sum\\limits_{i=0}^{+\\infty}Pr(X=i)z^i$ 不难发现以下性质： \\begin{aligned}f(1)=&1\\\\f'(1)=&\\mathbb{E}(X)\\\\f^{(k)}(1)=&\\mathbb{E}(X^{\\underline{k}})\\\\Var(X)=&f''(1)+f'(1)-f'(1)^2\\end{aligned}对于掷骰子的问题我们一般用以下几种关系来建立等式： 设时刻 $i$ 结束的概率生成函数为 $F(x)$ ， 未结束的概率生成函数为 $G(x)$ 那么 \\begin{aligned}F(x)+G(x)=&\\cdot\\cdot\\cdot\\\\G(x)\\times(强制结束的概率)=&\\sum\\limits_{i}F(x)\\times(提前i步结束的概率)\\\\\\end{aligned}然后对第一个式子求导，对第二个等式带入 $x=1$ 即可 例题：[CTSC2006]歌唱王国,hdu4652 而在有多个终态的时候一般考虑如下方法变形： $min-max$ 容斥 利用 $\\sum\\limits_{i}F_i(1)=1$这个等式和之前的等式建立方程组跑高斯消元解方程 例题：[SDOI2017]硬币游戏","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]}]}