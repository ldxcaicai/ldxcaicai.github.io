{"meta":{"title":"è‡ªç”±ã‚’æ¸‡æœ›ã™ã‚‹","subtitle":"ã²ã¨ã‚Šã¼ã£ã¡","description":"Konjak_ldx's blog","author":"ldxcaicai","url":"http://ldxcaicai.github.io","root":"/"},"pages":[{"title":"å‹æƒ…é“¾æ¥","date":"2019-10-11T13:48:25.405Z","updated":"2019-10-11T13:48:25.405Z","comments":true,"path":"links/index.html","permalink":"http://ldxcaicai.github.io/links/index.html","excerpt":"","text":""},{"title":"æ ‡ç­¾","date":"2019-10-11T13:58:52.069Z","updated":"2019-10-11T13:58:52.069Z","comments":false,"path":"tags/index.html","permalink":"http://ldxcaicai.github.io/tags/index.html","excerpt":"","text":""},{"title":"åˆ†ç±»","date":"2019-10-11T13:19:45.009Z","updated":"2019-10-11T13:19:45.009Z","comments":false,"path":"categories/index.html","permalink":"http://ldxcaicai.github.io/categories/index.html","excerpt":"","text":"Githubgithub: username: ldxcaicai # github username"}],"posts":[{"title":"è¿½å¿†","slug":"remembrance","date":"2019-12-26T02:08:32.000Z","updated":"2019-12-26T02:56:37.844Z","comments":true,"path":"remembrance/","link":"","permalink":"http://ldxcaicai.github.io/remembrance/","excerpt":"","text":"About Backseat_Stargazeråˆè¯†åœ¨åˆä¸‰çš„æ—¶å€™ zgs è¯·äº† rxdoi åˆ° cdss è®²è¯¾ï¼Œæˆ‘å’Œ yk éƒ½å‰å¾€å¬è¯¾ï¼ŒæœŸé—´åœ¨ zgs çš„ä»‹ç»ä¸‹è®¤è¯†äº† zxy å’Œ cyk ï¼Œå¬è¯´äº† cyk ä¸€ä¸ªä¸‹åˆ+æ™šä¸Šä»é›¶åŸºç¡€å­¦å®Œç®€å•å›¾è®ºä»¥åŠæˆå®å¤–ä¸‰æ ¡åŒºæ–‡åŒ–è¯¾ rk å‰10 çš„ç¥ä»™äº‹è¿¹ã€‚ä½†å½“æ—¶ç”±äº cyk ä¸€ç›´åœ¨ç¡è§‰ï¼Œäºæ˜¯ä»–ä¸¤è¾¹çš„æˆ‘å’Œ zxy å°±å¸¸å¸¸ä¸€è„¸æ‡µé€¼çš„æœ›ç€ä»–ç¡è§‰ç„¶åç»§ç»­å¬è¯¾æˆ–è€…è®¨è®ºé¢˜ç›® åæ¥æœ¬äººè¯´æ˜¯ç”Ÿç—…äº†ï¼Œæˆ‘å€’æ˜¯è®¤ä¸ºä»–è§‰å¾—å¤ªç®€å•äº†ç´¢æ€§ä¸å¬äº† å°±è¿™æ ·ï¼ŒçŸ­æš‚çš„è®¤è¯†åˆé©¬ä¸Šå¿˜è®°äº† cyk ä¹‹åï¼Œæˆ‘å¼€å§‹é¢“åºŸç”Ÿæ´»å‡†å¤‡ä¸­è€ƒ å†ä¼šä¸­è€ƒä¹‹åæœç„¶åœ¨ cdsszx åˆè§é¢äº†ï¼Œè¿™æ¬¡ zgs å¹²è„†ç›´æ¥é’¦å®š cyk æˆä¸ºæœªæ¥çš„é‡‘ç‰Œé€‰æ‰‹äº† Orz ï¼Œè®©ä»–è·Ÿæˆ‘ä»¬å‡ ä¸ªä¸€èµ·æ··å­¦ä¹  OI ï¼Œç„¶åä¸­è€ƒæˆç»©å‡ºæ¥ä¹‹å yk å’Œ zyj å°±æºœäº†ï¼Œæˆ‘å› ä¸º cdqz ç¥ä»™å¤ªå¤šçš„åŸå› å°±ç•™ä¸‹äº†ï¼Œå‘ç°å‰å®³çš„å°±åªå‰©ä¸‹äº† cyk å’Œ zxy ï¼ˆå½“ç„¶æš‘å‡å¿«ç»“æŸæ—¶ lmy çªç„¶å˜å¼ºä»¥è‡³äºæ¯”è¾ƒå‰å®³çš„å˜æˆäº†å››ä¸ªäººï¼‰ï¼Œä¹‹åç”±äº cyk å‰ç½®çŸ¥è¯†å­¦è¿‡çš„å¤ªå°‘äºæ˜¯è·Ÿæˆ‘ä»¬åˆ†æˆäº†ä¸¤ä¸ªæ•™å®¤å¬è¯¾ï¼Œåé¢å¤§å®¶é›†ä¸­åœ¨ä¸€èµ·è€ƒè¯•æ„Ÿè§‰ cyk çš„è€ƒè¯•ä¹˜ç§¯è™½ç„¶ä¸æ€ä¹ˆç¨³å®šä½†æ˜¯å®åŠ›å¼€å§‹æŒ‡æ•°çº§ä¸Šå‡ç°åœ¨çœ‹æ¥å¯èƒ½ cyk å½“æ—¶åœ¨æˆ˜ç•¥æ€§çŠ¯ä¸€äº›å°é”™è¯¯ä»¥éšè—å®åŠ›ï¼Œä½†ç”±äºä»–ä¹˜ç§¯æ—¶é«˜æ—¶ä½æˆ‘å½“æ—¶è§‰å¾—è¿™ä¸ª cyk å¥½åƒæ²¡ zgs å¹é‚£ä¹ˆå‰å®³åæ¥æˆ‘å°±è¢«åŠèµ·æ¥é”¤äº†äºæ˜¯å°±å¼€å§‹ diss ä»–ç°åœ¨ä»–æœ‰èƒ½åŠ› diss æˆ‘ä½†ä¸€ç›´ä¸ dissã€‚æš‘å‡æœ«çš„æ—¶å€™ï¼Œcyk æ¥æ‰¾æˆ‘è¯´ä»–æƒ³å…¥é—¨çº¿æ®µæ ‘ï¼Œæˆ‘æ²‰æ€è®¸ä¹…ä¹‹åç»™ä»–æ¨èäº†ä¸€é“ siano ï¼Œç»“æœç”±äºä»£ç èƒ½åŠ›è¿˜æ²¡æœ‰èµ·æ¥çš„åŸå› ï¼Œ cyk ç¿»äº†ä¸‰é¡µçš„è½¦ï¼ˆæŒ‡æäº¤ä»£ç ï¼‰æ‰è¿‡ï¼Œæå¾—ç°åœ¨æ¯æ¬¡æˆ‘æ¨é¢˜éƒ½ä¼šè¢«ä»–åæ§½==ï¼Œç„¶åå¼€å­¦å­¦äº†ä¸€ä¸ªæœˆæ–‡åŒ–è¯¾ä¹‹åå°±å¼€å§‹åœè¯¾å†²åˆº NOIp ï¼ŒæœŸé—´æˆ‘ç”±äºåˆä¸­åšè¿‡çš„ sb å¤šä»¥åŠæ‰‹é€Ÿç›¸å¯¹å¿«ä¸€ç‚¹çš„åŸå› æ‹¿äº†å‡ æ¬¡ rk1 ï¼Œæ„Ÿè§‰å¿ƒæ€ç¨³å¥ï¼Œ cyk ä»ç„¶æ˜¯æ³¢åŠ¨æ›²çº¿ä¸è¿‡çœ‹èµ·æ¥æ¯”åŸæ¥å¼ºå¥½å¤šäº†ã€‚æ„Ÿè§‰åœè¯¾çš„æ—¶é—´ç®—æ˜¯æœºæˆ¿ç¾¤ä½“æ‰€æœ‰äººæ„Ÿæƒ…å¢è¿›æœ€è¿…é€Ÿçš„æ—¶é—´æ®µäº†åºŸè¯æœ¬æ¥å°±ä¸æ˜¯ä¸€ä¸ªç­çš„åªæœ‰è¿™ä¸ªæ—¶å€™æ‰æœ‰é‚£ä¹ˆå¤šæ—¶é—´æ‹¿æ¥äº¤æµï¼Œè®©æˆ‘å°è±¡æ·±åˆ»çš„æ˜¯æˆ‘å’Œ cyk æœ‰å‡ æ¬¡å‘¨æœ«éƒ½ç•™ä¸‹æ¥ä¸Šæ™šè‡ªä¹ è®¨è®ºé—®é¢˜åˆ° 10 ç‚¹è¿‡æ‰èµ°ï¼Œå°è±¡æœ€æ·±åˆ»çš„è¿˜æ˜¯æœ‰ä¸€æ¬¡è®¨è®ºæ¦‚ç‡æœŸæœ› dp å…¥é—¨é¢˜ï¼Œè²Œä¼¼æ¿€åŠ¨åœ°å·®ç‚¹åµèµ·æ¥äº†ï¼Œç„¶åå°± NOIp äº†å‘ç°è‡ªå·±èœçš„ä¸€æ‰¹çš„åŒæ—¶å·²ç»è¢« cyk åŠèµ·æ¥é”¤äº† ç„¶åæˆ‘å°±å­¦ä¼šäº†çœ‹ç•ª ç„¶åå»é›…ç¤¼å’Œç»å…´é›†è®­æ„Ÿè§‰æˆ‘å¯èƒ½ç›¸å¯¹å…¶ä»–å‡ ä¸ªæ›´æ“…é•¿æ‰“æš´åŠ›åˆ†è²Œä¼¼è¿˜æ˜¯é«˜ä¸€ç‚¹ï¼Œæœ‰ç‚¹é«˜å…´ï¼Œé‚£æ®µæ—¶é—´æ„Ÿè§‰ cyk å’Œ zxy å®åŠ›è¿˜æ˜¯æŒ‡æ•°çº§æå‡ï¼Œç„¶åå°±æœ‰äº†æ’åäº¤æ¢çš„æ„Ÿè§‰å§ï¼Œæ„Ÿè§‰å®åŠ›æ’åä»åˆšè¿›æ ¡çš„ ldx&amp;zxy,lmy&amp;cyk ï¼Œå˜æˆäº† zxy,cyk,ldx&amp;lmy ï¼Œç„¶åå°± scoi äº†ï¼Œæˆ‘ day2MLEçš„äº‹æƒ…å¤§å®¶éƒ½çŸ¥é“ä¸ç„¶æ’åè·Ÿzxyå·®ä¸å¤šï¼ˆè™½ç„¶å¯èƒ½ä¹Ÿè¿›ä¸äº†Dï¼‰ ï¼Œå¾—äº†ï¼Œç°åœ¨åˆ†æ•°æ’åä¹Ÿæˆ zxy,cyk,ldx&amp;lmy äº† ä¹‹åä¼‘æ¯äº†ä¸€æ®µæ—¶é—´ä¸Šäº†ä¸€æ®µæ—¶é—´æ–‡åŒ–è¯¾ä¹‹åå»ezé›†è®­ï¼Œæ…¢æ…¢æ„Ÿè§‰å®åŠ›æ°´å¹³å˜å›äº† zxy,ldx,cyk,lmy ï¼Œæ¨æµ‹åŸå› æ˜¯å› ä¸º cyk å’Œ lmy æœ‰ä¸€äº›ç®—æ³•æ²¡å­¦ä»¥åŠæœ‰ä¸€äº›æš´åŠ›ä¸æƒ³æ‰“ï¼Œä½†æ˜¯ç”±äºæœ¬äººå¤ªé¢“äº†ä»¥è‡³äºååŠæ®µé›†è®­ä¸æ€ä¹ˆæ”¹é¢˜ï¼Œæ…¢æ…¢çš„å®åŠ›å˜æˆäº† zxy,cyk,lmy,ldx å¤§å“­ï¼Œç½‘ç»œèµ›ç”±äºå…¶ä½™ä¸‰ä¸ªå‘æŒ¥å¤±è¯¯äº†å¥½åƒåˆæ‹¿äº†ä¸ªå››äººé‡Œçš„ rk1 ï¼Œäº‹åæ¯”è¾ƒå¿ƒæ€€ä¾¥å¹¸ noi è¿‡åå°±è¯·äººè®²è¯¾äº†ï¼Œç„¶åå¼€å­¦å¼€å§‹åœè¯¾ï¼Œå‘ç° zxy å®åŠ›æ¯”æˆ‘ä»¬ä»¨é«˜äº†å‡ ä¸ªæ¡£ï¼Œäºæ˜¯ä¹‹åçš„å®åŠ›è¯„æ¯” zxy ä¸å†å‚ä¸ï¼Œç”¨å­¦å¼Ÿ fsy çš„æ°´å¹³æ‹¿æ¥æ›¿ä»£ cdss çš„é›†è®­ç­–ç•¥å¤§æ¦‚æ˜¯è€ƒä¸¤å¤©ä¼‘æ¯ä¸€å¤©çš„æ ·å­ï¼Œè¿™å¯¼è‡´æˆ‘è¿™ç§ç»å¸¸ç†¬å¤œçš„ç¬¬äºŒå¤©è€ƒè¯•ä¸æ¸…é†’ï¼Œå› æ­¤å¾€å¾€è€ƒå‡ºæ¥çš„ä¹˜ç§¯æ’åæ˜¯ cyk&amp;fsy,lmy,ldx ï¼Œä½†æˆ‘å®é™…æ„Ÿè§‰æˆ‘åº”è¯¥è¿˜æ˜¯è·Ÿ lmy æ°´å¹³å·®ä¸å¤šå§ï¼Œç»“æœ CSP-S 2019 å‰æˆ‘çš„çŠ¶æ€å´©çš„æ›´å‰å®³äº†ï¼ŒåŸºæœ¬åœºåœºè€ƒä¸è¿‡è”èµ›ç»„ç¥ä»™ï¼Œå“å¾—æˆ‘ CSP-S å‰å‡ å¤©å¼€å§‹è½ä¹‹å‰çš„ NOIp çœŸé¢˜ æˆ‘ CSP-S å’Œ NOIp æœ‰ä¸ª P çš„å…³ç³»ï¼Œåœ¨ day0 ä¸Šåˆç»ˆäºè½å®Œäº†ï¼Œå¿ƒæ€å¥½äº†ä¸€ç‚¹æ„Ÿè§‰è¿˜æ˜¯æœ‰å¸Œæœ›ä¸Š 450 çš„ï¼ŒNMD,æœ€åè¿˜çœŸå°±æ²¡ä¸Š 450 ï¼Œç„¶åå°±æ˜¯è”èµ›äº†ï¼Œè€ƒå®Œæ„Ÿè§‰è€ƒäº†ä¸ªå¤§ä¼—åˆ†ä¼°è®¡åªèƒ½æ’ 30~50 åäº†ï¼Œ lmy å› ä¸ºç¿»è½¦ä¸¥é‡å¯èƒ½è¦é€€å½¹äº†ï¼Œ cyk åº”è¯¥åˆ†æ•°è·Ÿæˆ‘å·®ä¸å¤šï¼Œ zxy åº”è¯¥ç¨³äº†ã€‚ ç›´åˆ°ä¸‹åˆ cyk å‘Šè¯‰æˆ‘ä»– d1t2 åªæœ‰ 50 äº† ç„¶åå½“æ—¶æˆ‘çš„å¿ƒæƒ…æ˜¯éš¾ä»¥ç½®ä¿¡ï¼Œæ„Ÿè§‰å®åŠ›æ¯”æˆ‘å¼ºçš„ cyk ä¸å¯èƒ½ç¿»åœ¨è¿™ç§ sbt ä¸Šé¢ æœ€åè¿˜çœŸå°±ç¿»äº†ï¼ŒNMDWSM æ„Ÿè§‰ç”Ÿæ´»å°±åƒå¤šç±³è¯ºéª¨ç‰Œä¸€æ ·ï¼Œæ‰“ç¿»äº†æœ€å¼€å§‹çš„é‚£ä¸€å¼ ï¼Œå°±ä¼šäº§ç”Ÿä¸€ç³»åˆ—çš„è¿é”ååº”ï¼š cyk æ²¡æœ‰è·Ÿæˆ‘ä»¬ä¸€èµ·å»ezå‚åŠ å†¬ä»¤è¥é›†è®­ cyk è€ƒäº† pkuwc ä¸€ç­‰å¥–çš„çº¿ä½†ç”±äºæ˜¯éæ­£å¼è¥å‘˜ä¸èƒ½é¢†å¥– cyk ç°åœ¨å›å»ä¸Šäº†æ–‡åŒ–è¯¾ MD PKU è¿™ä¸ªæ“ä½œçœŸ TMZZï¼Œæ˜æ˜éƒ½è·Ÿ cyk çº¦å¥½äº† day2 ç¿»ç›˜ï¼ˆå¹¶ä¸”æˆ‘ä¿©è¿˜çœŸç¿»äº†ï¼‰ç»“æœçªç„¶æ¥ä¸ªä¸èƒ½æ‹¿å¥–ï¼Ÿï¼Ÿï¼Ÿ å¯èƒ½è¿™å°±æ˜¯å‘½è¿å¯¹å¼ºè€…çš„æƒ©ç½šå§ æ‰€å¹¸çš„æ˜¯ cyk å¯’å‡å¤å½¹ï¼Œè¿˜èƒ½ä¸€èµ·æˆ˜æ–—ï¼Œè¿˜èƒ½é—® cyk æ²™é›•é—®é¢˜ï¼Œè¿˜èƒ½æœ‰æœºä¼šå’Œä»–äº’ç›¸å£åèŠ¬èŠ³ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘è¿˜æ˜¯å¾—æå‡è‡ªå·±æ°´å¹³ä»¥è‡³äºåˆ°æ—¶å€™ä¸ä¼šå¬ä¸æ‡‚ cyk å’Œ zxy åœ¨è®²ä»€ä¹ˆç¥ä»™ä¸œè¥¿ ï¼ˆä¸è¿‡ä½ çœ‹çœ‹æˆ‘ç°åœ¨å†™è¿™ç¯‡ä¸çŸ¥é“åœ¨å†™ä»€ä¹ˆçš„ä¸œè¥¿çš„æ—¶å€™ zxy åˆåšäº†å¥½å‡ é“é¢˜äº†ï¼Œæˆ‘è¿˜å•¥éƒ½æ²¡åšï¼Œå®åŠ›å·®è·æ²¡æ³•å¼¥è¡¥å•Šï¼‰","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"éšç¬”","slug":"éšç¬”","permalink":"http://ldxcaicai.github.io/tags/éšç¬”/"}]},{"title":"PKUWC2020æ¸¸è®°","slug":"pkuwc2020","date":"2019-12-23T23:34:57.000Z","updated":"2019-12-24T00:10:02.650Z","comments":true,"path":"pkuwc2020/","link":"","permalink":"http://ldxcaicai.github.io/pkuwc2020/","excerpt":"","text":"æ‰€ä»¥è¿™æ¬¡å†¬ä»¤è¥åˆ°åº•å«å•¥å•Šè¿™ä¸è¿˜æ˜¯19å¹´å—== Day0åé£æœºå»é¦–éƒ½ï¼Œç„¶åæ„Ÿè§‰äººè¢«å†»æ²¡äº†233 è¿™æ¬¡å‚åŠ  pkuwc çš„æœ‰æˆ‘,cyk,fsy,hwj ä¸­åˆå’Œæ•™ç»ƒåƒå®Œé¥­ä¸‹åˆè·‘å»æŠ¥åˆ°ï¼Œç»“æœ zxy å› ä¸ºæ²¡äº‹å¹²è·Ÿç€æˆ‘ä»¬å»æŠ¥åˆ°ï¼ˆå…¶å®æ˜¯å‡†å¤‡å˜²è®½æˆ‘ä»¬ï¼‰ ï¼Œç»“æœæ’é˜Ÿçš„äººå¤ªå¤šæˆ‘,cyk,fsyç›´æ¥å¼€å§‹æ¬¢ä¹æ–—åœ°ä¸»ç„¶åè¢« zxy æ— æƒ…åæ§½äº†ğŸ˜­ğŸ˜­ğŸ˜­ å›å»ä¹‹åç»™ cyk æ”¾å¢å§¥çˆ·çš„æ–—åœ°ä¸»ç¥ä»™ååœºé¢é›†é”¦ï¼ˆå¤§é›¾ï¼‰ç„¶åå†™äº†å‡ é“é¢˜å°±ç¡äº†ï¼Œæ„Ÿè§‰å•¥éƒ½æ²¡å¹²è¯ä¸¸ Day1ä¸Šåˆå¼€è¥ä»ªå¼ç»“æœè¯·äº†ä¸€ä¸ª thu æ¯•ä¸šçš„ pku è€å¸ˆæ¥ç»™æˆ‘ä»¬å¹æ°´åšè®²åº§ å¼€è¥ä»ªå¼ç»“æŸååˆ˜å§å’Œ D Z Yo å¸¦æˆ‘ä»¬åœ¨ pku æ—…æ¸¸äº†ä¸€åœˆè®²äº†ä¸€ä¸‹æ¯”èµ›äº‹é¡¹ï¼Œç»“æœæˆ‘ä»¬å’Œä»–ä»¬é‚£å±Šèµ›åˆ¶ä¸ä¸€æ ·ï¼Ÿï¼Ÿï¼Ÿæœ€åè¿˜çœŸæˆæ—…æ¸¸äº† ä¸­åˆæ¯”è¾ƒå›°ä½†ä¸€ç›´æ²¡ç¡ç€ï¼Œå–äº†ä¸€ç“¶å’–å•¡å°±å»ä¸Šæœºæµ‹è¯•äº† å¼€é¢˜ ä¸‰é“è®¡æ•°ï¼ŒçœŸæ£’ çœ‹é¢˜ä¸‰é“éƒ½ä¸ä¼šã€‚ã€‚ã€‚ã€‚ $A$ æƒ³äº†åŠå¤©ä¸ä¼šæœ€ä½æ¡£æš´åŠ› $B$ æƒ³äº†åŠå¤©åªä¼šæœ€ä½æ¡£æš´åŠ› $C$ æƒ³äº†åŠå¤©åªä¼š $100pts$ é‚£å°±å†™å§ï¼Œ $90min$ ä¹‹åæˆ‘å‘ç°è‡ªå·±çœ‹é”™é¢˜äº†ï¼Œå¿ƒæ€çˆ†ç‚¸ï¼Œç„¶åå‘ç° $mobius$ åæ¼”èƒ½æœ‰ $42pts$ ï¼Œé‚£å°±å†™å§ï¼Œç»ˆäºæœ‰åˆ†äº†.jpg ç„¶åå‘ç° $B$ ä¼š $50pts$ , $A$ å¯èƒ½ä¼šæœ€ä½æ¡£æš´åŠ›äº†ï¼Œç„¶åå°±å¼€å§‹å†™ $B$ çš„ $50pts$ ï¼Œå†™æ³•å‘ç°åˆå‡æ‰äº†ï¼Œç»“æœæƒ³äº†ä¸€ä¼šå„¿åˆä¼šäº†ä¸€ä¸ªç®—æ³•ï¼Œæ°ªå‘½ rush äº†ä¸€æ³¢è¿˜æ˜¯æ²¡è°ƒå‡ºæ¥ï¼Œæœ€åäº¤äº†ä¸€ä¸ª $10pts$ æ²¡è¯„å‡ºæ¥å°±ç»“æŸäº† ç„¶åä¸‹æ¥ä¸€é—®å¤§å®¶éƒ½æ¯”æˆ‘é«˜ğŸ˜±ğŸ˜±ğŸ˜±ğŸ˜±ğŸ˜±é‚£è¿™ä¸æ˜¯å®Œè›‹äº†å—ï¼Œæ‰€å¹¸çš„æ˜¯æ‰€æœ‰ æ­£å¼è¥å‘˜éƒ½è¿›äº†é¢è¯•ï¼Œç»“æœ cyk è²Œä¼¼æ˜¯å› ä¸º CSP-S è€ƒä½äº†ä¸€ç‚¹å°±æ²¡é¢è¯•èµ„æ ¼ï¼Ÿç„¶åå­¦å¼Ÿå‘Šè¯‰æˆ‘ä»–æ—è¾¹é‚£ä¸ªè€ƒäº† $241$ ï¼Œæˆ‘ï¼Ÿï¼Ÿï¼Ÿäººéƒ½å‚»äº†ï¼Œæ™šä¸Šè¢«å­¦å¼Ÿæ‹–å»æœªåæ¹–èµ°äº†ä¸€åœˆï¼Œå›å»ä¹‹å zgs è¯´ cyk åªè¦è€ƒå¾—é«˜è¿˜æ˜¯èƒ½æ‹¿å¥–ï¼Œäºæ˜¯æˆ‘ä»¬å…´é«˜é‡‡çƒˆçš„å›æˆ¿é—´å¼€å§‹é¢“åºŸï¼Œæˆ‘æ‰ä¸ä¼šå‘Šè¯‰ä½ æˆ‘å› ä¸ºå¤ªä¸§ç›´æ¥æŠŠåé£Ÿé±¼æ‰“é€šå…³ç„¶åçœ‹å°è¯´çœ‹åˆ°ä¸¤ç‚¹åŠçš„äº‹å‘¢ Day2æ—©ä¸Šå»é¢è¯•ï¼Œç”±äºæœ‰ä¸‰åœºé¢è¯•è€Œæˆ‘ä»¥ä¸ºåªæœ‰ä¸€åœºï¼Œäºæ˜¯ $8:55$ æ‰åˆ°æ–‡å²æ¥¼ï¼Œç»“æœå»äº†æ‰çŸ¥é“æˆ‘è¿˜æœ‰ä¸€åœº $8:35$ å’Œä¸€åœº $9:50$ çš„ï¼Œç”±äºé¢è¯•æ¯”è¾ƒæ— èŠæ‰€ä»¥è¿™é‡Œå°±ä¸å¤šè®²ï¼Œå”¯ä¸€è®©æˆ‘æ”¾ä¸ä¸‹å¿ƒçš„æ˜¯ç¬¬ä¸‰åœºé¢è¯•ç¦»å¼€çš„æ—¶å€™é¢è¯•æˆ‘çš„è€å¸ˆè¯´ï¼šä½ è¿˜å¾—å¤šå¤šåŠªåŠ›æ‰è¡Œå•Šã€‚ äººéƒ½å‚»äº†.jpgï¼Œè¿™æ˜¯åœ¨è¯´è®©æˆ‘ä¸‹æ¬¡å†æ¥çš„æ„æ€å§ğŸ˜±ğŸ˜±ğŸ˜±ğŸ˜±ğŸ˜± æ¯”è¾ƒç¥ä»™çš„æ˜¯å­¦å¼Ÿ fsy ç¬¬ä¸€åœºé¢è¯•çš„æ—¶å€™é¢è¯•è€å¸ˆé—®äº†ä¸€å¥ï¼šæˆéƒ½çŸ³å®¤ä¸­å­¦ï¼Ÿæ²¡å¬è¯´è¿‡å•Šï¼Œä½ æ¥ç®€å•ä»‹ç»ä¸€ä¸‹ã€‚ å›å»ä¹‹åæ„Ÿè§‰éå¸¸éƒé—·ï¼Œåƒå®Œé¥­ä¹‹åå’Œ cyk è¯´ä»Šå¤©ä¸€å®šè¦ç¿»ç›˜ç„¶åå°±è¿›è€ƒåœºäº†ï¼Œè¿˜æœ‰ 5min å¼€å§‹çš„æ—¶å€™æ‰“å®Œäº†å¤šé¡¹å¼å…¨å®¶æ¡¶çš„æ¿å­ï¼Œç„¶åæ…¢æ…¢ç­‰å¾…è€ƒè¯•å¼€å§‹ï¼Œæ‰“å¼€ä¸€çœ‹ï¼ŒNMDä»Šå¤©æ€ä¹ˆä¸€é“è®¡æ•°éƒ½æ²¡æœ‰å•Šï¼ç„¶åç¡®è®¤äº† 5min è‡ªå·±æ²¡æŠŠ $A$ è¯»é”™é¢˜ä¹‹åå†™äº†ä¸€å‘äº¤ä¸Šå»å°±è¿‡äº†ï¼Œç„¶åæƒ³äº†ä¸€ä¸‹ $B$ å‘ç°ç›´æ¥å»ºå‡ºç¬›å¡å°”æ ‘ç„¶ååŠ ä¸€ä¸ªå¹¿ä¹‰çº¿æ®µæ ‘æŸ¥è¯¢åŒºé—´ä¿¡æ¯åšæ³•å°±è¿‡äº†ï¼Œç„¶åæƒ³äº†ä¸€ä¸‹ $C$ ï¼Œå—¯ï¼Ÿè¿™ä¸ªæ— å‘å›¾æ€ä¹ˆæ±‚æœ€å°å‰²å•Šï¼Ÿï¼Ÿï¼Ÿæˆ‘å±…ç„¶è¿æœ€ä½æ¡£æš´åŠ›éƒ½ä¸ä¼šï¼Œå‰ä¸¤é“è¿˜æ˜¯é€åˆ†çš„ï¼Œå‡‰äº†ã€‚ è¿‡äº† $5min$ ååº”è¿‡æ¥æ˜¯ä¸ªäºŒç»´æ•°ç‚¹é—®é¢˜ï¼Œç„¶åä¼šäº† $68$ åˆ†ï¼Œå†™äº†ä¸ªå››åˆ†æ ‘ä¸€äº¤å‘ç°è¢«å¡äº†åªæœ‰ $42$ åˆ†ï¼Œå†·é™äº†ä¸€ä¸‹æŠŠç¬¬ä¸€ä¸ªå››åˆ†æ ‘æ”¹æˆäº†äºŒç»´ $bit$ ç»“æœåˆ TLE äº†ï¼Œåˆå†·é™äº†ä¸€ä¸‹æŠŠç¬¬äºŒä¸ªå››åˆ†æ ‘æ”¹æˆäº†æ ‘å¥—æ ‘å‡†å¤‡äº¤ä¸€å‘ï¼Œä»”ç»†æƒ³äº†ä¸€æƒ³è²Œä¼¼ç¬¬ä¸€æ£µç›´æ¥ç”¨äºŒç»´å‰ç¼€å’Œå³å¯ï¼Œè¿™æ¬¡å¦‚æœè¿‡ä¸äº†å°±æ¢æˆäºŒç»´å‰ç¼€å’Œå§ï¼ç»“æœäº¤ä¸Šå»å°±è¿‡äº†ã€‚ã€‚ã€‚æœ€åç”±äºå†·é™äº†å¾ˆä¹…ä¸ä¼šä¼˜åŒ–åé¢ä¸€ä¸ªæ ‘å¥—æ ‘äºæ˜¯äººæ²¡äº†ã€‚å‡ºæ¥ä¸€é—®å¥½åƒä¸€å¨äººé˜¿å…‹ï¼Œé‚£æˆ‘æ²¡äº†ã€‚ã€‚ã€‚å¯¹äº†ä¸€ä¸‹åˆ†å‘ç° cyk æ€»åˆ†è·Ÿæˆ‘å·®ä¸å¤šï¼Œ fsy å’Œ hwj è¦ç¨å¾®ä½ä¸€ç‚¹ç‚¹ï¼Œæ™šä¸Šå’Œ fsy å’Œ cyk åœ¨æˆ¿é—´é‡Œæ–—åœ°ä¸»ï¼Œ cyk ç›´æ¥è¾“å°é¡¶äº† Day3å‘å¥–æ—¥ ä¸Šåˆé…’åº—é‡Œé¢“åºŸï¼Œä¸‹åˆå»é¢†å¥–æ„Ÿè§‰æ…Œå¾—ä¸€æ‰¹ï¼Œå¸Œæœ›èƒ½è‹Ÿä¸€ä¸ªäºŒç­‰å¥–å›å®¶ ç„¶åå…ˆæ˜¯æ•¦æ•¦æ•¦æ¥è®²é¢˜ï¼Œå‘ç°è®²äº†æˆ‘è¿˜æ˜¯ä¸ä¼šï¼Œå¦å¤–é‚£ä¸ª d1t3 ä¹Ÿå¾—åæ§½ä¸€ä¸‹ï¼Œæ•¦æ•¦æ•¦ï¼šè¿™ä¸ªé¢˜æˆ‘ä¹Ÿä¸æ˜¯å¾ˆä¼šï¼Œä½ ä»¬æƒ³çŸ¥é“å¯ä»¥ä¸‹æ¥è”ç³»ä¸€ä¸‹ä»–ï¼ˆæŒ‡å‰è€å¸ˆï¼‰ã€‚ MDæœ‰æ¯’ ç„¶åå°±å‘å¥–äº†ï¼Œç»“æœä¸€äºŒç­‰å¥–å‘å®Œä¹‹åæˆ‘å’Œ cyk éƒ½æ²¡é¢†åˆ°ï¼Œ fsy å’Œ hwj éƒ½æœ‰äºŒç­‰å¥–ï¼Œæ„Ÿè§‰è‡ªå·±æˆæœ€å¤§è¾“å®¶ã€‚ç„¶åæœ€åå‘ç°æ˜¯ä¸€ç­‰ï¼Ÿï¼Ÿï¼Ÿæˆ‘æ‹¿åˆ°ä¹‹åå°±å¼€å§‹ç­‰ cyk çš„ï¼Œç»“æœåˆ°äº†æœ€åä¹Ÿæ²¡å‘ï¼Ÿï¼Ÿï¼Ÿç„¶åå»æ‰¾è€å¸ˆä¸€é—®è¯´çš„æ˜¯éæ­£å¼è¥å‘˜æ— æ³•å‘å¥–ï¼Ÿï¼Ÿï¼Ÿè¿™æ“ä½œå¤ªğŸ˜ğŸ˜ğŸ˜äº†å§ï¼Ÿï¼Ÿï¼Ÿå¼•èµ·æˆ‘ä»¬æåº¦ä¸é€‚ã€‚ zgs è”ç³»äº†ä¸€ä¸‹æ„Ÿè§‰ä¹Ÿä¸æ˜¯å¾ˆèƒ½è¡¥ä¸€ä¸ªå¥–ï¼Œäºæ˜¯ç®€å•å®‰æ…°äº†ä¸€ä¸‹ cyk å°±å‡†å¤‡å» thu ç­‰ zxy ä»–ä»¬å‘å¥–äº†ï¼Œç„¶åæˆåŠŸç»™åˆ°äº† hjk å’Œ yk ï¼Œå¬è§ yk åœ¨é‚£å„¿ä¸€ç›´å‡æ„Ÿè§‰æœ‰æ¯’ï¼Œæœ€åå‘ä¸‹æ¥ CDQZ é«˜äºŒä¸‰ä¸ªä¸€ç­‰å¥–ï¼Œ zxy ä¹Ÿä¸€ç­‰äº†ã€‚äºæ˜¯é©¬ä¸Šæˆ‘ä»¬å°±å»æœºåœºå‡†å¤‡å›å®¶æ„Ÿè§‰zgsåˆä¼šå‘ä¸ªä»€ä¹ˆç¥å¥‡çš„å–œæŠ¥","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"http://ldxcaicai.github.io/tags/æ¸¸è®°/"}]},{"title":"burnsideå¼•ç†ç®€å•è¯æ˜","slug":"burnside","date":"2019-12-16T13:56:40.000Z","updated":"2019-12-16T14:19:29.268Z","comments":true,"path":"burnside/","link":"","permalink":"http://ldxcaicai.github.io/burnside/","excerpt":"","text":"å‰è¨€ï¼šç”±äºåšä¸»æ—¶ä¸æ—¶ä¼šå¿˜è®°è¿™ä¸ªå®šç†ä»¥åŠå®ƒæ˜¯å’‹è¯æ˜çš„ï¼Œæ‰€ä»¥ä¸ºäº†æ–¹ä¾¿å°±å¹²è„†è‡ªå·±å†™ä¸€ä¸ªæ”¾ $blog$ ä¸Šé¢ ç°åœ¨ç»™å‡ºé›†åˆ $\\text{X}$ ï¼Œè®¾ $\\text G$ æ˜¯å…¶ç½®æ¢ç¾¤ï¼Œ $\\text C$ æ˜¯å…¶ç€è‰²é›†ï¼Œä¸” $\\text G$ ä½œç”¨åœ¨ $\\text C$ ä¸‹ é‚£ä¹ˆå®šä¹‰ $G(c)=\\{f:f\\in \\text G,f\\times c=c\\},C(f)=\\{c:c\\in \\text C,f\\times c=c\\}$ ç„¶åæœ‰ä¸€ä¸ªæ˜¾ç„¶çš„æ¨è®º: è®¾ $c$ æ˜¯ $\\text C$ ä¸­çš„ä¸€ç§ç€è‰²ï¼Œé‚£ä¹ˆ $|\\{f\\times c:f\\in \\text G\\}|=\\frac{|\\text G|}{|G(c)|}$ ,è¯æ˜æ˜¾ç„¶ ç„¶åå°±èƒ½è¯æ˜ $Burnside$ å¼•ç†äº†ï¼š \\begin{aligned} \\sum\\limits_{f\\in \\text G}|C(f)|=&\\sum\\limits_{c\\in \\text C}|G(c)|\\\\ \\sum\\limits_{f\\in \\text G}|C(f)|=&\\sum\\limits_{c\\in\\text C}\\frac{|\\text G|}{ä¸cç­‰ä»·çš„ç€è‰²æ•°}\\\\ \\sum\\limits_{f\\in\\text G}|C(f)|=&|\\text G|\\sum\\limits_{c\\in\\text C}\\frac{1}{ä¸cç­‰ä»·çš„ç€è‰²æ•°}\\\\ ç”±äºåœ¨ä¸€ä¸ªç­‰ä»·ç±»ä¸­&æ¯ç§ç€è‰²çš„è´¡çŒ®éƒ½æ˜¯\\frac{1}{ä¸cç­‰ä»·çš„ç€è‰²æ•°}\\\\ æ‰€ä»¥\\sum\\limits_{f\\in \\text G}|C(f)|=&|G|\\times N(\\text G,\\text C)\\\\ N(\\text G,\\text C)=&\\frac{\\sum\\limits_{f\\in \\text G}|C(f)|}{|\\text G|} \\end{aligned}å¾—è¯","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]},{"title":"Powerful Number ç­›å­¦ä¹ ç¬”è®°","slug":"PN","date":"2019-11-30T13:12:34.000Z","updated":"2019-11-30T13:27:30.102Z","comments":true,"path":"PN/","link":"","permalink":"http://ldxcaicai.github.io/PN/","excerpt":"","text":"NMDæˆ‘æ€ä¹ˆç°åœ¨æ‰ä¼šè¿™æ²™é›•ç©æ„å„¿.jpg æ„Ÿè§‰æŒºç®€å•çš„ï¼Œä¸»è¦æ˜¯é€‚ç”¨èŒƒå›´æ¯”è¾ƒå°ï¼Œå¤§æ¦‚èƒ½ç­›æŸäº›æ€§è´¨æ¯”è¾ƒå¥‡å¦™çš„ä¸Šç•Œåœ¨ $10^{13}$ ~ $10^{14}$çš„ç§¯æ€§å‡½æ•° é¦–å…ˆä»‹ç» $\\text{Powerful}$ $\\text{Number}$ æ˜¯å•¥ï¼Œå½“ä¸€ä¸ªæ•°æ»¡è¶³å…¶æ‰€æœ‰è´¨å› æ•°çš„æŒ‡æ•°éƒ½å¤§äº $1$ çš„æ—¶å€™æˆ‘ä»¬ç§°å…¶ä¸º $\\text{Powerful}$ $\\text{Number}$ ï¼Œä¸‹é¢ç®€å•è¯´æ˜å…¶é‡è¦æ€§è´¨ï¼š $n$ ä»¥å†…çš„ $\\text{Powerful}$ $\\text{Number}$ çš„æ•°é‡ä¸º $\\sqrt n$ çº§åˆ«çš„ï¼Œé¦–å…ˆå‘ç°æ¯ä¸ª $\\text{Powerful}$ $\\text{Number}$ éƒ½èƒ½è¡¨ç¤ºæˆ $x^2y^3$ çš„å½¢å¼ \\begin{aligned} |\\text{PowerfulNumber}\\le n|=&\\sum\\limits_{x=1}^{\\sqrt n}\\lfloor\\sqrt[3]{\\frac nx}\\rfloor\\\\ =&n^{\\frac13}\\sum\\limits_{x=1}^{\\sqrt n}x^{-\\frac23}\\\\","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]},{"title":"Linear algebra","slug":"LA","date":"2019-11-26T14:38:38.000Z","updated":"2019-11-26T14:40:03.123Z","comments":true,"path":"LA/","link":"","permalink":"http://ldxcaicai.github.io/LA/","excerpt":"","text":"ç›¸ä¼¼çŸ©é˜µ å®šä¹‰ï¼šè‹¥å¯¹äºçŸ©é˜µ $\\text A$ å­˜åœ¨çŸ©é˜µ $\\text B$ å’Œå¯é€†çŸ©é˜µ $\\Phi$ æ»¡è¶³ $\\text B=\\Phi^{-1}\\text A\\Phi$ ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§° $\\text A$ ç›¸ä¼¼äº $\\text B$ ï¼Œè®°åš $\\text A\\sim\\text B$ç›¸ä¼¼æœ‰å¦‚ä¸‹æ€§è´¨ï¼š åèº«æ€§ï¼š $\\text A\\sim\\text A$ å¯¹ç§°æ€§ï¼š å¦‚æœ $\\text A\\sim\\text B$ ï¼Œé‚£ä¹ˆ $\\text B\\sim\\text A$ ä¼ é€’æ€§ï¼š å¦‚æœ $\\text A\\sim\\text B,\\text B\\sim\\text C$ ï¼Œé‚£ä¹ˆ $\\text A\\sim\\text C$ ç›¸ä¼¼çŸ©é˜µæœ‰å¦‚ä¸‹æ€§è´¨ï¼š ä¸¤è€…çš„ç§©ç›¸ç­‰ ä¸¤è€…çš„è¡Œåˆ—å¼å€¼ç›¸ç­‰ ä¸¤è€…æ‹¥æœ‰åŒæ ·çš„ç‰¹å¾å€¼ï¼Œå°½ç®¡ç›¸åº”çš„ç‰¹å¾å‘é‡ä¸€èˆ¬ä¸åŒ ä¸¤è€…æ‹¥æœ‰åŒæ ·çš„ç‰¹å¾å¤šé¡¹å¼ ä¸¤è€…å¯é€†æ€§ç›¸åŒï¼Œè‹¥å‡å¯é€†ï¼Œé‚£ä¹ˆä¸¤è€…çš„é€†çŸ©é˜µåŒæ ·ç›¸ä¼¼ åšä¸»ä»…å¯¹ç¬¬å››ç‚¹è¿›è¡Œè¯æ˜ï¼š \\begin{aligned} 0=|\\lambda\\text E-\\text B|=&|\\Phi^{-1}\\lambda\\Phi-\\Phi^{-1}\\text A\\Phi|\\\\ =&|\\Phi^{-1}(\\lambda\\text E-\\text A)\\Phi|\\\\ =&|\\Phi^{-1}|\\times|\\lambda\\text E-\\text A|\\times|\\Phi|\\\\ =&0\\\\ \\Rightarrow&|\\lambda\\text E-\\text A|=0 \\end{aligned} ç”¨é€”å¯ä»¥ç”¨äºè§£å†³å…³äºå¯¹è§’åŒ–çŸ©é˜µçš„é—®é¢˜ï¼Œå‡è®¾ä¸€ä¸ªçŸ©é˜µ $\\text A$ ä¸å¯¹è§’çŸ©é˜µ $\\text B$ ç›¸ä¼¼ï¼Œé‚£ä¹ˆæœ‰ \\begin{aligned} \\text A^m=&(\\Phi^{-1}\\text B\\Phi)^m\\\\ =&\\Phi^{-1}\\text B(\\Phi\\text A\\Phi^{-1})^{m-1}\\Phi\\\\ =&\\Phi^{-1}\\text B^m\\Phi \\end{aligned}é—®é¢˜è½¬åŒ–ä¸ºæ±‚æ¡¥æ¥çŸ©é˜µ $\\Phi$ ï¼Œè¿™ä¸ªå°±å„å‡­æœ¬äº‹äº† å¥½å§è¿˜æœ‰ä¸€ä¸ªå®šç†å¦‚ä¸‹ï¼šè‹¥ $\\text A$ ä¸å¯¹è§’çŸ©é˜µ $\\text B$ ç›¸ä¼¼ï¼Œé‚£ä¹ˆ $\\text A$ æœ‰ $n$ ä¸ªçº¿æ€§æ— å…³çš„ç‰¹å¾å‘é‡ï¼Œè®¾ä¸º $v_i$ ï¼Œé‚£ä¹ˆ $\\Phi$ å°±æ˜¯å°† $v_1\\cdots v_n$ æ¨ªå‘æ‹¼æ¥èµ·æ¥å¾—åˆ°çš„çŸ©é˜µ é—®é¢˜è½¬åŒ–ä¸ºæ±‚é€†çŸ©é˜µ $\\Phi^{-1}$ ï¼Œè¿™å›æ˜¯çœŸçš„å„å‡­æœ¬äº‹äº†","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]},{"title":"CSP-S 2019 æ³ªå¥”è®°","slug":"csp2019","date":"2019-11-17T06:40:02.000Z","updated":"2019-11-18T08:50:47.013Z","comments":true,"path":"csp2019/","link":"","permalink":"http://ldxcaicai.github.io/csp2019/","excerpt":"","text":"å¸Œæœ›è¿™ä¸æ˜¯åšä¸»å‘å‡ºæ¥çš„æœ€åä¸€ç¯‡blog2333 Day 0ä¸Šåˆå†™å®Œäº† $NOIP$ çš„æœ€åä¸€éƒ¨åˆ†çœŸé¢˜ï¼Œè¿™é‡Œæ˜¯ä»¥å¾€çš„ $NOIP\\ TG$ çš„é¢˜è§£é“¾æ¥ ç„¶åä¸­åˆå†™å®Œé¢˜è§£å’Œ $Dad$ ä¸€èµ·å»äº†é…’åº—ï¼Œåœ¨æ»´æ»´ä¸Šå¬æ­Œå¬åˆ°ä¸€åŠæ’­æ”¾å™¨å°±æ²¡ç”µäº†ï¼Œ $sad$ åœ¨é…’åº—é¢“åºŸäº†ä¸€ä¸‹åˆä¹‹åè·Ÿ $Dad$ å‡ºé—¨åƒæ™šé¥­ç»“æœé‡è§äº† $Jun$ ï¼Œå‘ç°ä½çš„æ˜¯åŒä¸€å®¶é…’åº—ï¼ˆæƒŠäº†$\\times 1$ï¼‰ï¼Œåƒäº†åŠç¢—ç±³çº¿ï¼Œæ„Ÿè§‰æ²¡æœ‰é£Ÿæ¬²ï¼Œç„¶åå»ä¹°é¢åŒ…å‘ç° $jmr$ ä¹Ÿåœ¨å’Œä»–çˆ¸ä¹°é¢åŒ…ï¼ˆæƒŠäº† $\\times 2$ï¼‰ï¼Œç„¶åå»ä¹°äº†ç¢—æ³¡é¢å‡†å¤‡æ™šä¸Šåƒï¼Œå›å»ä¹‹åè·Ÿ $Jun$ è°ˆäº†ä¸€ä¸ªå¤šå°æ—¶äººç”Ÿï¼Œç„¶ååˆé¢“åºŸäº†ä¸€ä¼šå„¿å†²ä¸ªæ¾¡å°±ç¡äº† Day 1èµ·åºŠä¹‹åå¥—äº†ä¸ªè€³æœºå’Œ $Dad$ ä¸€èµ·å»è€ƒåœºï¼Œç„¶åå‘ç°å…¶ä½™é€‰æ‰‹è²Œä¼¼éƒ½å·²ç»è¿›åœºäº†ï¼Œèµ¶å¿«å»æ‹¿äº†ä¸¤ç“¶å†œå¤«å±±æ³‰ç„¶åè¿›äº†è€ƒåœºï¼Œå‘ç°æ²¡äººæ‹¦ç€æˆ‘å†™æ¿å­äºæ˜¯æŠŠæ¿å­ç å®Œäº†ï¼Œç„¶åå¼€é¢˜ï¼Œå‘ç°å‰ä¸¤é“éƒ½æ¯”è¾ƒèœæ„Ÿè§‰é˜¿å…‹ç¨³äº†ï¼Œç»“æœ $9:00$ è¿‡äº†å¤§æ ·ä¾‹ä¹‹åå‘ç°å®Œå…¨ä¸ä¼š $T3$ ï¼Œæ„Ÿè§‰æ²¡æ•‘äº†ï¼Œä¸€ç›´è‚åˆ° $11:00$ éƒ½æ²¡æœ‰æƒ³æ¸…æ¥šç»†èŠ‚æœæ–­å‡†å¤‡ææš´åŠ›ï¼Œç„¶åå‘ç°æš´åŠ›åªä¼šç¬¬ä¸€æ¡£ï¼Œè‡ªé—­äº†ï¼Œæœ€åä¸€åˆ†é’ŸåˆåŠ ä¸Šäº†ä¸€ä¸ªåˆšè¿‡ç¼–è¯‘çš„å‡è´ªå¿ƒäº¤äº†ä¸Šå»è¯´ä¸å®šåŸæœ¬çš„æš´åŠ›åˆ†éƒ½æ²¡äº†ï¼Œæƒ³é¢˜æœŸé—´æŠŠ $T3$ é¢˜æ„çœ‹é”™ä¸¤æ¬¡ å‡ºè€ƒåœºä¹‹åçªç„¶å¬è¯´ $T1$ è¦ $ULL$ ï¼Œè‡ªé—­äº†ï¼Œæ„Ÿè§‰é€€å½¹ç¨³äº†ï¼Œç®—äº†ä¸€ä¸‹ $day1$ è²Œä¼¼æœ€é«˜æ‰ $205$ è¢«å…¶ä½™äººæŒ‰åœ¨åœ°ä¸Šæš´æ‰“ ç„¶åä¸‹åˆå¬è¯´ $romiqi$ çˆ†ç‚¸äº†æ„Ÿè§‰æœ‰ç‚¹é—æ†¾ï¼Œç®€å•èŠäº†å‡ å¥ä¹‹åè·‘å»ç¡è§‰ï¼Œèµ·æ¥ä¹‹åè·Ÿ $hjk1030$ èŠå¤©ç»“æœå¾—çŸ¥ $zyj$ ä¹Ÿè·Ÿæˆ‘ä½ä¸€ä¸ªé…’åº—ï¼Ÿï¼Ÿï¼Ÿï¼ˆæƒŠäº† $\\times 3$ï¼‰ï¼Œç„¶åè·‘å»ä¸²é—¨èŠäº†å¾ˆä¹…çš„å¤©ï¼Œä¹‹åè·Ÿ $Jun$ ä¸¤ä¸ªäººä¸€èµ·å»ç”µå­ç§‘å¤§æ‰“ç¾½æ¯›çƒï¼Œç»“æœä¸¤ä¸ªé“æ†¨æ†¨ä¸è®¤è·¯æ‰¾äº† $30min$ æ‰æ‰¾åˆ°åœºå­ï¼Œæ‰“çš„æ—¶å€™æ—è¾¹è¿˜æœ‰ä¸€å¯¹ $cp$ åœ¨èŠ±å¼è™ç‹—ï¼Œæ›´6pçš„æ˜¯æˆ‘ä¿©åœ¨ç¯®çƒåœºé‡Œçœ‹è§ä¸€å †äººåœ¨ç›´æ’­ç”µç«æ¯”èµ›ï¼Œè·Ÿ $Jun$ åœ¨ç”µå­ç§‘å¤§é‡Œèµ°è·¯çš„æ—¶å€™åˆèŠäº†å¥½ä¹…äººç”Ÿ æ™šä¸Šå›é…’åº—å‘ç° $Mom$ æ¥äº†ï¼ˆæƒŠäº† $\\times 4$ ï¼‰ï¼Œåƒå®Œæ™šé¥­ä¹‹åå¬è¯´ $CDQZ$ åœ¨ä¸€ä¸ªä¸€ä¸ªé¢è°ˆäºæ˜¯ä¸‹å»é¢åŸºï¼Œå‘ç° $buzhibujue,sjkmost,jmr$ åœ¨ä¸‹é¢è½¬åœˆï¼Œçœ‹èµ·æ¥éƒ½å¥½ç¨³çš„æ ·å­ï¼Œå¤§æ¦‚èŠäº†ä¸€ä¸‹æœ€åä¸çŸ¥é“æ€ä¹ˆå˜æˆ $mod\\ jerome$_ $wei$ å’Œ $mod\\ zxyoi$ _$dreamer$ å¤§ä¼šäº†ï¼Œç„¶åæ‰¾åˆ° $yangkai$ å’Œ $hjk1030$ èŠäº†ä¸€å°ä¼šå„¿åˆå›æˆ¿äº†ï¼Œç»“æœå›å»ä¹‹å $yangkai$ çªç„¶é—®æˆ‘ä»– $d1t2$ çš„æ­£ç¡®æ€§ï¼Œæƒ³äº†ä¸€ä¸‹å‘ç°æ²¡å•¥é”…è·Ÿä»–è¯´äº†å‡ å¥ç„¶åå°é¢“ä¸€ä¼šå„¿åˆç¡äº† Day 2æ—©ä¸Šçˆ¬èµ·æ¥æ´—ä¸ªæ¾¡ï¼Œæ„Ÿè§‰ç¾æ»‹æ»‹ï¼Œç„¶åå»è€ƒåœºçš„æ—¶å€™é‡åˆ°äº† $yangkai$ ï¼Œç„¶åå¬è¯´å¸æœºå·®ç‚¹æ²¡è°ƒå‡ºæ¥ $d1t3$ ã€‚è¿›è€ƒåœºæ‰“å®Œæ¿å­ä¹‹åä¸€å¼€é¢˜å°±è’™è”½äº†ï¼Œå±…ç„¶æ²¡é€åˆ†é¢˜ï¼Ÿï¼Ÿï¼Ÿä¸å¯¹ $T2$ å¥½åƒæ˜¯é€çš„ï¼Œç„¶åæƒ³äº† $20min$ æ— æœå‘ç°çœ‹é”™é¢˜äº†ï¼Œç„¶åå€’å›å»çœ‹ $T1$ ï¼Œæƒ³äº†ä¸€ä¼šå„¿å‘ç°æ˜¯ä¸ªè¡¥é›†è½¬åŒ–å…¥é—¨é¢˜ï¼Œè¿‡å®Œæ ·ä¾‹å°±è·‘å»æƒ³ $T2$ ï¼Œç„¶åæ„Ÿè§‰è¶Šæƒ³è¶Šä¸è¡Œï¼Œå‡†å¤‡å…ˆå†™ $T3$ æš´åŠ›ç„¶åæŠŠ $T2$ éˆ¤å‡ºæ¥ï¼Œä½†ç”±äºå†™ $T3$ æš´åŠ›çš„æ—¶å€™æˆ‘ $dev$ åˆæ­»æ‰äº†äºæ˜¯å¿ƒæ€å°å´©ï¼Œï¼ˆè¿™ä¹ˆè¯´æ¥æˆ‘ç›®å‰å‚åŠ è¿‡çš„å¤§èµ› $day2$ éƒ½æ­»æœºäº†ï¼‰ç»“æœå¼€ $T2$ çš„æ—¶å€™å·²ç» $11:00$ äº†ï¼Œæƒ³äº† $30min$ æ— æœä¹‹å $rush$ äº†ä¸€ä¸ª $32pts$ æš´åŠ›ï¼Œå‘ç°èƒ½ä¼˜åŒ–åˆ° $64pt$ å¹¶ä¸”åœ¨ç»“æŸå‰ $5min$ çš„æ—¶å€™è°ƒå‡ºæ¥äº†ï¼Œç„¶åè€ƒè¯•ç»“æŸäº† å‡ºæ¥ä¹‹åå¬è¯´ $romiqi$ ç¿»è½¦äºŒè¿ï¼Œ $T2$ åˆ‡ $88pts$ æ˜¯çœŸçš„å¼ºï¼Œæ²¡è°ƒå‡ºæ¥å°±æœ‰ç‚¹å¯æƒœï¼Œä¸»è¦æ˜¯å› ä¸ºä»Šå¹´ä¸¤å¤©éƒ½æ²¡æœ‰åŒºåˆ†åº¦ï¼Œåªè¦æš´åŠ›æ‰“å¥½å³å¯ã€‚è¿™æ ·å¯¹æˆ‘ä»¬è¿™ç§å‡†å¤‡å¾ˆä¹…çš„ $oier$ å®Œå…¨æ²¡æœ‰ä¼˜åŠ¿ï¼Œä¸è¿‡ $CCF$ ä¹Ÿè®©å¾ˆå¤šåˆ†æ•°ç›¸è¿‘çš„é€‰æ‰‹çœ‹åˆ°å¸Œæœ›ä»è€Œèµšæ›´å¤šé’±ã€‚ ç°åœ¨åšä¸»æ…Œå¾—ä¸€æ‰¹æ„Ÿè§‰ä¼š $FST$ ä¸€å †ï¼Œå¸Œæœ›è¿æ°”å¥½ç‚¹å§ï¼Œä¸è¿‡ $WC$ å’Œ $PKUWC$ æ˜¯ç™¾åˆ†ç™¾æ— æœ›äº†ï¼Œå¦‚æœæˆ‘å»è½ä¸ª $d1t3$ çš„æš´åŠ›ä¹Ÿå°±ä¸è‡³äºæˆç°åœ¨è¿™é¬¼æ ·å­äº†ï¼Œå”‰ UPD:19.11.18: è²Œä¼¼æ°‘é—´æ•°æ®æµ‹å‡ºæ¥æ²¡æœ‰æŒ‚åˆ†ï¼Œå¤§æ¦‚è¿˜èƒ½è‹Ÿå»¶æ®‹å–˜ä¸€æ®µæ—¶é—´ï¼Ÿå¸Œæœ› $CCF$ çš„æœºå­å¯¹æˆ‘çš„ä»£ç å‹å¥½ä¸€ç‚¹","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¸¸è®°","slug":"æ¸¸è®°","permalink":"http://ldxcaicai.github.io/tags/æ¸¸è®°/"}]},{"title":"CodeForces gym 102059 ç®€è¦é¢˜è§£","slug":"gym102059","date":"2019-10-16T23:47:42.000Z","updated":"2019-11-07T10:53:43.276Z","comments":true,"path":"gym102059/","link":"","permalink":"http://ldxcaicai.github.io/gym102059/","excerpt":"","text":"Coloring Roadsé¢˜æ„ç®€è¿°ï¼š ç»™ä¸€æ£µæ ‘ï¼Œæ ‘è¾¹ä¸€å¼€å§‹éƒ½æ˜¯æ— è‰²çš„ï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥æŠŠä¸€ä¸ªç‚¹åˆ°æ ¹çš„è·¯å¾„ä¸Šæ‰€æœ‰è¾¹æŸ“æˆæŸä¸ªé¢œè‰²ï¼Œæ¯æ¬¡è¯¢é—®å½“å‰æ ‘ä¸Šå‡ºç°è¿‡æŸä¸ªæ¬¡æ•°çš„é¢œè‰²ç§æ•° æ•°æ®èŒƒå›´ï¼š ç‚¹æ•°ï¼Œæ“ä½œæ•° $\\le2\\times10^5$ è§£é¢˜æ€è·¯ï¼š è¿™é¢˜åšæ³•è¿˜è›®å¤šçš„ï¼Œåœ¨è¿™é‡Œç®€å•è®°å½•ä¸€ä¸‹ï¼š æ ‘é“¾å‰–åˆ†+å•è°ƒæ ˆï¼šå¯¹äºæ¯æ¡é‡é“¾ç»´æŠ¤ä¸€ä¸ªå…³äº $dfs$ åºçš„å•è°ƒé€’å‡æ ˆä»è€Œç»´æŠ¤ç­”æ¡ˆï¼Œæ¯æ¬¡æš´åŠ›ä¿®æ”¹ï¼Œå‡æ‘Šåˆ†æå¤æ‚åº¦æ˜¯å¯¹çš„ æ ‘é“¾å‰–åˆ†+ $ODT$ ï¼Œç”±äºæœ‰è·¯å¾„è¦†ç›–æ“ä½œï¼Œå› æ­¤å¯ä»¥ç”¨ $ODT$ ç®€å•ç»´æŠ¤ç­”æ¡ˆï¼Œå¤æ‚åº¦åˆ†æè·Ÿåºåˆ—ä¸Šæ˜¯å·®ä¸å¤šçš„ $LCT$ ï¼Œè€ƒè™‘åˆ°è·¯å¾„è¦†ç›–å°±æ˜¯ $LCT$ åœ¨ $access$ çš„æ—¶å€™é¡ºå¸¦ä¿®æ”¹ä¸€ä¸‹ä¿¡æ¯ï¼Œå› æ­¤æ¯æ¬¡æ”¹çš„æ—¶å€™ $access$ å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=4e5+5;set&lt;int&gt;S[N];int cnt[N];namespace lct&#123; #define lc (son[p][0]) #define rc (son[p][1]) int siz[N],fa[N],son[N][2],vl[N],col[N]; bool rev[N]; inline bool which(int x)&#123;return x==son[fa[x]][1];&#125; inline bool isroot(int x)&#123;return !fa[x]||(son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x);&#125; inline void pushup(int p)&#123;siz[p]=siz[lc]+siz[rc]+vl[p];&#125; inline void pushnow(int p,int c)&#123;col[p]=c;&#125; inline void pushdown(int p)&#123;(lc&amp;&amp;(col[lc]=col[p])),(rc&amp;&amp;(col[rc]=col[p]));&#125; inline void rotate(int x)&#123; int y=fa[x],z=fa[y],t=which(x); if(!isroot(y))son[z][which(y)]=x; fa[x]=z,fa[y]=x,son[y][t]=son[x][t^1],son[x][t^1]=y; if(son[y][t])fa[son[y][t]]=y; pushup(y),pushup(x); &#125; inline void splay(int x)&#123; static int stk[N],top; stk[top=1]=x; for(ri i=x;!isroot(i);i=fa[i])stk[++top]=fa[i]; while(top)pushdown(stk[top--]); while(!isroot(x))&#123; if(!isroot(fa[x]))rotate(which(x)^which(fa[x])?x:fa[x]); rotate(x); &#125; &#125; inline void access(int x,int c)&#123; int p=x; for(ri y=0;x;x=fa[y=x])&#123; splay(x); son[x][1]=0; pushup(x); S[cnt[col[x]]].erase(col[x]); cnt[col[x]]-=siz[x]; S[cnt[col[x]]].insert(col[x]); son[x][1]=y; pushup(x); p=x; &#125; pushnow(p,c); S[cnt[col[p]]].erase(col[p]); cnt[col[p]]+=siz[p]; S[cnt[col[p]]].insert(col[p]); &#125; #undef lc #undef rc&#125;int n,C,m;vector&lt;int&gt;e[N];void dfs(int p,int fa)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==fa)continue; dfs(v,p); lct::fa[lct::fa[v]=v+n]=p; lct::siz[v+n]=lct::vl[v+n]=1; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),C=read(),m=read(); for(ri i=1;i&lt;=C;++i)S[0].insert(i); S[n-1].insert(0); cnt[0]=n-1; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; dfs(1,0); for(ri x,c,k;m;--m)&#123; x=read(),c=read(),k=read(); lct::access(x,c); cout&lt;&lt;S[k].size()-(S[k].count(0)?1:0)&lt;&lt;'\\n'; &#125; return 0;&#125; Dev, Please Add This!é¢˜æ„ç®€è¿°ï¼š ç»™ä¸€ä¸ª $n*m$ çš„ç½‘æ ¼å›¾ï¼Œä¸€ä¸ªæ ¼å­æ˜¯ç©ºåœ°æˆ–å¢™ï¼Œç©ºåœ°ä¸Šå¯èƒ½æœ‰é“å…·ã€‚ä½ ä»ä¸€ä¸ªä½ç½®å‡ºå‘ï¼Œé€‰ä¸€ä¸ªæ–¹å‘ç„¶åä¸€ç›´æŒ‰é‚£ä¸ªæ–¹å‘èµ°ç›´åˆ°ç¢°åˆ°å¢™æˆ–è¾¹ç•Œã€‚æ²¿é€”çš„æ‰€æœ‰é“å…·éƒ½ä¼šè¢«æ”¶é›†ï¼Œé—®èƒ½å¦æ”¶é›†æ‰€æœ‰é“å…·ã€‚ æ•°æ®èŒƒå›´ï¼š $n,m\\le50$ è§£é¢˜æ€è·¯ï¼š æ ¹æ®é¢˜æ„ï¼Œæ¯è¡Œæ¯åˆ—éƒ½è¢«è¾¹ç•Œå’Œå¢™åˆ†æˆäº†å¾ˆå¤šå°æ®µï¼Œæˆ‘ä»¬æŠŠè¿™äº›æ®µè¿›è¡Œæ ‡å·ï¼Œé‚£ä¹ˆå¯¹äºä¸€ä¸ªé“å…·ï¼Œå®ƒè¢«æ”¶é›†å½“ä¸”ä»…å½“å®ƒæ‰€åœ¨çš„è¡Œåˆ—åˆ†é‡è‡³å°‘æœ‰ä¸€ä¸ªè¢«é€‰ï¼Œäºæ˜¯æƒ³åˆ°ç”¨ $2-sat$ æ¥è¿›è¡Œè¿™ç±»é™åˆ¶ï¼Œç„¶åè€ƒè™‘å‰©ä¸‹çš„é™åˆ¶ï¼Œè‹¥ä»èµ·ç‚¹å‡ºå‘ä¸èƒ½åˆ°è¾¾æŸä¸ªåˆ†é‡ï¼Œé‚£ä¹ˆæœ€åå®ƒå¿…é¡»ä¸º $false$ ï¼Œå¦‚æœä¸¤ä¸ªåˆ†é‡æ²¡æœ‰ä¸€ä¸ªèƒ½åˆ°è¾¾å¦ä¸€ä¸ªï¼Œé‚£ä¹ˆå°±ä¸èƒ½åŒæ—¶ä¸º $true$ ï¼Œå»ºå®Œå›¾ä¹‹åç”¨ $2-sat$ è·‘å³å¯ åˆæ³•æ€§è¯æ˜ï¼šè€ƒè™‘å°†å»ºå‡ºæ¥çš„å›¾ç¼©ç‚¹ï¼Œé‚£ä¹ˆå°±å˜æˆäº†ä¸€å¼ æœ‰å‘å®Œå…¨å›¾ï¼Œä»ä¸€ä¸ªå…¥åº¦ä¸º $0$ çš„ç‚¹å‡ºå‘æ‰¾å“ˆå¯†é¡¿å›è·¯ï¼Œè¿™ä¸ªä¸€å®šèƒ½æ„é€ å‡ºä¸€ç»„è§£ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='O'&amp;&amp;ch!='#'&amp;&amp;ch!='.'&amp;&amp;ch!='*')ch=gc(); while(ch=='O'||ch=='#'||ch=='.'||ch=='*')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353,inv2=499122177; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=55,M=N*N*4;char s[N][N];int n,m,sig=0,col[M],stk[M],top=0;bool vs[M];vector&lt;int&gt;e[M];int tot=0,low[M],dfn[M];bool trans[M][M];void dfs(int p)&#123; dfn[p]=low[p]=++tot; stk[++top]=p; vs[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if(dfn[v=e[p][i]])&#123; if(vs[v])low[p]=min(low[p],low[v]); continue; &#125; dfs(v),low[p]=min(low[p],low[v]); &#125; if(low[p]==dfn[p])&#123; ++sig; while(1)&#123; int x=stk[top--]; vs[x]=0; col[x]=sig; if(x==p)break; &#125; &#125;&#125;int idx1[N][N],idx2[N][N],cnt=0;inline void gettrans(int p,int rt)&#123; trans[rt][p]=1; for(ri i=0;i&lt;e[p].size();++i) if(!trans[rt][e[p][i]])gettrans(e[p][i],rt);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)Read(s[i]); for(ri i=0;i&lt;=n+1;++i)s[i][0]=s[i][m+1]='#'; for(ri i=0;i&lt;=m+1;++i)s[0][i]=s[n+1][i]='#'; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; if(s[i][j-1]=='#'&amp;&amp;s[i][j]!='#')++cnt; idx1[i][j]=cnt; &#125; for(ri i=1;i&lt;=m;++i)for(ri j=1;j&lt;=n;++j)&#123; if(s[j-1][i]=='#'&amp;&amp;s[j][i]!='#')++cnt; idx2[j][i]=cnt; &#125; ++cnt; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; if(s[i][j]=='#')continue; if(s[i][j-1]=='#'||s[i][j+1]=='#')e[idx1[i][j]].pb(idx2[i][j]); if(s[i-1][j]=='#'||s[i+1][j]=='#')e[idx2[i][j]].pb(idx1[i][j]); if(s[i][j]=='O')e[cnt].pb(idx1[i][j]),e[cnt].pb(idx2[i][j]); &#125; for(ri i=1;i&lt;=cnt;++i)gettrans(i,i); for(ri i=1;i&lt;=cnt;++i)e[i].clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)if(s[i][j]=='*')&#123; e[idx1[i][j]].pb(idx2[i][j]+cnt); e[idx2[i][j]].pb(idx1[i][j]+cnt); &#125; for(ri i=1;i&lt;cnt;++i)if(!trans[cnt][i])e[i+cnt].pb(i); for(ri i=1;i&lt;cnt;++i)for(ri j=i+1;j&lt;cnt;++j)if(!trans[i][j]&amp;&amp;!trans[j][i])&#123; e[i+cnt].pb(j); e[j+cnt].pb(i); &#125; for(ri i=1;i&lt;cnt*2;++i)if(!dfn[i])dfs(i); for(ri i=1;i&lt;cnt;++i)if(col[i]==col[i+cnt])&#123; puts(\"NO\"); return 0; &#125; puts(\"YES\"); return 0;&#125; Dstorvé¢˜æ„ç®€è¿°ï¼š æ•°è½´ä¸Šæ’åˆ—ç€ $n$ ä¸ªå·¦/å³ç®­å¤´ï¼Œæ¯ä¸ªç®­å¤´éƒ½ä¼šä»¥ç›¸åŒé€Ÿåº¦æœç€å„è‡ªæ–¹å‘ç§»åŠ¨ã€‚å½“ä¸€ä¸ªå·¦ç®­å¤´å’Œä¸€ä¸ªå³ç®­å¤´ç›¸é‡æ—¶æœ‰æ¦‚ç‡ $p$ ä½¿å¾—å…¶ä¸­å·¦ç®­å¤´æ¶ˆå¤±ï¼Œ $1-p$ æ¦‚ç‡ä½¿å³ç®­å¤´æ¶ˆå¤±ï¼Œé—®æœ€åå‰©ä¸‹ $a$ ä¸ªå³ç®­å¤´å’Œ $b$ ä¸ªå·¦ç®­å¤´çš„æ¦‚ç‡ã€‚ æ•°æ®èŒƒå›´ï¼š $n\\le5000$ è§£é¢˜æ€è·¯ï¼š å¯¹äºæ¯ä¸€ç§åˆæ³•æ–¹æ¡ˆï¼Œå¯¹åº”ç€åœ¨æœ€å³çš„å·¦ç®­å¤´å’Œæœ€å·¦çš„å³ç®­å¤´ä¹‹é—´åˆ’ä¸€é“åˆ†ç•Œçº¿ï¼Œç„¶ååˆ†ç•Œçº¿å·¦ä¾§çš„å³ç®­å¤´å…¨éƒ¨ $gg$ ï¼Œåˆ†ç•Œçº¿å³ä¾§çš„å·¦ç®­å¤´å…¨éƒ¨ $gg$ ï¼Œè¿™æ ·å¦‚æœç»Ÿè®¡å‡ºåˆ†ç•Œçº¿å·¦å³éƒ¨åˆ†åˆæ³•çš„æ¦‚ç‡å°±å¯ä»¥æšä¸¾åˆ†ç•Œçº¿ç»Ÿè®¡ç­”æ¡ˆ ç°åœ¨è€ƒè™‘å¦‚ä½•æ±‚æ¦‚ç‡ï¼Œè®¾ $f_{i,j}$ è¡¨ç¤ºä»å·¦åˆ°å³å¤„ç†åˆ°ç¬¬ $i$ ä¸ªç®­å¤´ï¼Œæœ€åä¼šä»å³è¾¹æ¥ $j$ ä¸ªå·¦ç®­å¤´è¿›è¡Œæ”¯æ´ï¼Œæœ€åå‰©ä¸‹ $b$ ä¸ªå·¦ç®­å¤´çš„æ¦‚ç‡ï¼Œç„¶åè½¬ç§»å³å¯ï¼Œå³ä¾§çš„è½¬ç§»åŒç† CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=5005;int f[N][N],g[N][N],pa,pb,p,n,A,B;char s[N];signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),pa=read(),pb=read(); Mul(pa,Inv(pa+pb)); pb=dec(1,pa); Read(s); A=read(),B=read(); f[0][B]=1; for(ri i=1;i&lt;=n;++i)&#123; if(s[i]=='H')for(ri j=0;j&lt;n;++j)f[i][j]=f[i-1][j+1]; else for(ri j=1;j&lt;=n;++j)f[i][j]=add(mul(f[i][j-1],pb),mul(f[i-1][j],pa)); &#125; g[n+1][A]=1; for(ri i=n;i;--i)&#123; if(s[i]=='R')for(ri j=0;j&lt;n;++j)g[i][j]=g[i+1][j+1]; else for(ri j=1;j&lt;=n;++j)g[i][j]=add(mul(g[i][j-1],pa),mul(g[i+1][j],pb)); &#125; int res=0; for(ri i=0;i&lt;=n;++i)Add(res,mul(f[i][0],g[i+1][0])); cout&lt;&lt;res; return 0;&#125; Dumaeå»ºæ‹“æ‰‘å›¾+è´ªå¿ƒå³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int mod=1e9+7;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=3e5+5;int n,m,L[N],R[N],du[N],q[N],hd,tl,Du[N];vector&lt;int&gt;e[N];vector&lt;pii&gt;a[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)L[i]=read(),R[i]=read(); for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].pb(v),++du[v],++Du[v]; &#125; int cnt=n; hd=1,tl=0; for(ri i=1;i&lt;=n;++i)if(!du[i])q[++tl]=i; while(hd&lt;=tl)&#123; int x=q[hd++]; --cnt; for(ri i=0,v;i&lt;e[x].size();++i)&#123; --du[v=e[x][i]]; if(!du[v])q[++tl]=v; &#125; &#125; if(cnt)return puts(\"-1\"),0; for(ri p,i=n;i;--i)&#123; p=q[i]; for(ri j=0,v;j&lt;e[p].size();++j)R[p]=min(R[p],R[v=e[p][j]]-1); &#125; set&lt;pii&gt;S,qu; vector&lt;int&gt;ans; for(ri i=1;i&lt;=n;++i)if(!Du[i])&#123; if(L[i]==1)qu.insert(pii(R[i],i)); else S.insert(pii(L[i],i)); &#125; while(qu.size())&#123; int x=qu.begin()-&gt;se; qu.erase(qu.begin()); ++cnt; if(R[x]&lt;cnt)return puts(\"-1\"),0; ans.pb(x); while(S.size()&amp;&amp;S.begin()-&gt;fi&lt;=cnt+1)qu.insert(pii(R[S.begin()-&gt;se],S.begin()-&gt;se)),S.erase(S.begin()); for(ri i=0,v;i&lt;e[x].size();++i)&#123; --Du[v=e[x][i]]; if(!Du[v])&#123; if(L[v]&lt;=cnt+1)qu.insert(pii(R[v],v)); else S.insert(pii(L[v],v)); &#125; &#125; &#125; if(ans.size()!=n)return puts(\"-1\"),0; for(ri i=0;i&lt;ans.size();++i)cout&lt;&lt;ans[i]&lt;&lt;'\\n'; return 0;&#125; Electronic Circuité€†å‘è€ƒè™‘ç„¶åæŒ‰ç…§é¢˜æ„æ¨¡æ‹Ÿ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int mod=1e9+7;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=1e5+5;set&lt;int&gt;e[N];bool ban[N];int n,m,cnt;inline void modify(int p)&#123; if(ban[p])return; if(e[p].size()^2)return; --cnt; ban[p]=1; int pre=*e[p].begin(),suf=*e[p].rbegin(); e[pre].erase(p); e[pre].insert(suf); e[suf].erase(p); e[suf].insert(pre); modify(pre),modify(suf);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); cnt=n; for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].insert(v); e[v].insert(u); &#125; for(ri i=1;i&lt;=n;++i)modify(i); puts(cnt==2?\"Yes\":\"No\"); return 0;&#125; Fake Plastic Treesæ¯æ¬¡å‡åˆ†å¶å­ç»™å­æ ‘ï¼Œè®°å¿†åŒ–ä¸€ä¸‹å°±è¡Œäº† CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int mod=1e9+7;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;vector&lt;ll&gt;vl;map&lt;ll,int&gt;idx;map&lt;ll,bool&gt;vs;inline void dfs(ll x)&#123; if(vs[x])return; vs[x]=1; vl.pb(x); if(x==1)return; dfs(x-(x&gt;&gt;1)),dfs(x&gt;&gt;1);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif ll x; int tot; for(ri tt=read();tt;--tt)&#123; x=readl(); vl.clear(); vs.clear(); dfs(x); sort(vl.begin(),vl.end()); idx.clear(); tot=-1; for(ri i=0;i&lt;vl.size();++i)idx[vl[i]]=++tot; cout&lt;&lt;tot+1&lt;&lt;'\\n'; cout&lt;&lt;-1&lt;&lt;' '&lt;&lt;-1&lt;&lt;'\\n'; for(ri i=1;i&lt;vl.size();++i)cout&lt;&lt;idx[vl[i]-(vl[i]&gt;&gt;1)]&lt;&lt;' '&lt;&lt;idx[vl[i]&gt;&gt;1]&lt;&lt;'\\n'; cout&lt;&lt;idx[vl.back()]&lt;&lt;'\\n'; &#125; return 0;&#125; Fascination Streeté¢˜æ„ç®€è¿°ï¼š è¡—é“ä¸Šæœ‰ä¸€æ’ç¯ï¼Œä¸€å¼€å§‹å…¨ç­ï¼Œç‚¹äº®æ¯ç›ç¯æœ‰ä¸€å®šä»£ä»·ï¼Œè¦æ±‚æœ€åå¯¹äºæ¯ä¸ªä½ç½®è·ç¦»è‡ªå·±ä¸è¶…è¿‡ $1$ çš„ç¯è‡³å°‘ç‚¹äº®ä¸€ç›ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œæœ‰ $k$ æ¬¡æœºä¼šäº¤æ¢ä¸¤ç›ï¼Œé—®æœ€å°ä»£ä»·ã€‚ æ•°æ®èŒƒå›´ï¼š $n\\le250000,k\\le9$ è§£é¢˜æ€è·¯ï¼š ä¸€é“æ¯”è¾ƒæœ‰æ„æ€çš„äºæ¬ å‹ $dp$ ï¼Œè€ƒè™‘åˆ°äº¤æ¢çš„ä¸€å®šæ˜¯ä¸€ç›äº®çš„å’Œä¸€ç›ç­çš„ï¼Œå¯ä»¥å®šä¹‰çŠ¶æ€ $f_{i,0/1,0/1,x,y}$ è¡¨ç¤ºè€ƒè™‘åˆ°ç¬¬ $i$ ç›ç¯ï¼Œæœ€åä¸¤ç›ç¯çš„äº®ç­çŠ¶æ€ï¼Œç°åœ¨å·²ç»æ¢äº† $x$ ç›äº®çš„ç¯ï¼Œ $y$ ç›ç­çš„ç¯ï¼Œç„¶åæšä¸¾å½“å‰ç¯äº®ä¸äº®ï¼Œæ¢ä¸æ¢å³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=250005;int n,K,vl[N],cur=0;ll f[2][2][2][10][10],inf;inline void ckmin(ll&amp;x,ll y)&#123;x=x&lt;y?x:y;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); for(ri i=1;i&lt;=n;++i)vl[i]=read(); memset(f[cur=0],0x3f,sizeof(f[0])); inf=f[cur][1][0][0][0],f[cur][1][0][0][0]=0; ll t; for(ri i=0;i&lt;n;++i)&#123; memset(f[cur^1],0x3f,sizeof(f[cur^1])); for(ri j=0;j&lt;2;++j)for(ri k=0;k&lt;2;++k)for(ri a=0;a&lt;=K;++a)for(ri b=0;b&lt;=K;++b)&#123; if(f[cur][j][k][a][b]==inf)continue; t=f[cur][j][k][a][b]; ckmin(f[cur^1][k][1][a][b],t+vl[i+1]); if(j|k)ckmin(f[cur^1][k][0][a][b],t); if(a&lt;K)ckmin(f[cur^1][k][1][a+1][b],t); if(b&lt;K&amp;&amp;(j|k))ckmin(f[cur^1][k][0][a][b+1],t+vl[i+1]); &#125; cur^=1; &#125; ll ans=inf; for(ri i=0;i&lt;2;++i)for(ri j=0;j&lt;2;++j)for(ri k=0;k&lt;=K;++k)if(i|j)ckmin(ans,f[cur][i][j][k][k]); cout&lt;&lt;ans; return 0;&#125; Fractionsæš´åŠ›æšä¸¾å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getcharinline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=1e5+5;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif ll a,b,c,d,xl,xr,yl,yr,ans=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; for(ri j,i=1;i&lt;=1000;++i)&#123; j=1; for(;;++j)&#123; if(__gcd(i,j)!=1)continue; if(i+j&gt;=1000)break; xl=a%i?a/i+1:a/i,xr=b/i; yl=c%j?c/j+1:c/j,yr=d/j; if(max(xl,yl)&lt;=min(xr,yr))ans+=min(xr,yr)-max(xl,yl)+1; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; Game on PlaneæŒ‰ç…§é¢˜æ„æšä¸¾æ–­è¾¹ï¼Œå‘ç°å‰©ä¸‹ä¸¤ä¸ªæˆäº†å­é—®é¢˜ï¼Œäºæ˜¯ç”¨ $SG$ å‡½æ•°å³å¯ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getcharinline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=5005;int n,a[N],sg[N];bool vis[N];inline void init()&#123; sg[2]=sg[3]=1; for(ri i=4;i&lt;=5000;++i)&#123; memset(vis,0,sizeof(vis)); for(ri j=0;j&lt;=i-2;++j)vis[sg[j]^sg[i-2-j]]=1; for(ri j=0;;++j)if(!vis[j])&#123;sg[i]=j;break;&#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri tt=read();tt;--tt)puts(sg[read()]?\"First\":\"Second\"); return 0;&#125; Histogram SequenceäºŒåˆ†+å•è°ƒæ ˆ+å †å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='O'&amp;&amp;ch!='#'&amp;&amp;ch!='.'&amp;&amp;ch!='*')ch=gc(); while(ch=='O'||ch=='#'||ch=='.'||ch=='*')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353,inv2=499122177; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=300005;int n,a[N],pl[N],pr[N],stk[N],tp;ll L,R;inline void init()&#123; stk[tp=1]=pl[1]=1; for(ri i=2;i&lt;=n;++i)&#123; while(tp&amp;&amp;a[stk[tp]]&gt;=a[i])--tp; pl[i]=stk[tp]+1; stk[++tp]=i; &#125; stk[0]=n+1; stk[tp=1]=pr[n]=n; for(ri i=n-1;i;--i)&#123; while(tp&amp;&amp;a[stk[tp]]&gt;a[i])--tp; pr[i]=stk[tp]-1; stk[++tp]=i; &#125;&#125;inline ll calc(ll lm,ll len)&#123; ll s=max(1ll,len-lm+1); return (len+s)*(len-s+1)/2;&#125;inline ll calc(ll lm)&#123; ll res=0; for(ri i=1;i&lt;=n;++i)&#123; if(a[i]&gt;lm)continue; res+=calc(lm/a[i],pr[i]-pl[i]+1)-calc(lm/a[i],pr[i]-i)-calc(lm/a[i],i-pl[i]); &#125; return res;&#125;inline int calc(int p,int l,int r,int len)&#123; return max((r-l+1)-len+1,0ll)-max((r-p)-len+1,0ll)-max((p-l)-len+1,0ll);&#125;struct Node&#123; ll h,w; int id; Node(ll h=0,ll w=0,int id=0):h(h),w(w),id(id)&#123;&#125; friend inline bool operator&lt;(Node a,Node b)&#123;return a.h*a.w&gt;b.h*b.w;&#125;&#125;tmp;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); L=readl(),R=readl(); init(); ll l=0,r=1e18,res=1e18; while(l&lt;=r)&#123; ll mid=l+r&gt;&gt;1; if(calc(mid)&gt;=L)r=mid-1,res=mid; else l=mid+1; &#125; ll lm=calc(res); while(L&lt;=R&amp;&amp;L&lt;=lm)&#123; ++L; cout&lt;&lt;res&lt;&lt;' '; &#125; priority_queue&lt;Node&gt;q; for(ri i=1;i&lt;=n;++i)q.push(Node(a[i],res/a[i]+1,i)); while(L&lt;=R)&#123; tmp=q.top(); q.pop(); int num=calc(tmp.id,pl[tmp.id],pr[tmp.id],tmp.w); if(!num)continue; while(num&amp;&amp;L&lt;=R)&#123; cout&lt;&lt;tmp.h*tmp.w&lt;&lt;' '; ++L; --num; &#125; ++tmp.w; q.push(tmp); &#125; return 0;&#125; Interesting Drugé¢˜æ„ç®€è¿°ï¼š ä¸€æ¡è·¯ä¸ŠæŒ‰é¡ºåºæœ‰ $n$ ç“¶æ¯’è¯ï¼Œå¯¹äº $iâˆˆ[1,n]$ ï¼Œæ±‚å‡ºå¦‚ä¸‹çš„å€¼ï¼šä» $i$ å‡ºå‘ï¼Œæ¯ä¸ªæ—¶åˆ»åƒæ‰å½“å‰ä½ç½®çš„æ¯’è¯ï¼Œç„¶åé€‰æ‹©ä¸‹ä¸€æ­¥åƒå·¦æˆ–å³çš„æ¯’è¯ï¼Œå°†æ¯æ¬¡é€‰æ‹©çš„ä½ç½®ææˆä¸€ä¸ªæ’åˆ— $p$ ï¼Œå…¶ä¼¤å®³å®šä¹‰ä¸º $\\sum\\limits_{j=1}^nd_j[p_{c_j}=j]$ ï¼Œæ±‚å¯èƒ½çš„æ’åˆ—ä¸­æœ€å¤§çš„ä¼¤å®³å€¼ã€‚ æ•°æ®èŒƒå›´ï¼š $n\\le3\\times10^5$ è§£é¢˜æ€è·¯ï¼š å®¹æ˜“çœ‹å‡ºä¸€ä¸ª $dp$ å³ $f_{i,j}$ è¡¨ç¤ºå·²ç»åƒæ‰åŒºé—´ $[i,j]$ çš„æ¯’è¯åˆ°åƒå®Œçš„æœ€å¤§å€¼ï¼Œè¿™æ ·æ”¾åˆ°äºŒç»´å¹³é¢ä¸Šæ¯æ¬¡è½¬ç§»å¯¹åº”å‘ä¸‹æˆ–è€…å‘å³èµ°ï¼Œè€Œç”±äºæœ€å¤šæœ‰ $2n$ æ¡è½¬ç§»è¾¹ï¼Œå› æ­¤æšä¸¾çºµåæ ‡ï¼Œç”¨æ ‘çŠ¶æ•°ç»„ä¿®æ”¹åç¼€å– $max$ å’ŒæŸ¥è¯¢å‰ç¼€ $max$ å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='O'&amp;&amp;ch!='#'&amp;&amp;ch!='.'&amp;&amp;ch!='*')ch=gc(); while(ch=='O'||ch=='#'||ch=='.'||ch=='*')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353,inv2=499122177; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=3e5+5;int n,c[N],d[N];ll bit[N];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void update(int x,ll v)&#123;for(;x;x^=lowbit(x))ckmax(bit[x],v);&#125;inline ll query(int x)&#123;ll res=0;for(;x&lt;=n;x+=lowbit(x))ckmax(res,bit[x]);return res;&#125;vector&lt;int&gt;ps[N];signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; c[i]=read(); if(c[i]!=1&amp;&amp;c[i]&lt;=i)ps[i-c[i]+1].pb(i); &#125; for(ri i=1;i&lt;=n;++i)d[i]=read(); for(ri i=1;i&lt;=n;++i)&#123; for(ri j=(int)ps[i].size()-1;~j;--j) update(ps[i][j]-1,query(ps[i][j])+d[ps[i][j]]); cout&lt;&lt;query(i)+(c[i]==1?d[i]:0)&lt;&lt;' '; if(i+c[i]-1&lt;=n)update(i+c[i]-1,query(i+c[i]-1)+d[i]); &#125; return 0;&#125; $$ --- ## [Timsort](https://codeforces.com/gym/102059/problem/L) ç›´æ¥æš´åŠ›å³å¯ï¼Œå¤æ‚åº¦æ˜¯è°ƒå’Œçº§æ•° CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getcharinline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=1e5+5;int n,a[N],f[N][2];pii ans[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); f[n][0]=f[n][1]=1; for(ri i=n-1;i;--i)&#123; f[i][0]=a[i]&lt;=a[i+1]?f[i+1][0]+1:1; f[i][1]=a[i]&gt;a[i+1]?f[i+1][1]+1:1; &#125; for(ri tt=read(),len;tt;--tt)&#123; len=read(); if(ans[len].fi)cout&lt;&lt;ans[len].fi&lt;&lt;' '&lt;&lt;ans[len].se&lt;&lt;'\\n'; else&#123; for(ri t,i=1;i&lt;=n;++i)&#123; ++ans[len].fi; if(f[i][0]&gt;=len)&#123; i+=f[i][0]-1; continue; &#125; if(f[i][1]&gt;=len)&#123; i+=f[i][1]-1; continue; &#125; t=max(f[i][0],f[i][1]); ans[len].se+=min(n-i+1-t,len-t); i+=min(n-i+1,len)-1; &#125; cout&lt;&lt;ans[len].fi&lt;&lt;' '&lt;&lt;ans[len].se&lt;&lt;'\\n'; &#125; &#125; return 0;&#125; Utilitarianismç›´æ¥ç”¨ $wqs$ äºŒåˆ†+ç®€å•æ ‘å½¢ $dp$ å³å¯ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef pair&lt;int,int&gt; pii;typedef long long ll;const int N=250005;int n,k;vector&lt;pii&gt;e[N];struct dat&#123; ll a; int b; dat(ll a=0,int b=0):a(a),b(b)&#123;&#125; friend inline dat operator+(const dat&amp;a,const dat&amp;b)&#123;return dat(a.a+b.a,a.b+b.b);&#125; friend inline dat operator-(const dat&amp;a,const dat&amp;b)&#123;return dat(a.a-b.a,a.b-b.b);&#125; friend inline bool operator&gt;(const dat&amp;a,const dat&amp;b)&#123;return a.a==b.a?a.b&gt;b.b:a.a&gt;b.a;&#125;&#125;f[N][2];inline dat max(const dat&amp;a,const dat&amp;b)&#123;return a&gt;b?a:b;&#125;void dfs(int p,int fa,ll tmp)&#123; f[p][0]=f[p][1]=dat(0,0); for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; dfs(v,p,tmp),f[p][0]=f[p][0]+max(f[v][0],f[v][1]); &#125; ll w; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; w=e[p][i].se+tmp; f[p][1]=max(f[p][1],f[p][0]-max(f[v][0],f[v][1])+f[v][0]+dat(w,1)); &#125;&#125;inline bool check(const double tmp)&#123; dfs(1,0,tmp); dat t=max(f[1][0],f[1][1]); return t.b&gt;=k;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),k=read(); for(ri i=1;i&lt;=n;++i)e[i].clear(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].push_back(pii(v,w)); e[v].push_back(pii(u,w)); &#125; ll L=-1e14,R=1e14,ans=1e14; while(L&lt;R)&#123; ll mid=(L+R+1)/2; if(check(mid))ans=mid,R=mid-1; else L=mid+1; &#125; dfs(1,0,ans); dat t=max(f[1][0],f[1][1]); if(t.b&lt;k)puts(\"Impossible\"); else cout&lt;&lt;(t.a-ans*k)&lt;&lt;'\\n'; return 0;&#125; æ€»ç»“ï¼š æˆ‘ $dp$ ä¸è¿‡å…³ æˆ‘$å›¾è®º$ä¸è¿‡å…³ æˆ‘$è‹±è¯­$ä¸è¿‡å…³","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"2019.10.15 æ¨¡æ‹Ÿæµ‹è¯•é¢˜è§£","slug":"191015test","date":"2019-10-15T13:13:46.000Z","updated":"2019-10-16T00:46:52.914Z","comments":true,"path":"191015test/","link":"","permalink":"http://ldxcaicai.github.io/191015test/","excerpt":"","text":"é¢˜ç›®æ¥æºï¼š $A: CF643D$ $B:TCO\\ BearDestroy$ Aé¢˜æ„ç®€è¿°ï¼š ç»™ä½ ä¸€ä¸ªæœ‰å‘åŸºç¯æ£®æ—ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªåç»§ï¼Œç„¶åå¯¹äºä¸€ä¸ªç‚¹ä¼šç»™å‡ºä¸€ä¸ª $ vl_i $ ï¼Œå®šä¹‰ $ E_i=\\frac{vl_i}{iå…¥åº¦+iå‡ºåº¦+1},res_i=vl_i\\%E_i+\\sum\\limits_{dist(i,v)\\le 1}E_v $ è¦æ±‚æ”¯æŒå¦‚ä¸‹æ“ä½œï¼š ä¿®æ”¹ä¸€ä¸ªç‚¹çš„åç»§ é—®ä¸€ä¸ªç‚¹çš„ $res$ æŸ¥è¯¢å…¨å±€ $res$ çš„æœ€å€¼ æ•°æ®èŒƒå›´: $n\\le100000$ $m\\le100000$ è§£é¢˜æ€è·¯ï¼š è€ƒè™‘ç”¨å¯åˆ å †ç»´æŠ¤å…¨å±€è¯¢é—®ï¼Œç„¶åå¯¹æ¯ä¸ªç‚¹è®°ä¸€ä¸ª $delta$ è¡¨ç¤ºå®ƒå¯¹å‰é©±çš„å½±å“ï¼Œç„¶åå°±å˜æˆäº†æ¨¡æ‹Ÿé¢˜ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;int du[N],n,m,a[N];ll det[N],vl[N],E[N],res[N];struct Set1&#123; priority_queue&lt;ll&gt;a,b; inline void ins(ll x)&#123;a.push(x);&#125; inline void del(ll x)&#123;b.push(x);&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline ll top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125; inline int size()const&#123;return a.size()-b.size();&#125;&#125;Mx[N],Ansmx;struct Set2&#123; priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;a,b; inline void ins(ll x)&#123;a.push(x);&#125; inline void del(ll x)&#123;b.push(x);&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline ll top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125; inline int size()const&#123;return a.size()-b.size();&#125;&#125;Mn[N],Ansmn;int main()&#123; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)vl[i]=readl(); for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); ++du[i],++du[a[i]]; &#125; for(ri i=1;i&lt;=n;++i)E[i]=vl[i]/(du[i]+1); for(ri i=1;i&lt;=n;++i)&#123; res[a[i]]+=E[i]-E[a[i]]; res[i]+=E[a[i]]-E[i]; res[i]+=vl[i]; &#125; for(ri i=1;i&lt;=n;++i)&#123; Mn[a[i]].ins(res[i]); Mx[a[i]].ins(res[i]); &#125; for(ri i=1;i&lt;=n;++i)&#123; if(Mx[i].size())Ansmx.ins(Mx[i].top()); if(Mn[i].size())Ansmn.ins(Mn[i].top()); &#125; ll dt; for(ri p,fp,ffp,x,y,op;m;--m)&#123; op=read(); if(op==1)&#123; x=read(),y=read(); p=a[x],fp=a[p],ffp=a[fp]; Ansmx.del(Mx[p].top()+det[p]); Ansmn.del(Mn[p].top()+det[p]); dt=vl[p]/du[p]-vl[p]/(du[p]+1); Mx[p].del(res[x]); Mn[p].del(res[x]); res[x]+=det[p]-E[p]; det[p]+=dt; if(Mx[p].size())Ansmx.ins(Mx[p].top()+det[p]); if(Mn[p].size())Ansmn.ins(Mn[p].top()+det[p]); Ansmx.del(Mx[fp].top()+det[fp]); Ansmn.del(Mn[fp].top()+det[fp]); Mx[fp].del(res[p]); Mn[fp].del(res[p]); res[p]-=dt*(du[p]-1); res[p]-=E[x]-E[p]; E[p]+=dt; Mx[fp].ins(res[p]); Mn[fp].ins(res[p]); Ansmx.ins(Mx[fp].top()+det[fp]); Ansmn.ins(Mn[fp].top()+det[fp]); Ansmx.del(Mx[ffp].top()+det[ffp]); Ansmn.del(Mn[ffp].top()+det[ffp]); Mx[ffp].del(res[fp]); Mn[ffp].del(res[fp]); res[fp]+=dt; Mx[ffp].ins(res[fp]); Mn[ffp].ins(res[fp]); Ansmx.ins(Mx[ffp].top()+det[ffp]); Ansmn.ins(Mn[ffp].top()+det[ffp]); --du[p]; a[x]=y; p=a[x],fp=a[p],ffp=a[fp]; if(Mx[p].size())Ansmx.del(Mx[p].top()+det[p]); if(Mn[p].size())Ansmn.del(Mn[p].top()+det[p]); dt=vl[p]/(du[p]+2)-vl[p]/(du[p]+1); det[p]+=dt; E[p]+=dt; res[x]-=det[p]-E[p]; Mx[p].ins(res[x]); Mn[p].ins(res[x]); Ansmx.ins(Mx[p].top()+det[p]); Ansmn.ins(Mn[p].top()+det[p]); Ansmx.del(Mx[fp].top()+det[fp]); Ansmn.del(Mn[fp].top()+det[fp]); Mx[fp].del(res[p]); Mn[fp].del(res[p]); res[p]-=dt*du[p]; res[p]+=E[x]-E[p]; Mx[fp].ins(res[p]); Mn[fp].ins(res[p]); Ansmx.ins(Mx[fp].top()+det[fp]); Ansmn.ins(Mn[fp].top()+det[fp]); Ansmx.del(Mx[ffp].top()+det[ffp]); Ansmn.del(Mn[ffp].top()+det[ffp]); Mx[ffp].del(res[fp]); Mn[ffp].del(res[fp]); res[fp]+=dt; Mx[ffp].ins(res[fp]); Mn[ffp].ins(res[fp]); Ansmx.ins(Mx[ffp].top()+det[ffp]); Ansmn.ins(Mn[ffp].top()+det[ffp]); ++du[p]; &#125; else if(op==2)&#123; x=read(); cout&lt;&lt;(res[x]+det[a[x]])&lt;&lt;'\\n'; &#125; else cout&lt;&lt;Ansmn.top()&lt;&lt;' '&lt;&lt;Ansmx.top()&lt;&lt;'\\n'; &#125; return 0;&#125; Bé¢˜æ„ç®€è¿°ï¼š ç»™ä¸€ä¸ª $nÃ—m$ çš„æ–¹æ ¼å›¾,æ¯ä¸ªæ ¼å­å¡«ä¸ŠEæˆ–è€…Sï¼Œä¸€ä¸ªäººä» $(0,0)$ å¼€å§‹æŒ‰è¡Œä¼˜å…ˆè¡ŒåŠ¨ï¼Œæ¯æ¬¡åˆ°ä¸€ä¸ªæ ¼å­ $(i,j)$ å°±æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š å¦‚æœè¯¥æ ¼å­å·²ç»æ”¾ç½®äº†éª¨ç‰Œ,é‚£ä¹ˆä¸æ“ä½œ è‹¥è¯¥æ ¼å­æ²¡æœ‰æ”¾ç½®éª¨ç‰Œä¸”è¯¥æ ¼å­å†™çš„æ˜¯Eï¼Œé‚£ä¹ˆä¼˜å…ˆæ”¾ä¸€å— $1Ã—2$ çš„éª¨ç‰Œï¼Œä¸è¡Œå°±æ”¾ä¸€å— $2Ã—1$ çš„éª¨ç‰Œï¼Œå†ä¸è¡Œå°±ä¸æ“ä½œ è‹¥è¯¥æ ¼å­æ²¡æœ‰æ”¾ç½®éª¨ç‰Œä¸”è¯¥æ ¼å­å†™çš„æ˜¯Sï¼Œé‚£ä¹ˆä¼˜å…ˆæ”¾ä¸€å— $2Ã—1$ çš„éª¨ç‰Œï¼Œä¸è¡Œå°±æ”¾ä¸€å— $1Ã—2$ çš„éª¨ç‰Œï¼Œå†ä¸è¡Œå°±ä¸æ“ä½œ ä¸€ä¸ªå›¾çš„å¾—åˆ†ä¸ºæ”¾ç½®çš„éª¨ç‰Œæ•°é‡,æ±‚ $2^{nÃ—m}$ ç§å›¾çš„å¾—åˆ†çš„å’Œå¯¹MODå–ä½™ æ•°æ®èŒƒå›´ï¼š $n\\le12$ $m\\le30$ è§£é¢˜æ€è·¯ï¼š è€ƒè™‘æ¯ä¸ªéª¨ç‰Œè¦ä¹ˆè¦†ç›– $(i,j),(i,j+1)$ ï¼Œè¦ä¹ˆè¦†ç›– $(i,j),(i+1,j)$ ï¼Œé‚£ä¹ˆå¦‚æœæŒ‰ç…§å¯¹è§’çº¿åˆ†å±‚çš„è¯è¿™æ˜¾ç„¶æ˜¯ä¸€ä¸ªåˆ†å±‚å›¾ $dp$ ï¼Œè¿™æ ·å°±å¯ä»¥è®¾ $f_{i,j}$ è¡¨ç¤ºç¬¬ $i$ å±‚çŠ¶æ€ä¸º $j$ çš„ç­”æ¡ˆï¼Œç„¶åå°±å¯ä»¥ç”¨çŠ¶å‹ $dp$ çš„æ€æƒ³è½¬ç§»äº†ï¼ˆå®è´¨ä¸Šè¿™ä¸ªåœ°æ–¹åˆ©ç”¨çš„æ˜¯æ’å¤´ $dp$ çš„æƒ³æ³• CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:0;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;int n,m,lm;#define getsta(x,y) ((x)&gt;&gt;((y)-1)&amp;1)#define sub(x) (1&lt;&lt;((x)-1))#define trans0 cf,cg,f,g#define trans1 add(cf,cf),add(cg,cg),f,g#define trans2 add(cf,cf),add(add(cf,cf),add(cg,cg)),f,g#define trans3 cf,add(cf,cg),f,ginline void update(int ps,int s1,int s2,int cf,int cg,vi&amp;f,vi&amp;g)&#123; if(ps==n+1)&#123; Add(f[s2],cf); Add(g[s2],cg); return; &#125; if(lm-ps&lt;0||lm-ps+1&gt;m)return update(ps+1,s1,s2,trans0); if(getsta(s1,ps))return update(ps+1,s1,s2,trans1); if(lm-ps+1==m||getsta(s2,ps))&#123; if(ps==n)update(ps+1,s1,s2,trans1); else update(ps+1,s1|sub(ps),s2|sub(ps+1),trans2); &#125; else&#123; if(ps==n)update(ps+1,s1|sub(ps),s2|sub(ps),trans2); else&#123; update(ps+1,s1|sub(ps),s2|sub(ps),trans3); update(ps+1,s1|sub(ps),s2|sub(ps+1),trans3); &#125; &#125;&#125;#undef sub#undef trans0#undef trans1#undef trans2#undef getstainline int solve()&#123; vii f(n+m+1),g(n+m+1); int all=1&lt;&lt;n; f[1].resize(all),g[1].resize(all); f[1][0]=1,g[1][0]=0; for(ri dep=1;dep&lt;n+m;++dep)&#123; lm=dep; f[dep+1].resize(all); g[dep+1].resize(all); for(ri sta=0;sta&lt;all;++sta) update(1,sta,0,f[dep][sta],g[dep][sta],f[dep+1],g[dep+1]); &#125; return g[n+m][0];&#125;class BearDestroys&#123; public: inline int sumUp(int n_,int m_,int mod_)&#123; mod=mod_,n=n_,m=m_; return solve(); &#125;&#125;; Cé¢˜æ„ç®€è¿°ï¼š æœ‰ $n$ ç§ä¸åŒçš„æœæ±ï¼Œç¬¬ $i$ ç§æœ‰ $c_i$ å‡ã€‚ç°åœ¨è¦å°†æ‰€æœ‰æœæ±æ”¾è¿› $m$ ä¸ªç“¶å­é‡Œï¼Œæ»¡è¶³æ¯ä¸ªç“¶å­é‡Œä¸è¶…è¿‡ä¸¤ç§æœæ±ä¸”æ‰€æœ‰ç“¶å­è£…çš„æœæ±é‡ä¸€æ ·ï¼Œé—® $m$ æœ€å°å€¼ï¼Œ(æœæ±é‡å…è®¸ä¸ºåˆ†æ•° æ•°æ®èŒƒå›´ï¼š $n\\le20$ $c_i\\le10^9$ è§£é¢˜æ€è·¯ï¼š å…ˆè€ƒè™‘ç­”æ¡ˆçš„ä¸Šç•Œï¼Œå®¹æ˜“å‘ç°æ˜¯ $n-1$ ï¼Œï¼ˆå¯ä»¥é€šè¿‡å½’çº³æ³•è¯æ˜ä¸€å®šå­˜åœ¨ $n-1$ ä¸ªç“¶å­çš„åˆæ³•æ–¹æ¡ˆ)ï¼Œç„¶åå‡è®¾ç°åœ¨ä¸€ä¸ªç“¶å­ä¸­æœ‰ä¸¤ç§æœæ± $a,b$ ï¼Œæˆ‘ä»¬åœ¨ $a,b$ ä¸­è¿ä¸Šä¸€æ¡è¾¹ï¼Œå‡è®¾ç­”æ¡ˆä¸º $m$ ï¼Œé‚£ä¹ˆä¸€å®šä¼šå°† $n$ ä¸ªç‚¹åˆ†æˆè‡³å°‘ $n-m$ ä¸ªè¿é€šå—ï¼Œè¿™æ ·ç›¸å½“äºå¯ä»¥æšä¸¾ $m$ ç„¶åé€’å½’æˆå­é—®é¢˜ï¼Œå¯¹äºä¸€ä¸ª $nâ€™$ ä¸ªç‚¹çš„ç‚¹é›†å¦‚æœå…¶å¯ä»¥è¢«åˆ†åˆ° $nâ€™-1$ ä¸ªç“¶å­é‡Œé‚£ä¹ˆå°±æ˜¯åˆæ³•çš„ï¼Œäºæ˜¯å°±èƒ½å¤Ÿæšä¸¾å­é›†è½¬ç§»ï¼Œå¤æ‚åº¦$O(3^n*n)$ ï¼Œå½“ç„¶å¯ä»¥ç”¨å­é›†å·ç§¯ç»§ç»­ä¼˜åŒ–ä½†æ˜¯ç”±äºæ•°æ®ä¸å¼ºå› æ­¤æ‡’å¾—å†™äº†~ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:0;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=25;int n,vl[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int all=1&lt;&lt;n; vi ct(all),id(all); vector&lt;ll&gt;ss(all); if(n&lt;=2)return puts(\"1\"),0; for(ri i=1;i&lt;=n;++i)id[1&lt;&lt;(i-1)]=i,vl[i]=read(); for(ri i=1;i&lt;all;++i)&#123; ct[i]=ct[i^(i&amp;-i)]+1; ss[i]=ss[i^(i&amp;-i)]+vl[id[i&amp;-i]]; &#125; for(ri i=n+1&gt;&gt;1;i&lt;n-1;++i)&#123; bool ff=0,tg; int s=all-1; while(1)&#123; tg=0; if((ll)ss[all-1]*(ct[s]-1)==(ll)ss[s]*i)&#123; ff=1; break; &#125; for(ri t=s;t;t=(t-1)&amp;s) if((ll)ss[all-1]*(ct[t]-1)==(ll)ss[t]*i)&#123; tg=1; s^=t; break; &#125; if(!tg)break; &#125; if(ff)&#123; cout&lt;&lt;i; return 0; &#125; &#125; cout&lt;&lt;n-1; return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"è€ƒè¯•é¢˜è§£","slug":"è€ƒè¯•é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/è€ƒè¯•é¢˜è§£/"}]},{"title":"CodeForces 1244 ç®€è¦é¢˜è§£","slug":"CF1244","date":"2019-10-14T08:59:39.000Z","updated":"2019-10-22T23:48:31.189Z","comments":true,"path":"CF1244/","link":"","permalink":"http://ldxcaicai.github.io/CF1244/","excerpt":"","text":"Aæ¨¡æ‹Ÿ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; int a=read(),b=read(),c=read(),d=read(),k=read(); int res=a%c?a/c+1:a/c,ress=b%d?b/d+1:b/d; if(res+ress&gt;k)puts(\"-1\"); else cout&lt;&lt;res&lt;&lt;' '&lt;&lt;ress&lt;&lt;'\\n'; &#125; return 0;&#125; Bç®€å•è´ªå¿ƒ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1005;char s[N];int n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(); Read(s); int ans=n,sum=n; for(ri i=1;i&lt;=n;++i)&#123; if(s[i]=='1')&#123; ++sum; ans=max(ans,i*2); ans=max(ans,(n-i+1)*2); &#125; &#125; ans=max(ans,sum); cout&lt;&lt;ans&lt;&lt;'\\n'; &#125; return 0;&#125; C$exgcd$ æ¿é¢˜ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1005;ll n,p,d,w;inline void exgcd(ll a,ll b,ll&amp;x,ll&amp;y)&#123; if(!b)&#123; x=1; y=0; return; &#125; exgcd(b,a%b,x,y); ll t=x; x=y,y=t-a/b*y;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=1;tt;--tt)&#123; n=readl(),p=readl(),w=readl(),d=readl(); ll g=__gcd(d,w); if(p%g)&#123; puts(\"-1\"); continue; &#125; p/=g,d/=g,w/=g; ll x,y; exgcd(w,d,x,y); y=(y%w+w)%w; y=y*(p%w)%w; x=(p-d*y)/w; if(x&lt;0)&#123; puts(\"-1\"); continue; &#125; if(n-x-y&lt;0)&#123; puts(\"-1\"); continue; &#125; cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;' '&lt;&lt;n-x-y&lt;&lt;'\\n'; &#125; return 0;&#125; Dåˆæ³•æƒ…å†µä¸€å®šæ˜¯æ¡é“¾ è²Œä¼¼ç›´æ¥æšä¸¾å·¦ç«¯çš„é¢œè‰²å…¶ä½™é¢œè‰²å°±å›ºå®šäº† ä½†ä¹Ÿå¯ä»¥å¼ºè¡Œ $dp$ å¥½å¥½çš„ç¡®æ˜¯æˆ‘æ¯”èµ›çš„æ—¶å€™è¢«é™æ™ºäº† CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=100005;int n,vl[N][4],q[N],hd,tl,vs[N],col[N];ll f[N][4][4];pii pre[N][4][4];vector&lt;int&gt;e[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=3;++i)for(ri j=1;j&lt;=n;++j)vl[j][i]=read(); for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; for(ri i=1;i&lt;=n;++i)if(e[i].size()&gt;2)return puts(\"-1\"),0; for(ri i=1;i&lt;=n;++i)&#123; if(e[i].size()==1)&#123; q[hd=tl=1]=i; break; &#125; &#125; while(hd&lt;=tl)&#123; int x=q[hd++]; vs[x]=1; for(ri i=0,v;i&lt;e[x].size();++i)&#123; if(vs[v=e[x][i]])continue; q[++tl]=v; &#125; &#125; memset(f,0x3f,sizeof(f)); for(ri i=1;i&lt;=3;++i)for(ri j=1;j&lt;=3;++j)if(i!=j)f[1][i][j]=vl[q[1]][j]; for(ri i=2;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=3;++j)&#123; for(ri k=1;k&lt;=3;++k)&#123; for(ri l=1;l&lt;=3;++l)&#123; if(j!=k&amp;&amp;k!=l&amp;&amp;j!=l)&#123; if(f[i-1][l][j]+vl[q[i]][k]&lt;f[i][j][k])&#123; f[i][j][k]=f[i-1][l][j]+vl[q[i]][k]; pre[i][j][k]=pii(l,j); &#125; &#125; &#125; &#125; &#125; &#125; ll res=1e18; pii las; for(ri i=1;i&lt;=3;++i)for(ri j=1;j&lt;=3;++j)&#123; if(i!=j)if(f[n][i][j]&lt;res)&#123; res=f[n][i][j]; las=pii(i,j); &#125; &#125; int ps=n; while(ps)&#123; col[q[ps]]=las.se; las=pre[ps][las.fi][las.se]; --ps; &#125; cout&lt;&lt;res&lt;&lt;'\\n'; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;col[i]&lt;&lt;' '; return 0;&#125; Eå…ˆæŠŠæ•°ç»„æ’åºï¼Œç„¶åå¤„ç†ä¸€ä¸‹å‰åç¼€å°±èƒ½ä¸ŠåŒæŒ‡é’ˆäº† CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=100005;int n,a[N],b[N],sig,pre[N],suf[N];ll Pre[N],Suf[N],pvl[N],svl[N];ll K;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); K=readl(); for(ri i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+n+1); sig=0; for(ri i=1;i&lt;=n;++i)&#123; if(a[i]!=a[i-1])a[++sig]=a[i],b[sig]=1; else ++b[sig]; &#125; for(ri i=1;i&lt;=sig;++i)pre[i]=pre[i-1]+b[i],Pre[i]=Pre[i-1]+(ll)b[i]*a[i],pvl[i]=(ll)pre[i]*a[i]-Pre[i]; for(ri i=sig;i;--i)suf[i]=suf[i+1]+b[i],Suf[i]=Suf[i+1]+(ll)b[i]*a[i],svl[i]=(ll)Suf[i]-(ll)suf[i]*a[i]; ll res=a[sig]-a[1]; for(ri ps1=1,ps2=1;ps1&lt;=sig;++ps1)&#123; while(ps2&lt;=sig&amp;&amp;pvl[ps1]+svl[ps2]&gt;K)++ps2; if(ps2&gt;sig)break; if(ps1&gt;=ps2)return puts(\"0\"),0; res=min(res,a[ps2]-a[ps1]-(K-pvl[ps1]-svl[ps2])/suf[ps2]); &#125; for(ri ps1=sig,ps2=sig;ps2;--ps2)&#123; while(ps1&amp;&amp;pvl[ps1]+svl[ps2]&gt;K)--ps1; if(!ps1)break; if(ps1&gt;=ps2)return puts(\"0\"),0; res=min(res,a[ps2]-a[ps1]-(K-pvl[ps1]-svl[ps2])/pre[ps1]); &#125; cout&lt;&lt;res; return 0;&#125; Féšä¾¿æ‰¾ä¸ªè§„å¾‹å°±è¡Œäº†ï¼Œç„¶ååˆ†å¥‡å¶è®¨è®ºä¸€ä¸‹ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=6e5+5;int n,k;char s[N];inline void check1()&#123; if(n&amp;1)return; for(ri i=2;i&lt;=n;++i)if(s[i]==s[i-1])return; k&amp;=1; for(ri i=1;i&lt;=n;++i)&#123; if(k==1)&#123; if(s[i]=='W')cout&lt;&lt;'B'; else cout&lt;&lt;'W'; &#125; else cout&lt;&lt;s[i]; &#125; exit(0);&#125;inline void check2()&#123; for(ri i=2;i&lt;=n;++i)if(s[i]!=s[i-1])return; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;s[i]; exit(0);&#125;bool ban[N];char res[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),k=read(); Read(s); check1(); check2(); for(ri i=1;i&lt;=n;++i)s[i+n]=s[i+n*2]=s[i]; int st; for(ri i=1;i&lt;=n;++i)&#123; if(s[i]==s[i+1])&#123; st=i; break; &#125; &#125; int mid,L=st,R=st+n-1,l,r; for(l=L;l&lt;=R;l=r+1)&#123; r=l; while(r&lt;R&amp;&amp;s[r+1]==s[r])++r; if(r==R)break; mid=r; while(r&lt;=R&amp;&amp;s[r+1]!=s[r])++r; --r; if(mid==r)continue; if(r-mid&lt;=k*2)for(ri p1=mid+1,p2=r;p1&lt;=p2;++p1,--p2)&#123; s[p1]=s[l],s[p2]=s[r+1]; &#125; else&#123; int p1,p2,i; for(p1=mid+1,p2=r,i=1;i&lt;=k;++i,++p1,--p2)&#123; s[p1]=s[l],s[p2]=s[r+1]; &#125; if(k&amp;1)for(ri i=p1;i&lt;=p2;++i)s[i]=s[i]=='B'?'W':'B'; &#125; &#125; for(ri i=L;i&lt;=R;++i)&#123; if(i&gt;n)s[i-n]=s[i]; &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;s[i]; return 0;&#125; Géšä¾¿è´ªä¸ªå¿ƒå°±è¿‡äº†ï¼Œè¯æ˜å¾ˆç®€å•ï¼ˆè™½ç„¶æˆ‘ç›´æ¥çè´ªçš„ä½†åæ¥ $cyktxdy$ è·Ÿæˆ‘è¯´äº†ä¸€ä¸ªè¯æ˜æ–¹æ³•æ„Ÿè§‰è¿˜æŒº $naiive$ çš„ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1e6+5;int n;ll K;#define lc (p&lt;&lt;1)#define rc (p&lt;&lt;1|1)#define mid (l+r&gt;&gt;1)int siz[N&lt;&lt;2];inline void build(int p,int l,int r)&#123; siz[p]=r-l+1; if(l==r)return; build(lc,l,mid),build(rc,mid+1,r);&#125;inline int query(int p,int l,int r)&#123; if(!siz[p])return -1; if(l==r)return l; return siz[lc]?query(lc,l,mid):query(rc,mid+1,r);&#125;inline void update(int p,int l,int r,int k)&#123; if(l==r)&#123; siz[p]=0; return; &#125; k&lt;=mid?update(lc,l,mid,k):update(rc,mid+1,r,k); siz[p]=siz[lc]+siz[rc];&#125;inline int query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return query(p,l,r); if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); int res=query(lc,l,mid,ql,qr); if(~res)return res; return query(rc,mid+1,r,ql,qr); &#125;#undef lc#undef rc#undef midint ans[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); K=readl(); ll ss=0; if(K&lt;(ll)n*(n+1)/2)return puts(\"-1\"),0; ll T=K; K-=(ll)n*(n+1)/2; build(1,1,n); for(ri i=n;i;--i)&#123; int ql=max(1ll,i-K),qr=i; int x=query(1,1,n,ql,qr); if(~x)ans[x]=i,K-=i-x; else ans[x=query(1,1,n,qr+1,n)]=i; update(1,1,n,x); &#125; cout&lt;&lt;T-K&lt;&lt;'\\n'; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;i&lt;&lt;' '; puts(\"\"); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;ans[i]&lt;&lt;' '; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"LibreOJ NOI Round2 Day1 ç®€è¦é¢˜è§£","slug":"LNRR2D1","date":"2019-10-14T08:41:11.000Z","updated":"2019-10-14T08:54:13.697Z","comments":true,"path":"LNRR2D1/","link":"","permalink":"http://ldxcaicai.github.io/LNRR2D1/","excerpt":"","text":"Aå®¹æ˜“å‘ç°åŸé¢˜ä¸­çš„è¿ç®—å¯ä»¥ç”¨çŸ©é˜µå®Œæˆ $O(n)$ ç»´æŠ¤çŸ©é˜µå’Œé€†çŸ©é˜µå³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch; return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int findInv(int a)&#123;return ksm(a,mod-2);&#125;&#125;using namespace modular;const int N=1e6+5;vector&lt;int&gt;e[N];struct Mat&#123; int a[2][2]; inline int*operator[](const int&amp;k)&#123;return a[k];&#125; Mat()&#123;a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;&#125; Mat(int x,int typ)&#123; typ==0? (a[0][0]=x,a[0][1]=1,a[1][0]=1,a[1][1]=0): (a[0][0]=0,a[0][1]=1,a[1][0]=1,a[1][1]=x?mod-x:0); &#125; friend inline Mat operator+(Mat a,Mat b)&#123; Mat ret; ret[0][0]=((ll)a[0][0]*b[0][0]+(ll)a[0][1]*b[1][0])%mod; ret[0][1]=((ll)a[0][0]*b[0][1]+(ll)a[0][1]*b[1][1])%mod; ret[1][0]=((ll)a[1][0]*b[0][0]+(ll)a[1][1]*b[1][0])%mod; ret[1][1]=((ll)a[1][0]*b[0][1]+(ll)a[1][1]*b[1][1])%mod; return ret; &#125;&#125;pre[N][2];int n,m,opt,a[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),opt=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); pre[0][0]=Mat(0,0),pre[0][1]=Mat(0,1); for(ri i=1;i&lt;=n;++i)&#123; pre[i][0]=pre[i-1][0]+Mat(a[i],0); pre[i][1]=Mat(a[i],1)+pre[i-1][1]; &#125; for(ri ansx=0,ansy=0,op,l,r,i=1;i&lt;=m;++i)&#123; op=read(); if(op==1)&#123; a[++n]=read()^ansx^ansy; pre[n][0]=pre[n-1][0]+Mat(a[n],0); pre[n][1]=Mat(a[n],1)+pre[n-1][1]; &#125; else&#123; l=read()^ansx^ansy,r=read()^ansx^ansy; Mat coe=pre[l-1][1]+pre[r-1][0]; ansx=((ll)coe[0][0]*a[r]+coe[0][1])%mod; cout&lt;&lt;ansx&lt;&lt;' '; ansy=((ll)coe[1][0]*a[r]+coe[1][1])%mod; cout&lt;&lt;ansy&lt;&lt;'\\n'; &#125; ansx*=opt; ansy*=opt; &#125; return 0;&#125; Bå®¹æ˜“æƒ³åˆ°è´¹ç”¨æµåšæ³•ï¼Œç„¶åå‘ç°å¯ä»¥ç”¨ $HLD$ +è´ªå¿ƒæ¨¡æ‹Ÿè´¹ç”¨æµæ¥è§£å†³æ‰å…ˆå‡ºç°æ‰€æœ‰é‡‘çŸ¿çš„æ•°æ®ç‚¹ ä¸‹é¢å°†é‡‘çŸ¿æˆä¸ºæ´ï¼ŒçŸ¿å·¥ç§°ä¸ºè€é¼  è€ƒè™‘ç”¨çº¿æ®µæ ‘åˆ†æ²»æ¥å°†é—®é¢˜è½¬åŒ–æˆä¸Šè¿°æƒ…å†µï¼Œè€ƒè™‘å¯¹æ¯ä¸ªæ´å»ºä¸€ä¸ªè™šçš„è€é¼ è¿›è¡ŒåŒ¹é…ï¼Œä½¿å¾—ä»£ä»·å’Œä¸ºä¸€ä¸ªç¡®å®šçš„æå¤§å€¼ $inf$ ï¼Œç„¶åç»™åŸæœ¬æ”¾æ´çš„åœ°æ–¹å»ºä¸€ä¸ªè™šå„¿å­ $x$ ï¼Œå°†è¿™ä¸ªæ´å’Œè€é¼ éƒ½æ”¾å…¥ $x$ å³å¯ï¼Œæ­£ç¡®æ€§æ˜¾ç„¶ ç„¶åå°† $HLD$ +çº¿æ®µæ ‘æ¢æˆå…¨å±€å¹³è¡¡äºŒå‰æ ‘å³å¯ï¼Œå¤æ‚åº¦ $O(n\\log^2 n)$ ç„¶åæˆ‘å’Œcykä¸¤ä¸ªäººä¸€èµ·å¡å¸¸æ•°å¡äº†ä¸€ä¸‹åˆæ²¡å¡è¿‡å»ï¼Œåªèƒ½ $96pts$ æ»šäº†ï¼Œæå‡ºè¿™ä¸ªç®—æ³•çš„ç”¨æˆ·hychycçš„acä»£ç è²Œä¼¼æ”¾å®½äº†æ—¶é™æ‰è¿‡æ‰äº†æœ€åä¸€ä¸ªç‚¹ï¼Œæˆ‘æœ¬åœ°æµ‹äº†ä¸€ä¸‹ä»–æœ€åä¸€ä¸ªç‚¹æ¯”æˆ‘æ…¢7s ç•™ä¸ªé“¾åˆ†æ²»çš„å‘ä»¥åæ¥å¡«å§ 96ptsCODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=2e5+5;int n,m,dist[N];vector&lt;pii&gt;e[N];int siz[N],dep[N],dis[N],fa[N],top[N],bot[N],num[N],hson[N],pred[N],tot=0;void dfs1(int p)&#123; siz[p]=1; for(ri i=0,v;i&lt;(int)e[p].size();++i)&#123; v=e[p][i].fi,fa[v]=p; dis[v]=dis[p]+e[p][i].se; dep[v]=dep[p]+1,dfs1(v); siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]])hson[p]=v; &#125;&#125;void dfs2(int p,int tp)&#123; top[p]=tp,pred[num[p]=++tot]=p; if(!hson[p])&#123; bot[p]=p; return; &#125; dfs2(hson[p],tp),bot[p]=bot[hson[p]]; for(ri i=0,v;i&lt;(int)e[p].size();++i)&#123; if((v=e[p][i].fi)==hson[p])continue; dfs2(v,v); &#125;&#125;const int inf=1e9;struct Set&#123; priority_queue&lt;ll&gt;a,b; inline void ins(int x)&#123;a.push(x);&#125; inline void del(int x)&#123;b.push(x);&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline int size()const&#123;return a.size()-b.size();&#125; inline int top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125;&#125;S[N];namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) int M; pii mx[1&lt;&lt;20|5]; inline void build(int n)&#123; for(M=1;M&lt;=n+1;M&lt;&lt;=1); for(ri i=1;i&lt;=M*2-1;++i)mx[i]=pii(-inf,-inf); for(ri i=1;i&lt;=n;++i)mx[i+M]=pii(-inf,pred[i]); for(ri p=M-1;p;--p)mx[p]=max(mx[lc],mx[rc]); cerr&lt;&lt;mx[1].fi&lt;&lt;' '&lt;&lt;mx[1].se&lt;&lt;'\\n'; &#125; inline void update(int p,int vl)&#123; mx[p+=M].fi=vl; for(p&gt;&gt;=1;p;p&gt;&gt;=1)mx[p]=max(mx[lc],mx[rc]); &#125; inline pii query(int l,int r)&#123; pii res=mx[l+M]; for(l+=M-1,r+=M+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1)&#123; if(l&amp;1^1)res=max(res,mx[l^1]); if(r&amp;1)res=max(res,mx[r^1]); &#125; if(!res.se)&#123; cerr&lt;&lt;res.fi&lt;&lt;'\\n'; &#125; return res; &#125; #undef lc #undef rc #undef mid&#125;//namespace sgt&#123;// #define lc (p&lt;&lt;1)// #define rc (p&lt;&lt;1|1)// #define mid (l+r&gt;&gt;1)// pli mx[N&lt;&lt;2];// inline void build(int p,int l,int r)&#123;// if(l==r)&#123;// mx[p]=pli(-inf,pred[l]);// return;// &#125;// build(lc,l,mid),build(rc,mid+1,r);// mx[p]=max(mx[lc],mx[rc]);// &#125;// inline void update(int p,int l,int r,int k,ll vl)&#123;// if(l==r)&#123;// mx[p].fi=vl;// return;// &#125;// k&lt;=mid?update(lc,l,mid,k,vl):update(rc,mid+1,r,k,vl);// mx[p]=max(mx[lc],mx[rc]);// &#125;// inline pli query(int p,int l,int r,int ql,int qr)&#123;// if(ql&lt;=l&amp;&amp;r&lt;=qr)return mx[p];// if(qr&lt;=mid)return query(lc,l,mid,ql,qr);// if(ql&gt;mid)return query(rc,mid+1,r,ql,qr);// return max(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr));// &#125;// #undef lc// #undef rc// #undef mid//&#125;inline pii operator+(pii a,pii b)&#123; if(a.fi!=b.fi)return min(a,b); return dep[a.se]&gt;dep[b.se]?a:b;&#125;namespace bst&#123; #define lc (son[p][0]) #define rc (son[p][1]) int ft[N],tg[N&lt;&lt;2],son[N][2]; pii vl[N&lt;&lt;2],mn[N&lt;&lt;2]; inline void pushup(int p)&#123; if(lc&amp;&amp;rc)mn[p]=mn[lc]+vl[p]+mn[rc]; else if(lc)mn[p]=mn[lc]+vl[p]; else if(rc)mn[p]=vl[p]+mn[rc]; else mn[p]=vl[p]; &#125; inline bool isroot(int x)&#123;return !ft[x]||(son[ft[x]][0]!=x&amp;&amp;son[ft[x]][1]!=x);&#125; inline void pushnow(int x,int v)&#123;vl[x].fi+=v,mn[x].fi+=v,tg[x]+=v;&#125; inline void pushdown(int p)&#123; if(tg[p])&#123; if(lc)pushnow(lc,tg[p]); if(rc)pushnow(rc,tg[p]); tg[p]=0; &#125; &#125; inline int build(int l,int r,int dt=0)&#123; if(l&gt;r)return 0; if(l==r)return pred[l]; for(ri p,i=r;i&gt;=l;--i)&#123; if(siz[pred[i]]*2&gt;=siz[pred[l]]+dt)&#123; p=pred[i]; lc=build(l,i-1,siz[p]); rc=build(i+1,r,dt); ft[lc]=ft[rc]=p; pushup(p); return p; &#125; &#125; &#125; inline int build(int p)&#123; for(ri x=p;x;x=hson[x])&#123; vl[x]=mn[x]=pii(0,x); for(ri i=0,v;i&lt;(int)e[x].size();++i) if((v=e[x][i].fi)!=hson[x])ft[build(v)]=x; &#125; return build(num[p],num[bot[p]]); &#125; int Stk[N],Tp; inline void update(int p,int v)&#123; while(p)&#123; Stk[Tp=1]=p; for(ri x=p;!isroot(x);x=ft[x])Stk[++Tp]=ft[x]; while(Tp)pushdown(Stk[Tp--]); vl[p].fi+=v; if(lc)pushnow(lc,v); pushup(p); while(!isroot(p))&#123; if(son[ft[p]][1]==p)&#123; vl[ft[p]].fi+=v; if(son[ft[p]][0])pushnow(son[ft[p]][0],v); &#125; p=ft[p]; pushup(p); &#125; p=ft[p]; &#125; &#125; inline pii query(int p)&#123; pii res=pii(inf,0); while(p)&#123; Stk[Tp=1]=p; for(ri x=p;!isroot(x);x=ft[x])Stk[++Tp]=ft[x]; while(Tp)pushdown(Stk[Tp--]); res=res+vl[p]; if(lc)res=res+mn[lc]; while(!isroot(p))&#123; if(son[ft[p]][1]==p)&#123; res=res+vl[ft[p]]; if(son[ft[p]][0])res=res+mn[son[ft[p]][0]]; &#125; p=ft[p]; &#125; p=ft[p]; &#125; return res; &#125; int Dep[N]; inline int querydep(int x)&#123; if(!ft[x])return Dep[x]=1; if(Dep[x])return Dep[x]; return Dep[x]=querydep(ft[x])+1; &#125; #undef lc #undef rc&#125;int rt,suf[N];struct Qry&#123;int op,id,vl;&#125;qry[N];bool vs[N];#define lc (p&lt;&lt;1)#define rc (p&lt;&lt;1|1)#define mid (l+r&gt;&gt;1)vector&lt;pii&gt;upd[N&lt;&lt;2];inline void update(int p,int l,int r,int ql,int qr,pii v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return upd[p].pb(v); if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v);&#125;ll ss=0,curss;struct node&#123; int op,id,vl; node()&#123;op=id=vl=0;&#125; node(int op,int id,ll vl):op(op),id(id),vl(vl)&#123;&#125;&#125;;vector&lt;node&gt;stk;inline void change(pii F)&#123; pii tp=bst::query(F.se); int p=tp.fi&gt;0?rt:tp.se; //pli tp=sgt::query(1,1,n,num[p],num[p]+siz[p]-1); tp=sgt::query(num[p],num[p]+siz[p]-1); if(tp.fi+F.fi&lt;=0)return; ss+=tp.fi+F.fi; S[F.se].ins(-F.fi); //sgt::update(1,1,n,num[F.se],S[F.se].top()); sgt::update(num[F.se],S[F.se].top()); bst::update(F.se,-1); stk.pb(node(1,F.se,-F.fi)); stk.pb(node(3,F.se,1)); S[tp.se].del(tp.fi); //sgt::update(1,1,n,num[tp.se],S[tp.se].top()); sgt::update(num[tp.se],S[tp.se].top()); bst::update(tp.se,1); stk.pb(node(2,tp.se,tp.fi)); stk.pb(node(3,tp.se,-1));&#125;inline void Pop()&#123; node t=stk.back(); stk.pop_back(); if(t.op==1)&#123; S[t.id].del(t.vl); //sgt::update(1,1,n,num[t.id],S[t.id].top()); sgt::update(num[t.id],S[t.id].top()); &#125; if(t.op==2)&#123; S[t.id].ins(t.vl); //sgt::update(1,1,n,num[t.id],S[t.id].top()); sgt::update(num[t.id],S[t.id].top()); &#125; if(t.op==3)bst::update(t.id,t.vl);&#125;inline void solve(int p,int l,int r)&#123; int sz=stk.size(); ll curss=ss; for(ri i=(int)upd[p].size()-1;~i;--i)change(upd[p][i]); if(l==r)cout&lt;&lt;ss-(ll)suf[l]*inf&lt;&lt;'\\n'; else solve(lc,l,mid),solve(rc,mid+1,r); while(stk.size()!=sz)Pop(); ss=curss;&#125;#undef lc#undef rc#undef midsigned main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); freopen(\"std.out\",\"w\",stdout); #endif int tt=clock(); n=read(),m=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); vs[v]=1; e[u].pb(pii(v,w)); &#125; for(ri i=1;i&lt;=n;++i)if(!vs[i])&#123; rt=i; break; &#125; for(ri i=1;i&lt;=m;++i)&#123; qry[i].op=read(); qry[i].id=read(); qry[i].vl=read(); if(qry[i].op==2)&#123; ++n; e[qry[i].id].pb(pii(n,0)); qry[i].id=n; &#125; &#125; for(ri i=1;i&lt;=n;++i)S[i].ins(-inf); dep[rt]=1; dfs1(rt); dfs2(rt,rt); //sgt::build(1,1,n); sgt::build(n); bst::build(rt); int mxdep=0; for(ri i=1;i&lt;=n;++i)mxdep=max(mxdep,bst::querydep(i)); for(ri i=1;i&lt;=m;++i)&#123; if(qry[i].op==1)&#123; qry[i].vl-=dis[qry[i].id]; update(1,1,m,i,m,pii(qry[i].vl,qry[i].id)); &#125; else&#123; qry[i].vl+=dis[qry[i].id]; if(i!=1)update(1,1,m,1,i-1,pii(inf-qry[i].vl,qry[i].id)); S[qry[i].id].ins(qry[i].vl); //sgt::update(1,1,n,num[qry[i].id],S[qry[i].id].top()); sgt::update(num[qry[i].id],S[qry[i].id].top()); &#125; &#125; suf[m]=0; for(ri i=m-1;i;--i)suf[i]=suf[i+1]+(qry[i+1].op==2); solve(1,1,m); return 0;&#125; Cä¸€ä¸ªæ¯”è¾ƒå¥—è·¯åŒ–çš„å®¹æ–¥ï¼ŒåŸºæœ¬ä¸Šè·Ÿ $PE$ çš„ $permuted\\ matrices$ æ˜¯ä¸€æ ·çš„ï¼Œå°±ä¸ç»†è®²äº† ç„¶åè¦åŠ ä¸Šä¸€ä¸ªåˆ†æ²» $ntt$ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(int*s)&#123; int top=0; char ch=gc(); while(ch!='&lt;'&amp;&amp;ch!='&gt;')ch=gc(); while(ch=='&lt;'||ch=='&gt;')s[++top]=ch=='&gt;',ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int lim,tim,w[22],invv[22];vector&lt;int&gt;rev[22];inline void init_ntt()&#123; invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;22;++i)invv[i]=mul(invv[i-1],iv); w[21]=ksm(3,(mod-1)&gt;&gt;22); for(ri i=20;~i;--i)w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(const int&amp;up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))a0=a[j+k],a1=mul(mt,a[j+k+i]),a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(~typ)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j)Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;poly f,g;const int N=1e5+5;int s[N];int n,cnt[N],fac[N],ifac[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]); ifac[0]=0;&#125;inline void solve(int l,int r)&#123; if(l==r)return; int mid=l+r&gt;&gt;1; solve(l,mid); poly a(mid-l+1),b(r-l+1); for(ri i=l;i&lt;=mid;++i)a[i-l]=mul(f[i],mul(s[i],cnt[i])); b.resize(r-l+1); for(ri i=0;i&lt;=r-l;++i)b[i]=ifac[i]; a=a*b; for(ri i=mid+1;i&lt;=r;++i)Add(f[i],mul(a[i-l],cnt[i-1])); solve(mid+1,r);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init_ntt(); n=Read(s)+1; f.resize(n+1); init(); s[0]=1,cnt[0]=0; f[0]=1; for(ri i=1;i&lt;=n;++i)cnt[i]=cnt[i-1]+s[i]; for(ri i=0;i&lt;=n;++i)cnt[i]=cnt[i]&amp;1?mod-1:1; solve(0,n); cout&lt;&lt;mul(f[n],fac[n]); return 0;&#125; å‘Šè¾","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"CodeForces 1228 ç®€è¦é¢˜è§£","slug":"CF1228","date":"2019-10-12T15:45:41.000Z","updated":"2019-10-22T23:48:26.300Z","comments":true,"path":"CF1228/","link":"","permalink":"http://ldxcaicai.github.io/CF1228/","excerpt":"","text":"Aæ¨¡æ‹Ÿ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int l,r;inline bool check(int x)&#123; int cnt[15]; for(ri i=0;i&lt;10;++i)cnt[i]=0; while(x)++cnt[x%10],x/=10; for(ri i=0;i&lt;10;++i)if(cnt[i]&gt;1)return 0; return 1;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif l=read(),r=read(); for(ri i=l;i&lt;=r;++i)&#123; if(check(i))return cout&lt;&lt;i,0; &#125; puts(\"-1\"); return 0;&#125; Bæ¨¡æ‹Ÿ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1005;int n,m,f[N][N],a[N],b[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); for(ri i=1;i&lt;=m;++i)b[i]=read(); int res=1; for(ri i=1;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=m;++j)&#123; if(a[i]&gt;=j&amp;&amp;b[j]+1==i)return puts(\"0\"),0; if(a[i]+1==j&amp;&amp;b[j]&gt;=i)return puts(\"0\"),0; if(b[j]+1==i||a[i]+1==j||a[i]&gt;=j||b[j]&gt;=i)continue; res=add(res,res); &#125; &#125; cout&lt;&lt;res; return 0;&#125; Cåˆ†è§£è´¨å› æ•° CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int x;ll n;vector&lt;int&gt;divv;inline void divid(int x)&#123; for(ri i=2,lm=sqrt(x);i&lt;=lm&amp;&amp;x!=1;++i)&#123; if(x!=x/i*i)continue; divv.pb(i); while(x==x/i*i)x/=i; &#125; if(x^1)divv.pb(x);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif x=read(); n=readl(); divid(x); int res=1; for(ri i=divv.size()-1;~i;--i)&#123; ll mt=divv[i]; while(1)&#123; int tot=(n/mt-n/mt/divv[i])%(mod-1); Mul(res,ksm((ll)mt%mod,tot)); if(!(n/mt/divv[i]))break; mt*=divv[i]; &#125; &#125; cout&lt;&lt;res; return 0;&#125; Dæ™®åŠ-é¢˜ä¸ºå•¥ä¸æ”¾ $A$ å•Šï¼Ÿï¼Ÿï¼Ÿ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=3e5+5;int n,m,col[N];vector&lt;int&gt;e[N],tp[4];bool vs[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)col[i]=-1; for(ri u,v,i=1;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; for(ri i=0;i&lt;e[1].size();++i)vs[e[1][i]]=1; for(ri i=1;i&lt;=n;++i)if(!vs[i])tp[1].pb(i),col[i]=1; int ps=-1; for(ri i=1;i&lt;=n;++i)&#123; if(vs[i])&#123; ps=i; break; &#125; &#125; if(ps==-1)return puts(\"-1\"),0; for(ri i=0;i&lt;e[ps].size();++i)if(vs[e[ps][i]])tp[3].pb(e[ps][i]),col[e[ps][i]]=3; for(ri i=1;i&lt;=n;++i)if(col[i]==-1)col[i]=2,tp[2].pb(i); if(!tp[2].size()||!tp[3].size())return puts(\"-1\"),0; if((ll)tp[1].size()*tp[2].size()+(ll)tp[2].size()*tp[3].size()+(ll)tp[3].size()*tp[1].size()!=m)return puts(\"-1\"),0; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;e[i].size();++j)if(col[i]==col[e[i][j]])return puts(\"-1\"),0; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;col[i]&lt;&lt;' '; return 0;&#125; Eç®€å•å®¹æ–¥å³å¯ $O(n^2)$ ï¼ŒæŠŠå¼å­æ‹†å¼€ä¹Ÿå¯ä»¥åšåˆ° $O(n\\log n)$ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=255*255;int n,K,fac[N],ifac[N],pw1[N],pw2[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1,pw1[0]=pw2[0]=1,pw1[1]=K,pw2[1]=K-1; for(ri i=2;i&lt;=n*n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); pw1[i]=mul(pw1[i-1],K); pw2[i]=mul(pw2[i-1],K-1); &#125; for(ri i=2;i&lt;=n*n;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return mul(fac[n],mul(ifac[m],ifac[n-m]));&#125; int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); init(); int res=0; for(ri t,x,i=0;i&lt;=n;++i)for(ri j=0;j&lt;=n;++j)&#123; t=mul(pw1[(n-i)*(n-j)],pw2[n*n-(n-i)*(n-j)]); Mul(t,mul(C(n,i),C(n,j))); (i+j)&amp;1?Dec(res,t):Add(res,t); &#125; cout&lt;&lt;res&lt;&lt;'\\n'; return 0;&#125; Få¤§åˆ†ç±»è®¨è®ºï¼Œä¸çŸ¥é“ä¸ºå•¥æˆ‘å†™çš„é‚£ä¹ˆéº»çƒ¦=.=ï¼Œçœ‹åˆ«äººè®¨è®ºçš„å¥½åƒå¾ˆç®€å•ï¼Œç›´æ¥å»ä¸–äº† æˆ‘çš„è®¨è®ºï¼š è‡ªå·±æ˜¯å¶å­ çˆ¶äº²æ˜¯æ ¹ è‡ªå·±ä¸æ˜¯å¶å­ä¸”çˆ¶äº²ä¸æ˜¯æ ¹ ä»£ç ä¸‘æ­»äº† CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1&lt;&lt;18|5;int n,m,siz[N],Fa[N];vector&lt;int&gt;e[N],RT;#define fail puts(\"0\"),exit(0)void dfs(int p,int ft)&#123; siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; Fa[v]=p; dfs(v,p); siz[p]+=siz[v]; &#125; if(siz[p]*2==n)RT.pb(p),RT.pb(ft);&#125;int ban,ad[N];bool check(int p,int ft)&#123; if(siz[p]==1)return 1; if(p==ban)&#123; vector&lt;pii&gt;tp; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; tp.pb(pii(siz[v],v)); &#125; sort(tp.begin(),tp.end()); if(tp[0].fi!=tp[1].fi)fail; if(tp[0].fi+tp[1].fi+1!=tp[2].fi)fail; return check(tp[0].se,p)&amp;&amp;check(tp[1].se,p)&amp;&amp;check(tp[2].se,p); &#125; else&#123; int son1=0,son2=0; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; if(!son1)son1=v; else son2=v; &#125; if(!son2)return 0; if(siz[son1]+ad[son1]!=siz[son2]+ad[son2])return 0; return check(son1,p)&amp;&amp;check(son2,p); &#125;&#125;bool checkk(int p,int ft)&#123; if(siz[p]==1)return 1; if(p==ban)&#123; vector&lt;pii&gt;tp; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; tp.pb(pii(siz[v],v)); &#125; return tp[0].fi==1; &#125; else&#123; int son1=0,son2=0; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; if(!son1)son1=v; else son2=v; &#125; if(!son2)return 0; if(siz[son1]+ad[son1]!=siz[son2]+ad[son2])return 0; return checkk(son1,p)&amp;&amp;checkk(son2,p); &#125;&#125;void dfss(int p,int ft)&#123; siz[p]=1; int son1=0,son2=0; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; if(!son1)son1=v; else son2=v; dfss(v,p),siz[p]+=siz[v]; &#125; if(siz[son1]!=siz[son2])fail;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif m=read(),n=(1&lt;&lt;m)-2; if(n==2)return cout&lt;&lt;2&lt;&lt;'\\n'&lt;&lt;1&lt;&lt;' '&lt;&lt;2,0; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; int ct1=0,ct2=0,ct3=0; for(ri i=1;i&lt;=n;++i)&#123; if(e[i].size()&gt;4)fail; if(e[i].size()==4)++ct1; if(e[i].size()==2)++ct2; if(e[i].size()==3)++ct3; &#125; if(ct1&gt;1)fail; if(ct1==1)&#123; if(ct2!=1)fail; int ps; for(ps=1;ps&lt;=n;++ps)if(e[ps].size()==2)break; for(ri i=1;i&lt;=n;++i)if(e[i].size()==4)ban=i; dfs(ps,0); int tp=ban; while(tp!=ps)&#123; ad[tp]=1; tp=Fa[tp]; &#125; if(!check(ps,0))fail; cout&lt;&lt;1&lt;&lt;'\\n'; cout&lt;&lt;ban; return 0; &#125; if(ct2&amp;&amp;ct2!=2)fail; if(ct2==2)&#123; int a=0,b=0; for(ri i=1;i&lt;=n;++i)if(e[i].size()==2)&#123; if(!a)a=i; else b=i; &#125; dfs(a,0); ban=b; while(ban!=a)&#123; ad[ban]=1; ban=Fa[ban]; &#125; ban=b; if(checkk(a,0))return cout&lt;&lt;1&lt;&lt;'\\n'&lt;&lt;ban,0; while(ban!=a)&#123; ad[ban]=0; ban=Fa[ban]; &#125; dfs(b,0); ban=a; while(ban!=b)&#123; ad[ban]=1; ban=Fa[ban]; &#125; ban=a; if(checkk(b,0))return cout&lt;&lt;1&lt;&lt;'\\n'&lt;&lt;ban,0; fail; &#125; if(!ct3)fail; dfs(1,0); if(RT.size()!=2)fail; dfss(RT[0],RT[1]),dfss(RT[1],RT[0]); cout&lt;&lt;2&lt;&lt;'\\n'; cout&lt;&lt;min(RT[0],RT[1])&lt;&lt;' '&lt;&lt;max(RT[0],RT[1]); return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"CodeForces 1101 ç®€è¦é¢˜è§£","slug":"CF1101","date":"2019-10-12T15:31:54.000Z","updated":"2019-10-22T23:48:07.686Z","comments":true,"path":"CF1101/","link":"","permalink":"http://ldxcaicai.github.io/CF1101/","excerpt":"","text":"AæŒ‰ç…§é¢˜æ„æ¨¡æ‹Ÿ CODE 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=105;int mod,n,m,k;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri l,r,d,tt=read();tt;--tt)&#123; l=read(),r=read(),d=read(); if(l&gt;d)cout&lt;&lt;d&lt;&lt;'\\n'; else cout&lt;&lt;((r/d+1)*d)&lt;&lt;'\\n'; &#125; return 0;&#125; Bä»ä¸¤è¾¹å¼€å§‹å„æ‰«ä¸€éå³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=105;int mod,n,m,k;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;char s[500005];int len;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif scanf(\"%s\",s+1); len=strlen(s+1); int ps1=-1,ps2=-1,ps3=-1,ps4=-1; for(ri i=1;i&lt;=len;++i)&#123; if(s[i]=='['&amp;&amp;ps1==-1)&#123; ps1=i; &#125; if(s[i]==':'&amp;&amp;ps1!=-1)&#123; ps2=i; break; &#125; &#125; for(ri i=len;i;--i)&#123; if(s[i]==']'&amp;&amp;ps3==-1)&#123; ps3=i; &#125; if(s[i]==':'&amp;&amp;ps3!=-1)&#123; ps4=i; break; &#125; &#125; if(ps1==-1||ps2==-1||ps3==-1||ps4==-1||ps2&gt;=ps4)return cout&lt;&lt;-1,0; int res=4; for(ri i=ps2+1;i&lt;ps4;++i)if(s[i]=='|')++res; cout&lt;&lt;res; return 0;&#125; Cç”¨ä¸ªæ ˆæ¥æ¨¡æ‹Ÿè´ªå¿ƒå³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;int mod;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=2e5+5;int n;struct Node&#123; int l,r,id; friend inline bool operator&lt;(Node a,Node b)&#123;return a.r^b.r?a.r&lt;b.r:a.l&lt;b.l;&#125;&#125;a[N];int ans[N],vl[N&lt;&lt;1],sig;inline int find(int x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;pii stk[N];int top=0,tot=0;inline void insert(int l,int r)&#123; ++tot; int idl=tot,idr=tot; while(top)&#123; if(l&gt;a[stk[top].se].r)break; if(l&gt;=a[stk[top].fi].l)&#123; stk[top].se=tot; return; &#125; idl=stk[top].fi; --top; &#125; stk[++top]=pii(idl,idr);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(); sig=0; for(ri i=1;i&lt;=n;++i)vl[++sig]=a[i].l=read(),vl[++sig]=a[i].r=read(); sort(vl+1,vl+sig+1); sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i)a[i].l=find(a[i].l),a[i].r=find(a[i].r),a[i].id=i; sort(a+1,a+n+1); top=tot=0; for(ri i=1;i&lt;=n;++i)insert(a[i].l,a[i].r); if(top==1)&#123; cout&lt;&lt;-1; &#125; else&#123; for(ri i=1;i&lt;=top;++i)&#123; for(ri j=stk[i].fi;j&lt;=stk[i].se;++j)&#123; ans[a[j].id]=2-(i&amp;1); &#125; &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;ans[i]&lt;&lt;' '; &#125; puts(\"\"); &#125; return 0;&#125; Dä»¤è¾¹æƒç­‰äºè¿æ¥ä¸¤ä¸ªç‚¹çš„ $\\gcd(i,j)$ ï¼Œç„¶åå¯ä»¥æšä¸¾æ¯ä¸ªæ•°çš„å€æ•°ç„¶ååšæ ‘å½¢ $dp$ æ±‚ç›´å¾„ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;int mod;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=2e5+5;int n,a[N],tim[N],timm[N];vector&lt;pii&gt;E[N];vector&lt;int&gt;e[N];int dist=0,len[N];void dfs(int p,int ft,int ct)&#123; len[p]=1; timm[p]=ct; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; dfs(v,p,ct); dist=max(dist,len[p]+len[v]); len[p]=max(len[p],len[v]+1); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); if(a[i]&gt;1)&#123; dist=1; &#125; &#125; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); E[__gcd(a[u],a[v])].pb(pii(u,v)); &#125; for(ri i=2;i&lt;=200000;++i)&#123; vector&lt;int&gt;t; for(ri j=i;j&lt;=200000;j+=i)&#123; for(ri u,v,k=0;k&lt;E[j].size();++k)&#123; u=E[j][k].fi,v=E[j][k].se; if(tim[u]!=i)&#123; t.pb(u); tim[u]=i; e[u].clear(); &#125; if(tim[v]!=i)&#123; t.pb(v); tim[v]=i; e[v].clear(); &#125; e[u].pb(v),e[v].pb(u); &#125; &#125; for(ri k=0;k&lt;t.size();++k)&#123; if(timm[t[k]]!=i)dfs(t[k],0,i); &#125; t.clear(); &#125; cout&lt;&lt;dist; return 0;&#125; Eæ™®åŠ-é¢˜ï¼Œä¸ºå•¥ä¸æ”¾ $A$ å•Šï¼Ÿï¼Ÿï¼Ÿ è¯»æ‡‚é¢˜æ„å³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;int mod;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=5e5+5;int n;char op;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int mx1=0,mx2=0; for(ri i=1;i&lt;=n;++i)&#123; op=gc(); while(op!='+'&amp;&amp;op!='?')op=gc(); if(op=='+')&#123; int a=read(),b=read(); if(a&gt;b)swap(a,b); mx1=max(mx1,a); mx2=max(mx2,b); &#125; else&#123; int a=read(),b=read(); if(a&gt;b)swap(a,b); puts(a&gt;=mx1&amp;&amp;b&gt;=mx2?\"YES\":\"NO\"); &#125; &#125; return 0;&#125; Fè²Œä¼¼æœ‰åŒºé—´ $dp$ +å•è°ƒé˜Ÿåˆ—çš„åšæ³•ï¼Œä½†æˆ‘ç›´æ¥éšæœºåŒ–+å‰ªæ+äºŒåˆ†+å•è°ƒé˜Ÿåˆ—è‰¹è¿‡äº† CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch; return top;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=405,M=250005;int n,m,ps[N],s,t,C,r,f[N];inline bool check(ll V)&#123; static int q[N],hd,tl; f[s]=0; q[hd=tl=1]=s; for(ri coe,i=s+1;i&lt;=t;++i)&#123; while(hd&lt;=tl&amp;&amp;(ll)(ps[i]-ps[q[hd]])*C&gt;V)++hd; coe=hd&gt;tl?1e9:f[q[hd]]; if(i==t)return coe&lt;=r; f[i]=coe+1; while(hd&lt;=tl&amp;&amp;f[q[tl]]&gt;=f[i])--tl; q[++tl]=i; &#125;&#125;struct Node&#123;int a,b,c,d;&#125;a[M];int main()&#123; srand(time(0)); #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)ps[i]=read(); for(ri i=1;i&lt;=m;++i)a[i].a=read(),a[i].b=read(),a[i].c=read(),a[i].d=read(); random_shuffle(a+1,a+m+1); ll res=0; for(ri i=1;i&lt;=m;++i)&#123; s=a[i].a,t=a[i].b,C=a[i].c,r=a[i].d; if(check(res))continue; ll l=res+1,r=1e18,ress=1e18; while(l&lt;=r)&#123; ll mid=l+r&gt;&gt;1; if(check(mid))ress=mid,r=mid-1; else l=mid+1; &#125; res=ress; &#125; cout&lt;&lt;res; return 0;&#125; G$bzoj2460$ å¼±åŒ–ç‰ˆï¼Œç›´æ¥æ±‚å‡ºå‰ç¼€å’Œç„¶åçº¿æ€§åŸºå³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; &#125;;using namespace modular;const int N=2e5+5;int n,a[N],ok[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1,x;i&lt;=n;++i)&#123; a[i]=read()^a[i-1]; x=a[i]; for(ri j=31;~j;--j)&#123; if(x&gt;&gt;j&amp;1)&#123; if(ok[j])x^=ok[j]; else&#123; ok[j]=x; break; &#125; if(!x)break; &#125; &#125; &#125; if(!a[n])return puts(\"-1\"),0; int res=0; for(ri i=31;~i;--i)if(ok[i])++res; cout&lt;&lt;res; return 0;&#125; æ„Ÿè§‰ä»¥åè¿˜æ˜¯å¾— $vp$ $div1$ åœº å‘Šè¾","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"AtCoder Grand Contest 039 ç®€è¦é¢˜è§£","slug":"AGC039","date":"2019-10-10T03:43:21.000Z","updated":"2019-10-11T15:33:29.541Z","comments":true,"path":"AGC039/","link":"","permalink":"http://ldxcaicai.github.io/AGC039/","excerpt":"","text":"Aç®€å•åˆ†ç±»è®¨è®ºå³å¯ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef pair&lt;int,int&gt; pii;typedef long long ll;typedef unsigned long long Ull;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;char s[105];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif int len=Read(s),k=read(); if(s[1]!=s[len])&#123; int res=0; for(ri l=1,r;l&lt;=len;l=r+1)&#123; r=l; while(r!=len&amp;&amp;s[r+1]==s[r])++r; res+=(r-l+1)/2; &#125; cout&lt;&lt;(ll)res*k; return 0; &#125; bool ff=1; for(ri i=2;i&lt;=len;++i)if(s[i]!=s[i-1])&#123; ff=0; break; &#125; if(ff)&#123; cout&lt;&lt;(ll)len*k/2; return 0; &#125; int ct=2,ps1,ps2; for(ri i=2;i&lt;=len;++i)&#123; if(s[i]==s[i-1])++ct; else&#123; ps1=i; break; &#125; &#125; for(ri i=len-1;i;--i)&#123; if(s[i]==s[i+1])++ct; else&#123; ps2=i; break; &#125; &#125; int res=ct/2; for(ri l=ps1,r;l&lt;=ps2;l=r+1)&#123; r=l; while(r!=ps2&amp;&amp;s[r+1]==s[r])++r; res+=(r-l+1)/2; &#125; ll ans=(ll)res*(k-1); for(ri l=1,r;l&lt;=len;l=r+1)&#123; r=l; while(r!=len&amp;&amp;s[r+1]==s[r])++r; ans+=(r-l+1)/2; &#125; cout&lt;&lt;ans; return 0;&#125; Bå…ˆåˆ¤æ‰å¥‡ç¯ï¼Œç„¶åæšä¸¾æ¯ä¸ªç‚¹åšæ ¹æ±‚ $bfs$ æ ‘çš„ $mxdep$ æ›´æ–°æœ€å¤§å€¼å³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef pair&lt;int,int&gt; pii;typedef long long ll;typedef unsigned long long Ull;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;char s[205];int n,dep[205];bool vs[205];vector&lt;int&gt;e[205];void check(int p)&#123; vs[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if(vs[v=e[p][i]])&#123; if((dep[v]+dep[p])&amp;1)continue; puts(\"-1\"); exit(0); &#125; dep[v]=dep[p]+1;check(v); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; Read(s); for(ri j=1;j&lt;=n;++j)if(s[j]=='1')e[i].pb(j); &#125; check(1); int mx=0; for(ri s=1;s&lt;=n;++s)&#123; memset(dep,0,sizeof(dep)); memset(vs,0,sizeof(vs)); queue&lt;int&gt;q; q.push(s),dep[s]=1; while(q.size())&#123; int x=q.front(); q.pop(); vs[x]=1; for(ri i=0,v;i&lt;e[x].size();++i)&#123; if(vs[v=e[x][i]])continue; dep[v]=dep[x]+1; vs[v]=1; q.push(v); &#125; &#125; for(ri i=1;i&lt;=n;++i)mx=max(mx,dep[i]); &#125; cout&lt;&lt;mx; return 0;&#125; Cæ¨¡æ‹Ÿä¸€ä¸‹ä¼šå‘ç°æ¯æ¬¡æŠŠæœ€åä¸€ä½åˆ æ‰ï¼Œç„¶ååœ¨ç¬¬ä¸€ä½åŠ ä¸Šç›¸åçš„æ•°å­—ï¼Œæ‰“è¡¨å†è¯æ˜å¯ä»¥å‘ç°æ‰€æœ‰é $n$ çš„çº¦æ•°å®ƒä»¬çš„è´¡çŒ®ç›¸åŒéƒ½æ˜¯ $2n$ ï¼Œå¯¹äº $n$ æ»¡è¶³ $n/x$ ä¸ºå¥‡æ•°çš„çº¦æ•° $x$ å…¶è´¡çŒ®ä¸º $2x$ é‚£ä¹ˆæˆ‘ä»¬æšä¸¾ $x$ ç„¶åè·Ÿå®ƒçš„å€æ•°æˆ–è€…çº¦æ•°å®¹æ–¥å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;const int mod=998244353;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=2e5+5;char s[N],t[N];int n;int pre[N],f[N];inline int solve(int len)&#123; int res=pre[len]; for(ri i=1;i&lt;=len;++i)t[i]=s[i]; for(ri l=len+1,r=len&lt;&lt;1;l&lt;=n;l+=len,r+=len)&#123; for(ri i=l;i&lt;=r;++i)&#123; t[i]=t[i-len]^1; if(s[i]&gt;t[i])return res+1; if(s[i]&lt;t[i])return res; &#125; &#125; return res+1;&#125;int pri[N],tot=0;bool vs[N];inline void init()&#123; for(ri i=2;i&lt;=n;++i)&#123; if(!vs[i])pri[++tot]=i; for(ri j=1,up=n/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j)&#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j])break; &#125; &#125;&#125;int a[N],b[N],top;vector&lt;int&gt;divv;void dfs(int ps,int mt)&#123; divv.pb(mt); for(ri mlt=a[ps],i=ps;i&lt;=top;++i,mlt=a[i])for(ri j=1;j&lt;=b[i];++j,mlt*=a[i])dfs(i+1,mt*mlt);&#125;inline int calc(int lm)&#123; int x=lm; top=0; for(ri i=1,up=sqrt(lm);i&lt;=tot&amp;&amp;pri[i]&lt;=up&amp;&amp;lm!=1;++i)&#123; if(lm!=lm/pri[i]*pri[i])continue; ++top,a[top]=pri[i],b[top]=0; while(lm==lm/pri[i]*pri[i])lm/=pri[i],++b[top]; &#125; if(lm^1)a[++top]=lm,b[top]=1; divv.clear(); dfs(1,1); int res=0; for(ri i=divv.size()-1;~i;--i)if(divv[i]!=1)if((n/(x/divv[i]))&amp;1)Add(res,f[x/divv[i]]); return res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),Read(s); init(); int res=0; for(ri i=1;i&lt;=n;++i)pre[i]=add(add(pre[i-1],pre[i-1]),s[i]-'0'); res=add(pre[n],1); Mul(res,n*2); for(ri tp,i=1;i*3&lt;=n;++i)&#123; if(n%i)continue; if(!((n/i)&amp;1))continue; f[i]=dec(solve(i),calc(i)); Dec(res,mul(2*(n-i),f[i])); &#125; cout&lt;&lt;res; return 0;&#125; Dä¸ºå•¥æ˜¯MOé¢˜å•Š2333 å¯¹äºä¸€ä¸ª $\\Delta ABC$ ï¼Œä»¤ $Aâ€™$ ä¸º $BC$ ä¸åŒ…å« $A$ çš„å¼§çš„ä¸­ç‚¹ï¼Œ $Bâ€™Câ€™$ åŒç†ï¼Œè¿™æ · $\\Delta Aâ€™Bâ€™Câ€™$ çš„é‡å¿ƒå³ä¸º $\\Delta ABC$ çš„å†…å¿ƒï¼Œç„¶ååˆ©ç”¨æ¬§æ‹‰çº¿çš„æ€§è´¨åˆ†ç±»è®¨è®ºè®¡ç®—è´¡çŒ®å³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;const int mod=998244353;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=3005;int t[N],n,L;const double pi=acos(-1.0);int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),L=read(); for(ri i=1;i&lt;=n;++i)t[i]=read(); double resx=0,resy=0,Ang=pi/L; for(ri i=1;i&lt;n;++i)for(ri j=i+1;j&lt;=n;++j)&#123; resx+=cos(Ang*(t[i]+t[j]))*(n-(j-i+1)); resy+=sin(Ang*(t[i]+t[j]))*(n-(j-i+1)); resx+=cos(Ang*(t[i]+t[j])+pi)*(j-i-1); resy+=sin(Ang*(t[i]+t[j])+pi)*(j-i-1); &#125; printf(\"%.10lf %.10lf\",resx*6.0/n/(n-1)/(n-2),resy*6.0/n/(n-1)/(n-2)); return 0;&#125; E$f_{l,r,p}$ è¡¨ç¤ºå¯¹äºåŒºé—´ $[l,r]$ ï¼Œç‚¹ $p$ è¿å‘äº† $[l,r]$ å¤–çš„åŒºé—´çš„æ–¹æ¡ˆæ•°ï¼Œç„¶å $O(n^4)$ æšä¸¾æ–°çš„å°åŒºé—´å³å¯,æ—¶é—´å¤æ‚åº¦ $O(n^7)$ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;details&gt;&lt;summary&gt;CODE&lt;/summary&gt;#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef long long ll;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(bool*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch^48,ch=gc(); return top;&#125;const int N=45;int n;ll f[N][N][N],res=0;bool trans[N][N];ll dfs(int l,int r,int p)&#123; if(~f[l][r][p])return f[l][r][p]; if(l==r)return f[l][r][p]=1; if(l==p||r==p)return f[l][r][p]=0; ll res=0ll; for(ri _l=l;_l&lt;p;++_l)for(ri _r=r;_r&gt;p;--_r)if(trans[_l][_r]) for(ri a=_l;a&lt;p;++a)for(ri b=_r;b&gt;p;--b)res+=dfs(l,a,_l)*dfs(a+1,b-1,p)*dfs(b,r,_r); return f[l][r][p]=res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); memset(f,-1,sizeof(f)); for(ri i=1;i&lt;=n*2;++i)Read(trans[i]); if(n==1)return cout&lt;&lt;trans[1][2],0; for(ri i=3;i&lt;n*2;++i)(trans[1][i])&amp;&amp;(res+=dfs(2,n*2,i)); cout&lt;&lt;res; return 0;&#125; Fè€ƒè™‘è½¬åŒ–é—®é¢˜æˆä¸ºå¦‚ä¸‹æ–°æ¨¡å‹ï¼š è¦æ±‚å¡«ä¸Šä¸¤ä¸ªçŸ©é˜µ $A,B$ ï¼Œæ»¡è¶³ $A$ çš„è¡Œæœ€å¤§å€¼ä¸è¶…è¿‡ $B$ çš„è¡Œæœ€å°å€¼ï¼Œ $A$ çš„åˆ—æœ€å¤§å€¼ä¸è¶…è¿‡ $B$ çš„åˆ—æœ€å°å€¼ï¼Œæ±‚æ–¹æ¡ˆæ•° é‚£ä¹ˆå°±å¯ä»¥è®¾è®¡å‡ºæšä¸¾ä¸¤ç»´è½¬ç§»çš„ $dp$ ï¼Œå‘ç°å¥½åƒè¿˜èƒ½ç”¨ $fft$ ä¼˜åŒ–åˆ° $O(n^4\\log n)$ ä½†ä»ç„¶ä¸å¤Ÿï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ª $O(n^4)$ åšæ³•ï¼Œå› ä¸ºæœ‰æƒå€¼çš„é™åˆ¶çŠ¶æ€åº”è¯¥æ˜¯ $O(n^3)$ çš„ï¼Œå› æ­¤éœ€è¦å®šä¹‰å¯ä»¥å°†æ¨ªçºµåæ ‡åˆ†å¼€æˆ–è€…åˆ†æ­¥è½¬ç§»çš„çŠ¶æ€ äºæ˜¯ä»¤ $x_i$ ä¸º $A$ ç¬¬ $i$ è¡Œæœ€å¤§å€¼ï¼Œ $y_i$ ä¸º $B$ ç¬¬ $i$ åˆ—æœ€å°å€¼ è®¾ $f_{i,j,k}$ è¡¨ç¤ºå·²ç»æšä¸¾äº† $i$ è¡Œ $j$ åˆ—ï¼Œå·²ç»å¡«ä¸Šäº† $A$ æ•°ç»„è¿™ $i$ è¡Œ $j$ åˆ—å¹¶é›†çš„ä½ç½®ï¼Œå·²æ¥è¿‘å¡«ä¸Šäº† $B$ æ•°ç»„è¿™ $i$ è¡Œ $j$ åˆ—äº¤é›†çš„ä½ç½®ï¼Œä¸”æ»¡è¶³å·²ç»å¡«å¥½çš„ $x_i,y_i\\le k$ çš„å¯è¡ŒçŠ¶æ€çš„æ–¹æ¡ˆæ•° ç„¶åå°±å¯ä»¥åˆ†æ­¥æšä¸¾è¡Œåˆ—çš„å¢é‡è½¬ç§»åˆ° $f_{i+a,j+b,k+1}$ äº† CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=105;int n,m,L,f[N][N][N][2],C[N][N],pw[4][N];inline void init()&#123; for(ri i=0,up=max(n,m);i&lt;=up;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j-1],C[i-1][j]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),L=read(),mod=read(); init(); f[0][0][0][0]=1; for(ri i=0;i&lt;4;++i)pw[i][0]=1; for(ri vl=0;vl&lt;L;++vl)&#123; for(ri i=1,up=max(n,m);i&lt;=up;++i)&#123; pw[0][i]=pw[1][i]; pw[1][i]=mul(pw[1][i-1],vl+1); pw[2][i]=mul(pw[2][i-1],L-vl); pw[3][i]=mul(pw[3][i-1],L-vl-1); &#125; for(ri mt,mlt,a=0;a&lt;=n;++a)for(ri b=0;b&lt;=m;++b)if(f[vl][a][b][0])&#123; mt=1,mlt=mul(pw[2][b],dec(pw[1][m-b],pw[0][m-b])); for(ri t=0;a+t&lt;=n;++t,Mul(mt,mlt)) Add(f[vl][a+t][b][1],mul(f[vl][a][b][0],mul(mt,C[n-a][t]))); &#125; for(ri mt,mlt,a=0;a&lt;=n;++a)for(ri b=0;b&lt;=m;++b)if(f[vl][a][b][1])&#123; mt=1,mlt=mul(pw[1][n-a],dec(pw[2][a],pw[3][a])); for(ri t=0;b+t&lt;=m;++t,Mul(mt,mlt)) Add(f[vl+1][a][b+t][0],mul(f[vl][a][b][1],mul(mt,C[m-b][t]))); &#125; &#125; cout&lt;&lt;f[L][n][m][0]; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"2019.10.09 æ¨¡æ‹Ÿæµ‹è¯•é¢˜è§£","slug":"191009test","date":"2019-10-10T03:27:23.000Z","updated":"2019-10-11T15:33:33.345Z","comments":true,"path":"191009test/","link":"","permalink":"http://ldxcaicai.github.io/191009test/","excerpt":"","text":"Aé¢˜æ„ç®€è¿°ï¼š ç»™ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„ï¼Œæ¯ä¸ªæ•°éƒ½ä¸º $0,1,\\cdots,9$ ä¸­çš„ä¸€ä¸ªï¼Œç»™å‡º $Q$ ä¸ªé™åˆ¶ $(l,r,v)$ è¡¨ç¤ºåŒºé—´ $[l,r]$ çš„ä¹˜ç§¯æ¨¡ $10$ çš„ä½™æ•°ä¸º $v$ ï¼Œé—®åˆæ³•æ•°ç»„æ•° æ•°æ®èŒƒå›´ï¼š $n\\le100$ $q\\le50$ è§£é¢˜æ€è·¯ï¼š è€ƒè™‘è½¬åŒ–ä¸ºè®¡ç®—æ¨¡ $2$ å’Œæ¨¡ $5$ çš„æ–¹æ¡ˆæ•°å†ä¹˜èµ·æ¥ ç„¶åå‘ç°é™¤äº† $0$ éƒ½æœ‰é€†å…ƒï¼Œå®¹æ˜“æƒ³åˆ°æŠŠå¼ºåˆ¶ä¸ä¸º $0$ çš„ä½ç½®å’Œå¯èƒ½ä¸º $0$ çš„ä½ç½®åˆ†å¼€è€ƒè™‘ï¼Œå‰è€…åœ¨ç»™åŒºé—´è¿›è¡Œç®€å•æ“ä½œåå¯ä»¥ç›´æ¥ç®—ï¼Œåè€…å¯ä»¥ç”¨ç®€å• $dp$ ç®— CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=105,Q=55;struct F&#123; int l,r,v; F(int l=0,int r=0,int v=0):l(l),r(r),v(v)&#123;&#125; friend inline bool operator&lt;(F a,F b)&#123;return a.l^b.l?a.l&lt;b.l:a.r&lt;b.r;&#125;&#125;a[N],ori[N],vl[N];int n,q,ps[N],top,coe,sig,tot,Inv[5]=&#123;0,1,3,2,4&#125;,f[N],pw[N];pii L[N],R[N];bool ban[N];inline bool insert(F x)&#123; while(1)&#123; if(!L[x.l].fi&amp;&amp;!R[x.r].fi)break; if(L[x.l].fi==x.r)return x.v==L[x.l].se; if(L[x.l].fi)&#123; if(L[x.l].fi&gt;x.r)&#123; swap(x.v,L[x.l].se); R[L[x.l].fi]=pii(0,0); swap(x.r,L[x.l].fi); R[L[x.l].fi]=pii(x.l,L[x.l].se); &#125; (x.v*=Inv[L[x.l].se])%=coe; x.l=L[x.l].fi+1; &#125; else&#123; if(R[x.r].fi&lt;x.l)&#123; swap(x.v,R[x.r].se); L[R[x.r].fi]=pii(0,0); swap(x.l,R[x.r].fi); L[R[x.r].fi]=pii(x.r,R[x.r].se); &#125; (x.v*=Inv[R[x.r].se])%=coe; x.r=R[x.r].fi-1; &#125; &#125; ++sig; L[x.l]=pii(x.r,x.v); R[x.r]=pii(x.l,x.v); return 1;&#125;inline int solve1()&#123; if(coe==2)return 1; sig=0; for(ri i=1;i&lt;=top;++i)L[i]=R[i]=pii(0,0); for(ri i=1;i&lt;=tot;++i)if(!insert(vl[i]))return 0; return ksm(coe-1,top-sig);&#125;inline bool check(int len,int ps)&#123; for(ri i=tot;i&amp;&amp;vl[i].l&gt;ps;--i)if(vl[i].r&lt;=len)return 0; return 1;&#125;inline int solve2()&#123; sort(vl+1,vl+tot+1); pw[0]=1; f[0]=1; for(ri len=1;len&lt;=top;++len)&#123; pw[len]=mul(pw[len-1],coe-1); f[len]=0; for(ri ps=0;ps&lt;=len;++ps)check(len,ps)&amp;&amp;(Add(f[len],mul(pw[len-ps],ps?f[ps-1]:1)),1); &#125; return f[top];&#125;inline void fix1()&#123; tot=0; for(ri i=1;i&lt;=q;++i)if(a[i].v)&#123; ++tot; vl[tot].l=lower_bound(ps+1,ps+top+1,a[i].l)-ps; vl[tot].r=lower_bound(ps+1,ps+top+1,a[i].r)-ps; vl[tot].v=a[i].v; &#125;&#125;inline void fix2()&#123; tot=0; for(ri t,i=1;i&lt;=q;++i)if(!a[i].v)&#123; ++tot; for(t=1;t&lt;=top&amp;&amp;ps[t]&lt;a[i].l;++t); vl[tot].l=t; for(t=top;t&amp;&amp;ps[t]&gt;a[i].r;--t); vl[tot].r=t; vl[tot].v=a[i].v; &#125;&#125;inline int solve()&#123; for(ri i=1;i&lt;=n;++i)ban[i]=0; for(ri i=1;i&lt;=q;++i)if(a[i].v) for(ri j=a[i].l;j&lt;=a[i].r;++j)ban[j]=1; for(ri i=1;i&lt;=q;++i)if(!a[i].v)&#123; bool ff=0; for(ri j=a[i].l;j&lt;=a[i].r;++j)if(!ban[j])&#123;ff=1;break;&#125; if(!ff)return 0; &#125; top=0; for(ri i=1;i&lt;=n;++i)if(ban[i])ps[++top]=i; fix1(); int res=solve1(); top=0; for(ri i=1;i&lt;=n;++i)if(!ban[i])ps[++top]=i; fix2(); return mul(res,solve2());&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),q=read(); for(ri l,r,v,i=1;i&lt;=q;++i)&#123; l=read()+1,r=read()+1,v=read(); ori[i]=F(l,r,v); &#125; for(ri i=1;i&lt;=q;++i)a[i]=ori[i],a[i].v%=2; coe=2; int res=solve(); for(ri i=1;i&lt;=q;++i)a[i]=ori[i],a[i].v%=5; coe=5; cout&lt;&lt;mul(res,solve()); return 0;&#125; Bé¢˜æ„ç®€è¿°ï¼š å¯¹äºä¸€å¼  $n$ ä¸ªç‚¹çš„æ— å‘å®Œå…¨å›¾ï¼Œæ¯æ¡è¾¹æœ‰ $P$ çš„æ¦‚ç‡å‡ºç°ï¼Œé—®ç­‰æ¦‚ç‡éšæœºä¸€ä¸ªç‚¹ï¼Œä» $1$ å·ç‚¹åˆ°å…¶çš„æœ€çŸ­è·¯é•¿åº¦ï¼ˆä¸è¿é€šç­”æ¡ˆä¸º $10^9$ )çš„æœŸæœ› æ•°æ®èŒƒå›´: $n\\le400$ è§£é¢˜æ€è·¯ï¼š è€ƒè™‘å®šä¹‰çŠ¶æ€ $P_{i,j}$ è¡¨ç¤ºè€ƒè™‘äº† $i$ ä¸ªç‚¹çš„åˆ†å±‚å›¾ï¼Œæœ€åä¸€å±‚æœ‰ $j$ ä¸ªç‚¹ï¼Œåˆ°è¾¾è¿™ä¸ªçŠ¶æ€çš„æ¦‚ç‡ï¼Œ $E_{i,j}$ åŒç†ä¸è¿‡æ¢æˆäº†æœŸæœ›ï¼Œè¿™æ ·å°±èƒ½è¾¹ $dp$ è¾¹ç»Ÿè®¡ç­”æ¡ˆï¼Œè½¬ç§»å¯ä»¥è€ƒè™‘æ–°åŠ è¿›æ¥çš„ä¸€å±‚å’Œå½“å‰æœ€åä¸€å±‚çš„è¿è¾¹æƒ…å†µï¼Œå¤æ‚åº¦ $O(n^3)$ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef long long ll;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; &#125;using namespace modular;const int N=405;int n,E[N][N],P[N][N],fac[N],ifac[N],pw2[N*N],coe[N][N],_P;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1,pw2[0]=1; pw2[1]=dec(1,_P); for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=n*n;++i)pw2[i]=mul(pw2[i-1],pw2[1]); for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]); for(ri i=1;i&lt;=n;++i)&#123; coe[i][0]=1; coe[i][1]=dec(1,pw2[i]); for(ri j=2;j&lt;=n;++j)coe[i][j]=mul(coe[i][j-1],coe[i][1]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),_P=mul(ksm(1000000,mod-2),read()); init(); int res=0; P[1][1]=1; for(ri i=1;i&lt;n;++i)for(ri j=1;j&lt;=i;++j)&#123; if(i&gt;1&amp;&amp;i==j)continue; Add(res,mul(add(E[i][j],P[i][j]),coe[j][1])); Add(res,mul(1000000000%mod,mul(pw2[j*(n-i)],P[i][j]))); for(ri k=1;k+i&lt;n;++k)&#123; Add(P[i+k][k],mul(mul(P[i][j],coe[j][k]),mul(C(n-i-1,k),pw2[j*(n-i-k)]))); Add(E[i+k][k],mul(mul(add(P[i][j],E[i][j]),coe[j][k]),mul(C(n-i-1,k),pw2[j*(n-i-k)]))); &#125; &#125; cout&lt;&lt;mul(res,mul(n-1,ksm(1000000,n*n))); return 0;&#125; Cé¢˜æ„ç®€è¿°ï¼š æ±‚æœ‰å¤šå°‘æœ¬è´¨ä¸åŒçš„ä¸è¶…è¿‡ $n$ ä¸ªç‚¹çš„ã€æ— é‡è¾¹ã€å¯ä»¥æœ‰è‡ªç¯ã€å­˜åœ¨è‡³å°‘ä¸€æ¡æ¬§æ‹‰å›è·¯çš„å¸¦æ ‡å·è¿é€šæ— å‘å›¾ æ•°æ®èŒƒå›´ï¼š $n\\le45$ è§£é¢˜æ€è·¯ï¼š é¦–å…ˆç”¨æœ€å°è¡¨ç¤ºæ³• + $burnside$ æ±‚å‡ºä¸è¦æ±‚è¿ä½“æ¡¶çš„ç­”æ¡ˆï¼Œè¿™ä¸ªæ–¹æ³•å‚è§æ´›è°·ä¸€é“å«åšç”»ç”»çš„é¢˜ç›®ï¼Œç„¶åå°±å¯ä»¥ç”¨è¡¥é›†è½¬åŒ–çš„æ€æƒ³æšä¸¾ä¸è¿é€šçš„æƒ…å†µæ±‚å‡ºç­”æ¡ˆ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=55;int n,fac[N],ifac[N],inv[N],pw[N*N*2];inline void init()&#123; inv[1]=fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125; pw[0]=1; for(ri i=1;i&lt;=n*n*2;++i)pw[i]=add(pw[i-1],pw[i-1]);&#125;int res,a[N],cnt[N],vl[N],top=0,ft[N],up;inline int find(int x)&#123;return x^ft[x]?ft[x]=find(ft[x]):x;&#125;inline int gcd(int a,int b)&#123;int t;while(b)t=a,a=b,b=t-t/a*a;return a;&#125;inline void update()&#123; int coe=1,ss=0; for(ri i=1;i&lt;=up;++i)Mul(coe,ifac[cnt[i]]),ft[i]=i; for(ri i=1;i&lt;=top;++i)&#123; ss+=(a[i]-1)/2; vl[i]=!(a[i]&amp;1); Mul(coe,inv[a[i]]); &#125; for(ri x,y,fx,fy,g,i=1;i&lt;top;++i)for(ri j=i+1;j&lt;=top;++j)&#123; g=gcd(a[i],a[j]); x=(a[j]/g)&amp;1,y=(a[i]/g)&amp;1; if(x^y)(x?vl[i]:vl[j])+=g; else&#123; ss+=g; if(x&amp;y)&#123; fx=find(i); fy=find(j); if(fx^fy)ft[fx]=fy; &#125; &#125; &#125; for(ri i=1;i&lt;=top;++i)if(find(i)!=i)vl[find(i)]+=vl[i]; for(ri i=1;i&lt;=top;++i)if(find(i)==i)ss+=max(vl[i],1); Add(res,mul(coe,pw[ss]));&#125;inline void dfs(int sz,int all)&#123; if(!all)return update(); if(sz&gt;all)return; for(ri i=sz;i&lt;=all;++i)&#123; ++cnt[i]; a[++top]=i; dfs(i,all-i); --cnt[i]; --top; &#125;&#125;inline int C(int n,int m)&#123; if(n&lt;m)return 0; int ret=ifac[m]; for(ri i=0;i&lt;m;++i)Mul(ret,n-i); return ret;&#125;int f[N],g[N],h[N];inline void IEP()&#123; res=0; g[0]=1; for(ri i=1;i&lt;=n;++i)&#123; h[i]=dec(f[i],g[i]); for(ri j=n;j;--j)for(ri k=1;i*k&lt;=j;++k)Add(g[j],mul(g[j-i*k],C(add(h[i],k-1),k))); &#125; for(ri i=1;i&lt;=n;++i)Add(res,h[i]); cout&lt;&lt;dec(res,1);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),mod=read(); init(); for(up=1;up&lt;=n;++up)&#123; res=0; dfs(1,up); f[up]=res; &#125; IEP(); return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"è€ƒè¯•é¢˜è§£","slug":"è€ƒè¯•é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/è€ƒè¯•é¢˜è§£/"}]},{"title":"2019.10.07 æ¨¡æ‹Ÿæµ‹è¯•é¢˜è§£","slug":"191007test","date":"2019-10-10T03:08:47.000Z","updated":"2019-10-11T15:33:34.569Z","comments":true,"path":"191007test/","link":"","permalink":"http://ldxcaicai.github.io/191007test/","excerpt":"","text":"é¢˜ç›®æ¥æºï¼š $A:CF793G$ $B:CF335E$ $C:CF809E$Aé¢˜æ„ç®€è¿°ï¼š ç»™ä½ ä¸€ä¸ª $n\\times n$ çš„ç½‘æ ¼å›¾å’Œ $q$ ä¸ªä¸ç›¸äº¤çš„çŸ©å½¢ï¼Œé—®é™¤å¼€è¿™ $q$ ä¸ªçŸ©å½¢å‰©ä¸‹çš„æ ¼å­ä¸­æœ€å¤šèƒ½æ”¾å¤šå°‘ä¸ªäº’ä¸å½±å“çš„è»Š æ•°æ®èŒƒå›´ï¼š $n\\le10000$ $q\\le10000$ è§£é¢˜æ€è·¯ï¼š æš´åŠ›æ˜¯å¾ˆæ˜¾ç„¶çš„æŒ‰ç…§è¡Œåˆ—å»ºäºŒåˆ†å›¾ç„¶åæœ€å¤§åŒ¹é…ï¼Œæ­£è§£å¯ä»¥è€ƒè™‘ç”¨æ•°æ®ç»“æ„ä¼˜åŒ–å»ºå›¾ï¼Œç®€å•æ€è€ƒåå®¹æ˜“æƒ³åˆ°æ‰«æçº¿+ä¸»å¸­æ ‘ï¼ŒWOJä¸Šè¢«å¡å¸¸äº†ä»€ä¹ˆè¾£é¸¡è¯„æµ‹å§¬ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef long long ll;const int N=10005,M=6e6+5,inf=0x3f3f3f3f;int n,m;struct edge&#123;int v,next,c;&#125;;namespace dinic&#123; int s,t,first[M],cnt,d[M],cur[M]; edge e[M]; inline void addedge(int u,int v,int c)&#123;e[++cnt]=(edge)&#123;v,first[u],c&#125;,first[u]=cnt;&#125; inline void add(int u,int v,int c)&#123;if(!c)return;addedge(u,v,c),addedge(v,u,0);&#125; inline bool bfs()&#123; static int que[M],hd,tl; for(ri i=s;i&lt;=t;++i)d[i]=-1; d[s]=0,que[hd=tl=1]=s; while(hd&lt;=tl)&#123; int x=que[hd++]; for(ri i=first[x],v;~i;i=e[i].next)&#123; v=e[i].v; if(~d[v]||e[i].c&lt;=0)continue; d[v]=d[x]+1; if(v==t)return 1; que[++tl]=v; &#125; &#125; return 0; &#125; inline int dfs(int p,int f)&#123; if(!f||p==t)return f; int flow=f; for(ri i=first[p],v,tp;~i;i=e[i].next)&#123; if(!flow)return f; v=e[i].v; if(d[v]&gt;d[p]&amp;&amp;e[i].c&gt;0)&#123; tp=dfs(v,min(flow,e[i].c)); (!tp)&amp;&amp;(d[v]=-1); e[i].c-=tp,e[i^1].c+=tp,flow-=tp; &#125; &#125; return f-flow; &#125; inline int solve()&#123; int res=0,tp=0; while(bfs())while((tp=dfs(s,inf)))res+=tp; return res; &#125;&#125;namespace subtask1&#123; int det[105][105]; inline void Main()&#123; dinic::cnt=-1; dinic::s=0,dinic::t=2*n+1; for(ri i=0;i&lt;=n*2+1;++i)dinic::first[i]=-1; for(ri i=1;i&lt;=n;++i)dinic::add(0,i,1),dinic::add(i+n,n*2+1,1); for(ri x1,x2,y1,y2,i=1;i&lt;=m;++i)&#123; x1=read(),y1=read(),x2=read(),y2=read(); ++det[x1][y1],--det[x1][y2+1],--det[x2+1][y1],++det[x2+1][y2+1]; &#125; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)&#123; det[i][j]+=det[i-1][j]+det[i][j-1]-det[i-1][j-1]; if(!det[i][j])dinic::add(i,j+n,1); &#125; cout&lt;&lt;dinic::solve(); exit(0); &#125;&#125;int all=0,idx[M],rt[N],tot=0,son[M][2],siz[M];#define lc (son[p][0])#define rc (son[p][1])#define mid (l+r&gt;&gt;1)inline void build(int&amp;p,int l,int r)&#123; p=++tot,siz[p]=r-l+1; idx[p]=++all,dinic::first[all]=-1; if(l==r)&#123; dinic::add(idx[p],l+n,1); return; &#125; build(lc,l,mid),build(rc,mid+1,r); dinic::add(idx[p],idx[lc],siz[lc]); dinic::add(idx[p],idx[rc],siz[rc]);&#125;inline void update(int&amp;p,int o,int O,int l,int r,int ql,int qr,int v)&#123; p=++tot; siz[p]=siz[o]+v*(min(qr,r)-max(ql,l)+1),lc=son[o][0],rc=son[o][1]; idx[p]=++all,dinic::first[all]=-1; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; if(l==r)dinic::add(idx[p],l+n,1); else&#123; dinic::add(idx[p],idx[son[O][0]],siz[son[O][0]]); dinic::add(idx[p],idx[son[O][1]],siz[son[O][1]]); &#125; return; &#125; if(qr&lt;=mid)update(lc,lc,son[O][0],l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,rc,son[O][1],mid+1,r,ql,qr,v); else update(lc,lc,son[O][0],l,mid,ql,qr,v),update(rc,rc,son[O][1],mid+1,r,ql,qr,v); dinic::add(idx[p],idx[lc],siz[lc]); dinic::add(idx[p],idx[rc],siz[rc]);&#125;#undef lc#undef rc#undef midstruct F&#123;int l,r,typ;friend inline bool operator&lt;(F a,F b)&#123;return a.typ&lt;b.typ;&#125;;&#125;;vector&lt;F&gt;upd[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri x1,y1,x2,y2,i=1;i&lt;=m;++i)&#123; x1=read(),y1=read(),x2=read(),y2=read(); upd[x1].pb((F)&#123;y1,y2,-1&#125;),upd[x2+1].pb((F)&#123;y1,y2,1&#125;); &#125; all=n*2; dinic::s=0; dinic::cnt=-1; for(ri i=0;i&lt;=all;++i)dinic::first[i]=-1; for(ri i=1;i&lt;=n;++i)dinic::add(0,i,1); build(rt[0],1,n); for(ri i=1;i&lt;=n;++i)&#123; rt[i]=rt[i-1]; sort(upd[i].begin(),upd[i].end()); for(ri j=upd[i].size()-1;~j;--j) update(rt[i],rt[i],rt[0],1,n,upd[i][j].l,upd[i][j].r,upd[i][j].typ); dinic::add(i,idx[rt[i]],siz[rt[i]]); &#125; dinic::t=++all,dinic::first[all]=-1; for(ri i=1;i&lt;=n;++i)dinic::add(i+n,all,1); cout&lt;&lt;dinic::solve(); return 0;&#125; Bè§£é¢˜æ€è·¯ï¼š é¦–å…ˆè€ƒè™‘ç»™ä½ ä¸€ä¸ª $Bob$ çš„æƒ…å†µï¼Œæ ¹æ®æ ·ä¾‹ä¸éš¾çŒœå‡ºç­”æ¡ˆä¸º $n$ ç„¶åè€ƒè™‘ç»™ä½ ä¸€ä¸ª $Alice$ çš„æƒ…å†µï¼Œå‘ç°å¯ä»¥æšä¸¾é«˜åº¦ä»¤å…¶ä¸€ç‚¹ç‚¹å¢åŠ ç„¶åç®—æ–°æ»‘ç´¢å‡åŸæ¥æ»‘ç´¢çš„æœŸæœ›å¢é‡ CODE 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;char s[10];int n,H,pw[35];double ipw[35];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif scanf(\"%s%d%d\",s,&amp;n,&amp;H); if(s[0]=='B')&#123; cout&lt;&lt;n; return 0; &#125; pw[0]=ipw[0]=1; for(ri i=1;i&lt;=H;++i)pw[i]=pw[i-1]*2,ipw[i]=1.0/pw[i]; double res=0,mt; for(ri h=1;h&lt;=H;++h)&#123; mt=ipw[h]*ipw[h]; for(ri len=1;len&lt;n;++len)&#123; res+=(n-len)*mt*(pw[h]-pw[h-1]*(1.0+(double)(len-1)/(double)(pw[h]-1))); mt*=1-ipw[h]; &#125; &#125; printf(\"%.10lf\",res+n); return 0;&#125; Cé¢˜æ„ç®€è¿°ï¼š ç»™å‡ºä¸€æ£µæ ‘å’Œæ¯ä¸ªç‚¹ç‚¹æƒ $a_i$ æ±‚ $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\phi(a_ia_j)dist(i,j)$æ•°æ®èŒƒå›´ï¼š $n\\le200000$ ä¿è¯ $\\{a\\}$ æ˜¯ä¸€ä¸ªæ’åˆ—è§£é¢˜æ€è·¯ï¼šè€ƒè™‘åˆ°æœ‰ç­‰å¼ $\\phi(ij)=\\phi(i)\\phi(j)\\frac{\\gcd(i,j)}{\\phi(\\gcd(i,j))}$ äºæ˜¯å®¹æ˜“æƒ³åˆ°å¯ä»¥è«æ¯”ä¹Œæ–¯åæ¼”+è°ƒå’Œçº§æ•°æšä¸¾ç‚¹+è™šæ ‘ç»Ÿè®¡ç­”æ¡ˆ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int mod=1e9+7;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline void Mul(int&amp;a,int b)&#123;a=mul(a,b);&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=2e5+5;vector&lt;int&gt;e[N],E[N];int n,a[N],b[N],mu[N],phi[N],pri[N],inv[N],tot=0,F[N];bool vs[N];inline void init()&#123; phi[1]=inv[1]=mu[1]=1; for(ri i=2;i&lt;=n;++i)&#123; inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); if(!vs[i])pri[++tot]=i,phi[i]=i-1,mu[i]=mod-1; for(ri j=1,up=n/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j)&#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j])&#123; mu[i*pri[j]]=0; phi[i*pri[j]]=phi[i]*pri[j]; break; &#125; phi[i*pri[j]]=phi[i]*(pri[j]-1); mu[i*pri[j]]=mu[i]?mod-mu[i]:0; &#125; &#125; for(ri i=1;i&lt;=n;++i)for(ri j=i,t=1;j&lt;=n;j+=i,++t)Add(F[j],mul(i,mul(inv[phi[i]],mu[t])));&#125;int siz[N],top[N],dep[N],fa[N],hson[N],dfntot=0,dfn[N];void dfs1(int p)&#123; siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==fa[p])continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; (siz[v]&gt;siz[hson[p]])&amp;&amp;(hson[p]=v); &#125;&#125;void dfs2(int p,int tp)&#123; dfn[p]=++dfntot,top[p]=tp; if(!hson[p])return; dfs2(hson[p],tp); for(ri i=0,v;i&lt;e[p].size();++i)((v=e[p][i])!=hson[p]&amp;&amp;v!=fa[p])&amp;&amp;(dfs2(v,v),1);&#125;inline int lca(int x,int y)&#123; while(top[x]^top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;bool key[N];int tp=0,stk[N];inline void insert(int x)&#123; if(tp&lt;2)&#123;stk[++tp]=x;return;&#125; int t=lca(x,stk[tp]); if(t==stk[tp])&#123;stk[++tp]=x;return;&#125; while(dfn[stk[tp]]&gt;dfn[t])&#123; if(dfn[t]&gt;=dfn[stk[tp-1]])&#123; E[t].pb(stk[tp]),--tp; if(t^stk[tp])stk[++tp]=t; stk[++tp]=x; return; &#125; E[stk[tp-1]].pb(stk[tp]),--tp; &#125;&#125;int res=0,ss,ss1[N],ss2[N];void dfs(int p)&#123; ss1[p]=ss2[p]=0; for(ri i=0,v;i&lt;E[p].size();++i)&#123; v=E[p][i]; dfs(v); Add(ss2[p],ss2[v]); Add(ss1[p],ss1[v]); &#125; if(key[p])&#123; Add(ss,dec(mul(ss2[p],phi[a[p]]),mul(ss1[p],mul(phi[a[p]],dep[p])))); Add(ss2[p],mul(phi[a[p]],dep[p])); Add(ss1[p],phi[a[p]]); &#125; for(ri i=0,v;i&lt;E[p].size();++i)&#123; v=E[p][i]; Dec(ss2[p],ss2[v]); Dec(ss1[p],ss1[v]); Add(ss,mul(ss1[v],ss2[p])); Add(ss,mul(ss1[p],ss2[v])); Dec(ss,mul(mul(2,dep[p]),mul(ss1[v],ss1[p]))); Add(ss2[p],ss2[v]); Add(ss1[p],ss1[v]); &#125;&#125;void clear(int p)&#123; key[p]=0; for(ri i=0;i&lt;E[p].size();++i)clear(E[p][i]); E[p].clear();&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init(); for(ri i=1;i&lt;=n;++i)b[a[i]=read()]=i; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; dfs1(1),dfs2(1,1); vector&lt;pii&gt;t; for(ri d=1;d&lt;=n;++d)&#123; t.clear(); for(ri p=d;p&lt;=n;p+=d)t.pb(pii(dfn[b[p]],b[p])),key[b[p]]=1; sort(t.begin(),t.end()); tp=0; if(!key[1])insert(1); for(ri i=0;i&lt;t.size();++i)insert(t[i].se); while(tp&gt;1)E[stk[tp-1]].pb(stk[tp]),--tp; ss=0; dfs(1),clear(1); Add(res,mul(ss,F[d])); &#125; cout&lt;&lt;mul(res,mul(inv[n],inv[n-1])); return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"è€ƒè¯•é¢˜è§£","slug":"è€ƒè¯•é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/è€ƒè¯•é¢˜è§£/"}]},{"title":"CodeForces 1220 ç®€è¦é¢˜è§£","slug":"CF1220","date":"2019-10-04T08:43:54.000Z","updated":"2019-10-22T23:48:20.283Z","comments":true,"path":"CF1220/","link":"","permalink":"http://ldxcaicai.github.io/CF1220/","excerpt":"","text":"Aæ˜¾ç„¶å°½é‡å¤šé€‰ $1$ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;int n,c[5];char s[100005];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); Read(s); for(ri i=1;i&lt;=n;++i)&#123; if(s[i]=='z')++c[0]; if(s[i]=='e')++c[1]; if(s[i]=='r')++c[2]; if(s[i]=='o')++c[3]; if(s[i]=='n')++c[4]; &#125; for(ri i=1,up=min(c[4],min(c[3],c[1]));i&lt;=up;++i)--c[4],--c[3],--c[1],cout&lt;&lt;1&lt;&lt;' '; for(ri i=1,up=min(min(c[0],c[1]),min(c[2],c[3]));i&lt;=up;++i)cout&lt;&lt;0&lt;&lt;' '; return 0;&#125; BæŒ‰ç…§é¢˜æ„æ¨¡æ‹Ÿï¼Œå…ˆç®—å‡º $a_1$ ï¼Œç„¶åå¯ä»¥ç”¨ $a_{i,1}/a_1$ å¾—å‡ºå‰©ä½™çš„æ•° CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;int n;int res[1005],a[1005][1005];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)a[i][j]=read(); res[1]=sqrt((ll)a[1][2]*a[1][3]/a[2][3]); for(ri i=2;i&lt;=n;++i)res[i]=a[1][i]/res[1]; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;res[i]&lt;&lt;' '; puts(\"\"); return 0;&#125; Cæ˜¾ç„¶åªç”¨è€ƒè™‘é¦–å­—æ¯å¤§å°ï¼Œå–å‰ç¼€æœ€å°å€¼æ¯”ä¸€æ¯”å³å¯ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=5e5+5;char s[N];int n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=Read(s); int premn=26; for(ri i=1;i&lt;=n;++i)&#123; int x=s[i]-'a'; if(premn&lt;x)&#123; puts(\"Ann\"); &#125; else puts(\"Mike\"); premn=min(premn,x); &#125; return 0;&#125; Dæ‰‹ç©ä¸€ä¸‹å¯ä»¥å‘ç°è§„å¾‹ï¼Œè®¾æœ€åä¿ç•™çš„é›†åˆä¸º $\\{a_1,a_2,\\cdots,a_n\\}$ï¼Œé‚£ä¹ˆæ»¡è¶³ $\\forall i,j,lcm(a_i,a_j)/\\gcd(a_i,a_j)\\%2==1$ äºæ˜¯æŒ‰ $2$ çš„å¹‚æ¬¡åˆ†ç»„å³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=2e5+5;int n;bool vs[N];ll a[N];bool in[N];vector&lt;ll&gt;vl[105];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); set&lt;int&gt;A,B; for(ri i=1;i&lt;=n;++i)&#123; ll x=readl(),s=x,t=0; while(!(s&amp;1))s&gt;&gt;=1,++t; vl[t].pb(x); &#125; int mx=0; for(ri i=0;i&lt;63;++i)mx=max(mx,(int)vl[i].size()); cout&lt;&lt;n-mx&lt;&lt;'\\n'; bool ff=1; for(ri i=0;i&lt;63;++i)&#123; if(vl[i].size()==mx&amp;&amp;ff)&#123;ff=0;continue;&#125; for(ri j=0;j&lt;vl[i].size();++j)cout&lt;&lt;vl[i][j]&lt;&lt;' '; &#125; return 0;&#125; Eå…ˆ $tarjan$ ä¸€æ¬¡ï¼Œç„¶åç”¨æ ‘å½¢ $dp$ å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=2e5+5;int S,n,m,w[N],dfn[N],low[N],tot=0,stk[N],top=0,siz[N],col[N],sig=0;bool vs[N];ll sum[N];vector&lt;int&gt;e[N],E[N];void tarjan(int p,int fa)&#123; dfn[p]=low[p]=++tot,stk[++top]=p; vs[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if(dfn[v=e[p][i]])&#123; if(v==fa||!vs[v])continue; low[p]=min(low[p],dfn[v]); &#125; else tarjan(v,p),low[p]=min(low[p],low[v]); &#125; if(low[p]==dfn[p])&#123; int x; ++sig; while(1)&#123; x=stk[top--]; ++siz[sig]; col[x]=sig; vs[x]=0; sum[sig]+=w[x]; if(x==p)break; &#125; &#125;&#125;ll F[N][2];bool ok[N];void dfs(int p,int fa)&#123; ok[p]=siz[p]&gt;1; F[p][0]=sum[p]; for(ri i=0,v;i&lt;E[p].size();++i)&#123; if((v=E[p][i])==fa)continue; dfs(v,p); if(ok[v])F[p][0]+=F[v][0],ok[p]=1; &#125; F[p][1]=F[p][0]; for(ri i=0,v;i&lt;E[p].size();++i)&#123; if((v=E[p][i])==fa)continue; if(ok[v])F[p][0]-=F[v][0]; F[p][1]=max(F[p][1],F[p][0]+F[v][1]); if(ok[v])F[p][0]+=F[v][0]; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)w[i]=read(); for(ri u,v,i=1;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; S=read(); tarjan(S,0); for(ri u=1,v;u&lt;=n;++u)for(ri i=0;i&lt;e[u].size();++i)&#123; v=e[u][i]; if(col[u]==col[v])continue; E[col[u]].pb(col[v]); &#125; dfs(col[S],0); cout&lt;&lt;max(F[col[S]][0],F[col[S]][1]); return 0;&#125; Fç”¨çº¿æ®µæ ‘ç»´æŠ¤é¢˜æ„å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=4e5+5;int a[N],n,b[N],dep[N];namespace sgt1&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) int mx[N&lt;&lt;2],dt[N&lt;&lt;2]; inline void pushup(int p)&#123;mx[p]=max(mx[lc],mx[rc]);&#125; inline void pushnow(int p,int v)&#123; mx[p]+=v; dt[p]+=v; &#125; inline void pushdown(int p)&#123; if(dt[p])&#123; pushnow(lc,dt[p]); pushnow(rc,dt[p]); dt[p]=0; &#125; &#125; inline void build(int p,int l,int r)&#123; if(l==r)&#123;mx[p]=dep[a[l]];return;&#125; build(lc,l,mid),build(rc,mid+1,r); pushup(p); &#125; inline void modify(int p,int l,int r,int k,int v)&#123; if(l==r)&#123;mx[p]=v;return;&#125; pushdown(p); k&lt;=mid?modify(lc,l,mid,k,v):modify(rc,mid+1,r,k,v); pushup(p); &#125; inline void update(int p,int l,int r,int ql,int qr,int v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return pushnow(p,v); pushdown(p); if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); pushup(p); &#125; inline int query(int p,int l,int r,int k)&#123; if(l==r)return mx[p]; pushdown(p); return k&lt;=mid?query(lc,l,mid,k):query(rc,mid+1,r,k); &#125;&#125;namespace sgt2&#123; int mn[N&lt;&lt;2]; inline void pushup(int p)&#123;mn[p]=min(mn[lc],mn[rc]);&#125; inline void build(int p,int l,int r)&#123; if(l==r)&#123;mn[p]=a[l];return;&#125; build(lc,l,mid),build(rc,mid+1,r); pushup(p); &#125; inline int Ql(int p,int l,int r,int v)&#123; if(mn[p]&gt;=v)return -1; if(l==r)return l; if(mn[lc]&lt;v)return Ql(lc,l,mid,v); return Ql(rc,mid+1,r,v); &#125; inline int Ql(int p,int l,int r,int ql,int qr,int v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return Ql(p,l,r,v); if(qr&lt;=mid)return Ql(lc,l,mid,ql,qr,v); if(ql&gt;mid)return Ql(rc,mid+1,r,ql,qr,v); int res=Ql(lc,l,mid,ql,qr,v); if(~res)return res; return Ql(rc,mid+1,r,ql,qr,v); &#125; inline int Qr(int p,int l,int r,int v)&#123; if(mn[p]&gt;=v)return -1; if(l==r)return l; if(mn[rc]&lt;v)return Qr(rc,mid+1,r,v); return Qr(lc,l,mid,v); &#125; inline int Qr(int p,int l,int r,int ql,int qr,int v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return Qr(p,l,r,v); if(qr&lt;=mid)return Qr(lc,l,mid,ql,qr,v); if(ql&gt;mid)return Qr(rc,mid+1,r,ql,qr,v); int res=Qr(rc,mid+1,r,ql,qr,v); if(~res)return res; return Qr(lc,l,mid,ql,qr,v); &#125; #undef lc #undef rc #undef mid&#125;int stk[N],top=0,son[N][2];void dfs(int p)&#123; if(son[p][0])dep[son[p][0]]=dep[p]+1,dfs(son[p][0]); if(son[p][1])dep[son[p][1]]=dep[p]+1,dfs(son[p][1]);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=a[i+n]=read(),b[a[i]]=i; sgt2::build(1,1,n&lt;&lt;1); stk[top=1]=a[1]; for(ri i=2;i&lt;=n;++i)&#123; int x=0; while(top&amp;&amp;stk[top]&gt;a[i])x=stk[top--]; son[a[i]][0]=x; top&amp;&amp;(son[stk[top]][1]=a[i]); stk[++top]=a[i]; &#125; dep[1]=1; dfs(1); sgt1::build(1,1,n); int ans=n+1,res=-1; for(ri l=1,dt=0,r=n;l&lt;=n;++l,++r,++dt)&#123; if(ans&gt;sgt1::mx[1])ans=sgt1::mx[1],res=dt; int ps1=sgt2::Ql(1,1,n&lt;&lt;1,l,r,a[l]); if(~ps1)&#123; if(ps1&lt;=n+1)sgt1::update(1,1,n,l,ps1-1,-1); else sgt1::update(1,1,n,l,n,-1),sgt1::update(1,1,n,1,ps1-1-n,-1); &#125; else sgt1::pushnow(1,-1); int ps2=sgt2::Qr(1,1,n&lt;&lt;1,l+1,r+1,a[l]); if(~ps2)&#123; if(ps2&lt;n)sgt1::update(1,1,n,ps2+1,n,1),sgt1::update(1,1,n,1,r+1-n,1); else sgt1::update(1,1,n,ps2+1-n,r+1-n,1); &#125; else sgt1::pushnow(1,1); sgt1::modify(1,1,n,l,~ps2?sgt1::query(1,1,n,ps2&lt;=n?ps2:ps2-n)+1:1); &#125; cout&lt;&lt;ans&lt;&lt;' '&lt;&lt;res; return 0;&#125; Gè€ƒè™‘åˆ°ä¸€ä¸ªç­‰å¼ï¼š \\begin{aligned} \\sum\\limits_{i=1}^nd_i=&\\sum\\limits_{i=1}^n(x-x_i)^2+(y-y_i)^2\\\\ =&n(x^2+y^2)-2x\\sum\\limits_{i=1}^nx_i-2y\\sum\\limits_{i=1}^ny_i+\\sum\\limits_{i=1}^nx_i^2+y_i^2 \\end{aligned}ç„¶åæŠŠé‡å¿ƒ $G$ è®¾ç½®æˆæ–°çš„åŸç‚¹ï¼Œè¿™æ ·ä¸­é—´ä¸¤å¨å°±æ²¡äº†ï¼Œå˜ä¸ºï¼š \\begin{aligned} (x-G_x)^2+(x-G_y)^2=\\frac1n\\sum\\limits_{i=1}^nd_i-(x_i-G_x)^2-(y_i-G_y)^2 \\end{aligned}ä¸éš¾çœ‹å‡ºè¿™æ˜¯ä¸€ä¸ªåœ†çš„æ–¹ç¨‹ï¼Œå³æ‰€æœ‰æ»¡è¶³è¦æ±‚çš„è§£éƒ½åœ¨è¿™ä¸ªåœ†ä¸Šï¼Œç„¶åæˆ‘ä»¬æšä¸¾ $a_1$ æ‰€å¯¹çš„åŠå¾„ä¸º $d_i$ æ¥å¾—åˆ°ä¸€ä¸ªæ–°çš„åœ†ï¼Œæ±‚å‡ºæ‰€æœ‰åœ†çš„äº¤ç‚¹ä¸€ä¸€å¸¦å…¥éªŒè¯æ˜¯å¦åˆæ³•å³å¯ ç”±äºæ•°æ®éšæœºå› æ­¤å¤æ‚åº¦æ˜¯å¯¹çš„ æ³¨æ„ç›´æ¥ $long$ $double$ æœ‰å¯èƒ½ä¼šç‚¸ç²¾åº¦ï¼Œäºæ˜¯å¯ä»¥å°è£…ä¸€ä¸ªæ¨¡æ„ä¹‰ä¸‹çš„å®æ•°æ¥è¿›è¡Œè¿ç®— CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=1e5+5;const long double eps=1e-10;inline int sgn(long double x)&#123;return (x&gt;eps)-(x&lt;-eps);&#125;const int mod=1e9+7;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;template&lt;class T&gt;struct modular&#123; T vl; explicit operator T()const&#123;return vl;&#125; modular()&#123;vl=0;&#125; modular(const ll&amp;v)&#123;vl=v&gt;=-mod&amp;&amp;v&lt;=mod?v:v%mod,vl&lt;0?vl+=mod:0;&#125; friend inline bool operator==(const modular&amp;a,const modular&amp;b)&#123;return a.vl==b.vl;&#125; friend inline bool operator!=(const modular&amp;a,const modular&amp;b)&#123;return a.vl!=b.vl;&#125; friend inline bool operator&lt;(const modular&amp;a,const modular&amp;b)&#123;return a.vl&lt;b.vl;&#125; friend inline bool operator&gt;(const modular&amp;a,const modular&amp;b)&#123;return a.vl&gt;b.vl;&#125; friend inline bool operator&lt;=(const modular&amp;a,const modular&amp;b)&#123;return a.vl&lt;=b.vl;&#125; friend inline bool operator&gt;=(const modular&amp;a,const modular&amp;b)&#123;return a.vl&gt;=b.vl;&#125; inline modular operator-()const&#123;return mod-vl;&#125; friend inline modular operator+(const modular&amp;a,const modular&amp;b)&#123;return modular(a.vl+b.vl&lt;mod?a.vl+b.vl:a.vl+b.vl-mod);&#125; friend inline void operator+=(modular&amp;a,const modular&amp;b)&#123;a=a+b;&#125; friend inline modular operator-(const modular&amp;a,const modular&amp;b)&#123;return modular(a.vl&lt;b.vl?a.vl-b.vl+mod:a.vl-b.vl);&#125; friend inline void operator-=(modular&amp;a,const modular&amp;b)&#123;a=a-b;&#125; friend inline modular operator*(const modular&amp;a,const modular&amp;b)&#123;return modular((ll)a.vl*b.vl%mod);&#125; friend inline void operator*=(modular&amp;a,const modular&amp;b)&#123;a=a*b;&#125; friend inline modular operator^(modular a,ll p)&#123;modular ans=1;for(;p;p&gt;&gt;=1,a*=a)if(p&amp;1)ans*=a;return ans;&#125; friend inline void operator^=(modular&amp;a,const ll&amp;p)&#123;a=a^p;&#125; friend inline modular operator^(modular a,int p)&#123;modular ans=1;for(;p;p&gt;&gt;=1,a*=a)if(p&amp;1)ans*=a;return ans;&#125; friend inline void operator^=(modular&amp;a,const int&amp;p)&#123;a=a^p;&#125; friend inline modular inv(const modular&amp;a)&#123;return a^(mod-2);&#125; friend inline modular operator/(const modular&amp;a,const modular&amp;b)&#123;return modular(a*inv(b));&#125; friend inline void operator/=(modular&amp;a,const modular&amp;b)&#123;a=a/b;&#125; &#125;;typedef modular&lt;int&gt; mi;struct F&#123; mi x,y; F(mi x=mi(0),mi y=mi(0)):x(x),y(y)&#123;&#125; friend inline F operator+(F a,F b)&#123;return F(a.x+b.x,a.y+b.y);&#125; friend inline void operator+=(F&amp;a,F b)&#123;a=a+b;&#125; friend inline F operator-(F a,F b)&#123;return F(a.x-b.x,a.y-b.y);&#125; friend inline void operator-=(F&amp;a,F b)&#123;a=a-b;&#125; friend inline F operator/(F a,mi b)&#123;return F(a.x/b,a.y/b);&#125; friend inline void operator/=(F&amp;a,mi b)&#123;a=a/b;&#125; friend inline F operator*(F a,mi b)&#123;return F(a.x*b,a.y*b);&#125; friend inline void operator*=(F&amp;a,mi b)&#123;a=a*b;&#125; friend inline bool operator&lt;(F a,F b)&#123;return a.x!=b.x?a.x&lt;b.x:a.y&lt;b.y;&#125; friend inline bool operator==(F a,F b)&#123;return a.x==b.x&amp;&amp;a.y==b.y;&#125; inline mi mod()const&#123;return x*x+y*y;&#125;&#125;a[N],G,O1,O2;int W;inline int rd()&#123;return rand()|(rand()&lt;&lt;15);&#125;struct cp&#123; int x,y; cp(int x=0,int y=0):x(x),y(y)&#123;&#125; friend inline cp operator*(cp a,cp b)&#123;return cp(add(mul(a.x,b.x),mul(W,mul(a.y,b.y))),add(mul(a.x,b.y),mul(a.y,b.x)));&#125; friend inline cp operator^(cp a,ll p)&#123;cp res=cp(1,0);for(;p;p&gt;&gt;=1,a=a*a)if(p&amp;1)res=res*a;return res;&#125;&#125;;inline int Sqrt(int x)&#123; if(x==0)return 0; if(ksm(x,(mod-1)&gt;&gt;1)==mod-1)return -1; int a; while(1)&#123; a=(rd()%mod+mod)%mod,W=dec(mul(a,a),x); if(ksm(W,(mod-1)&gt;&gt;1)==mod-1)&#123; int res=(cp(a,1)^((mod+1)&gt;&gt;1)).x; return min(res,mod-res); &#125; &#125;&#125;int n;inline mi sq(mi x)&#123;return x*x;&#125;inline ll fix(mi x)&#123; int res=(int)x; if(res&gt;abs(res-mod))res-=mod; return res;&#125;vector&lt;pair&lt;ll,ll&gt; &gt;res;ll d[N],_d[N];inline ll dist(ll x,ll y,ll a,ll b)&#123;return (x-a)*(x-a)+(y-b)*(y-b);&#125;inline void check(F pt,ll dis)&#123; ll dx=fix(pt.x),dy=fix(pt.y); if(dist(dx,dy,(int)a[1].x,(int)a[1].y)!=dis)return; for(ri i=1;i&lt;=n;++i)_d[i]=dist(dx,dy,(int)a[i].x,(int)a[i].y); sort(_d+1,_d+n+1); for(ri i=1;i&lt;=n;++i)if(_d[i]!=d[i])return; res.pb(make_pair(dx,dy));&#125;inline void modify(F o1,mi r1,F o2,mi r2,ll dis)&#123; mi a=(o1.x-o2.x)*2,b=(o1.y-o2.y)*2,c=r2-r1+o1.mod()-o2.mod(); if(a!=0)&#123; b=b/a,c=c/a; mi A=b*b+1,B=(b*o1.x-b*c-o1.y)*2,C=(c-o1.x)*(c-o1.x)+o1.y*o1.y-r1,delta; B/=A,C/=A; delta=B*B-C*4; int res=Sqrt(delta.vl); mi x,y; if(res==-1)return; y=(-B+res)/2,x=c-y*b; check(F(x,y),dis); y=(-B-res)/2,x=c-y*b; check(F(x,y),dis); &#125; else&#123; mi y=c/b; int s=Sqrt((r1-sq(o1.y-y)).vl); if(s==-1)return; check(F(o1.x+s,y),dis); check(F(o1.x-s,y),dis); &#125;&#125;mi dall=mi(0),Dall=mi(0),R1,R2;int main()&#123; srand(time(NULL)); #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i].x=read(),a[i].y=read(),G=G+a[i],dall-=a[i].mod(); G=G/mi(n); if(a[1]==G)swap(a[1],a[2]); O1=G; O2=a[1]; dall+=n*G.mod(); for(ri tt=read();tt;--tt)&#123; Dall=dall; for(ri i=1;i&lt;=n;++i)d[i]=readl(),Dall+=d[i]; sort(d+1,d+n+1); res.clear(); R1=Dall/n; for(ri i=1;i&lt;=n;++i)&#123; if(i!=1&amp;&amp;d[i]==d[i-1])continue; R2=d[i]; modify(O1,R1,O2,R2,d[i]); &#125; sort(res.begin(),res.end()); res.erase(unique(res.begin(),res.end()),res.end()); cout&lt;&lt;res.size()&lt;&lt;' '; for(ri i=0;i&lt;res.size();++i)cout&lt;&lt;res[i].fi&lt;&lt;' '&lt;&lt;res[i].se&lt;&lt;' '; puts(\"\"); &#125; return 0;&#125; å‘Šè¾","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"2019.10.03 æ¨¡æ‹Ÿæµ‹è¯•é¢˜è§£","slug":"191003test","date":"2019-10-03T07:07:45.000Z","updated":"2019-10-11T15:33:35.719Z","comments":true,"path":"191003test/","link":"","permalink":"http://ldxcaicai.github.io/191003test/","excerpt":"","text":"Aé¢˜æ„ç®€è¿°ï¼š ç»™å‡ºä¸€ä¸ª $n$ ä¸ªç‚¹ $m$ æ¡è¾¹çš„å¸¦æƒæœ‰å‘å›¾ï¼Œè¦æ±‚åˆ å»æŸäº›è¾¹ä½¿å¾—æœ€åçš„å›¾æ¯ä¸ªç‚¹çš„å…¥åº¦å‡ºåº¦å‡ä¸èƒ½è¶…è¿‡ $1$ ï¼Œé—®åˆ å»çš„è¾¹æƒå’Œæœ€å°å€¼ æ•°æ®èŒƒå›´ï¼š $n\\le200$ $m\\le10000$ è§£é¢˜æ€è·¯ï¼š è€ƒè™‘ç®€å•è¡¥é›†è½¬åŒ–ï¼Œå˜ä¸ºæ±‚ä¿ç•™çš„è¾¹æƒå’Œæœ€å¤§å€¼ï¼Œç„¶åè€ƒè™‘æŒ‰ç…§é¢˜æ„å»ºå›¾å˜æˆæœ€å¤§è´¹ç”¨æµé—®é¢˜æˆ–è€…è¯´äºŒåˆ†å›¾æœ€å¤§åŒ¹é…é—®é¢˜ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se secondconst int N=10005,M=2e6+5,inf=0x3f3f3f3f;struct edge&#123;int v,c,w,next;&#125;;int n,m;namespace mcmf&#123; ll dis[N],res,sum; int ps[N],cnt,first[N],s,t; bool in[N]; edge e[M]; inline void addedge(int u,int v,int c,int w)&#123; e[++cnt]=(edge)&#123;v,c,w,first[u]&#125;; first[u]=cnt; &#125; inline void add(int u,int v,int c,int w)&#123; addedge(u,v,c,w); addedge(v,u,0,-w); &#125; inline void init()&#123;memset(first,-1,sizeof(first)),cnt=-1,s=0,t=2*n+1,res=sum=0;&#125; inline bool bfs()&#123; queue&lt;int&gt;q; for(ri i=s;i&lt;=t;++i)dis[i]=-inf,ps[i]=-1; in[s]=1,dis[s]=0,q.push(s); while(q.size())&#123; int x=q.front(); q.pop(); in[x]=0; for(ri i=first[x],v;~i;i=e[i].next)&#123; v=e[i].v; if(e[i].c&gt;0&amp;&amp;dis[v]&lt;dis[x]+e[i].w)&#123; dis[v]=dis[x]+e[i].w; ps[v]=i; if(!in[v])in[v]=1,q.push(v); &#125; &#125; &#125; if(dis[t]==-inf)return 0; sum+=dis[t]; res=max(res,sum); int p=t; while(p^s)--e[ps[p]].c,++e[ps[p]^1].c,p=e[ps[p]^1].v; return 1; &#125; inline ll solve()&#123; while(bfs()); return res; &#125;&#125;int main()&#123; n=read(),m=read(); ll ss=0; mcmf::init(); for(ri i=1;i&lt;=n;++i)&#123; mcmf::add(mcmf::s,i,1,0); mcmf::add(i+n,mcmf::t,1,0); &#125; for(ri i=1,u,v,w;i&lt;=m;++i)&#123; u=read(),v=read(),w=read(); ss+=w; if(w&lt;=0)continue; mcmf::add(u,v+n,1,w); &#125; cout&lt;&lt;ss-mcmf::solve(); return 0;&#125; Bé¢˜æ„ç®€è¿°ï¼š ç»™å‡ºä¸€ä¸ª $n*m$ çš„æ ¼å­è®©ä½ æŸ“è‰²å¹¶ç»™å‡ºæŸ“è‰²çš„ç»ˆæ€ï¼Œä¿è¯æ¯ä¸ªä½ç½®é¢œè‰²æ•°å€¼ä¸è¶…è¿‡ $C$ ï¼Œç°åœ¨æœ€åˆæ ¼å­ä¸Šéƒ½æœªè¢«æŸ“è¿‡è‰²ï¼Œæ¯æ¬¡å¯ä»¥æŠŠæŸä¸€è¡Œæˆ–è€…æŸä¸€åˆ—æŸ“æˆä¸€ä¸ªç›¸åŒçš„é¢œè‰²ï¼Œæ±‚æŸ“è‰²æ¬¡æ•°æœ€å°‘çš„ä»»æ„æ–¹æ¡ˆï¼Œæ— è§£è¾“å‡º $-1$ æ•°æ®èŒƒå›´ï¼š $n,m\\le50$ $C\\le100$ è§£é¢˜æ€è·¯ï¼š å…ˆæ€è€ƒå¦‚ä½•å¾—åˆ°å¯è¡Œè§£ï¼Œç„¶åå¯¹æŸ“è‰²æ¬¡æ•°è¿›è¡Œä¼˜åŒ– è€ƒè™‘æ—¶é—´å€’æµï¼Œæœ€åæŸ“ä¸Šé¢œè‰²åä¸€å®šæŸä¸€è¡Œæˆ–è€…æŸä¸€åˆ—æ˜¯åŒä¸€ç§é¢œè‰²ï¼Œè€ƒè™‘åˆ å»è¿™æ ·çš„è¡Œæˆ–è€…åˆ—ç„¶åå¯¹å‰©ä¸‹çš„çŸ©é˜µè¿­ä»£è¯¥æ“ä½œï¼Œæœ€åå¦‚æœåˆæ³•ä¸€å®šå‰©ä¸‹ä¸€ä¸ªå…¨é›¶çŸ©é˜µï¼Œå¦åˆ™å°±éæ³• è¿™æ ·å°±æˆåŠŸå¾—åˆ°äº†ä¸€ä¸ªå¯è¡Œè§£ï¼Œç„¶åä¸‹é¢è€ƒè™‘ä¸¤ä¸ªç®€å•ä¼˜åŒ–ï¼š å‡å¦‚å½“å‰éé›¶è¡Œçš„ä¸ªæ•°ä¸è¶…è¿‡éé›¶åˆ—çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆä¼˜å…ˆæ¶ˆå»ä¸€è¡Œï¼Œå¦åˆ™ä¼˜å…ˆæ¶ˆå»ä¸€åˆ— å‡å¦‚å½“å‰æœ‰è‹¥å¹²ä¸ªåˆæ³•çš„è¡Œ/åˆ—ï¼Œå°†å…¶æŒ‰ç…§é¢œè‰²åˆ†ç±»ï¼Œç„¶åä¼˜å…ˆæ¶ˆå»æŸç§å¯è¡Œæ¬¡æ•°æœ€å°‘çš„é¢œè‰²å¯¹åº”çš„ä»»æ„ä¸€è¡Œ/åˆ— è¿™æ ·å¯ä»¥é€šè¿‡ç°æœ‰çš„æ‰€æœ‰æ•°æ®ç‚¹ æƒ³å¿…ä¼šæœ‰æ•°æ®èƒ½å¤ŸÃ—æ‰ä¸Šè¿°åšæ³•ï¼Œæ¯•ç«Ÿæ­£è§£è¦åŠ ä¸€ä¸ªtopsoortå¹¶ä¸”ç¬”è€…å¹¶ä¸ä¼šè¯æ˜ä¸Šè¿°åšæ³•æ­£ç¡®æ€§ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef long long ll;typedef pair&lt;int,int&gt; pii;int n,m,a[55][55],C;struct F&#123; int op,x,y; F(int op=0,int x=0,int y=0):op(op),x(x),y(y)&#123;&#125;&#125;;int cnt1[155],cnt2[155],Ps1[155],Ps2[155];vector&lt;F&gt;res;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),C=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); vector&lt;int&gt;X,Y; for(ri i=1;i&lt;=n;++i)X.pb(i); for(ri i=1;i&lt;=m;++i)Y.pb(i); while(X.size()&amp;&amp;Y.size())&#123; int ct1=0,ct2=0; for(ri i=1;i&lt;=C;++i)cnt1[i]=0,cnt2[i]=0; for(ri i=0;i&lt;X.size();++i)&#123; bool ff=1; for(ri j=0;j&lt;Y.size();++j)if(a[X[i]][Y[j]])&#123; ff=0; break; &#125; if(ff)++ct1; &#125; for(ri i=0;i&lt;Y.size();++i)&#123; bool ff=1; for(ri j=0;j&lt;X.size();++j)if(a[X[j]][Y[i]])&#123; ff=0; break; &#125; if(ff)++ct2; &#125; if(ct1==X.size())break; int ps1=-1; for(ri i=0;i&lt;X.size();++i)&#123; bool ff=1; for(ri j=0;j&lt;Y.size();++j)&#123; if(!a[X[i]][Y[j]]||(j&amp;&amp;a[X[i]][Y[j]]!=a[X[i]][Y[j-1]]))&#123; ff=0; break; &#125; &#125; if(ff)&#123; ps1=i; ++cnt1[a[X[i]][Y[0]]]; Ps1[a[X[i]][Y[0]]]=i; &#125; &#125; int ps2=-1; for(ri i=0;i&lt;Y.size();++i)&#123; bool ff=1; for(ri j=0;j&lt;X.size();++j)&#123; if(!a[X[j]][Y[i]]||(j&amp;&amp;a[X[j]][Y[i]]!=a[X[j-1]][Y[i]]))&#123; ff=0; break; &#125; &#125; if(ff)&#123; ps2=i; ++cnt2[a[X[0]][Y[i]]]; Ps2[a[X[0]][Y[i]]]=i; &#125; &#125; if(ps1==-1&amp;&amp;ps2==-1)&#123; puts(\"-1\"); return 0; &#125; if(X.size()-ct1&lt;Y.size()-ct2)&#123; if(~ps1)&#123; int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt1[i])mn=min(mn,cnt1[i]); for(ri i=1;i&lt;=C;++i)if(cnt1[i]==mn)&#123;ps1=Ps1[i];break;&#125; res.pb(F(1,X[ps1],a[X[ps1]][Y[0]])); for(ri i=ps1+1;i&lt;X.size();++i)X[i-1]=X[i]; X.pop_back(); continue; &#125; else&#123; int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt2[i])mn=min(mn,cnt2[i]); for(ri i=1;i&lt;=C;++i)if(cnt2[i]==mn)&#123;ps2=Ps2[i];break;&#125; res.pb(F(0,Y[ps2],a[X[0]][Y[ps2]])); for(ri i=ps2+1;i&lt;Y.size();++i)Y[i-1]=Y[i]; Y.pop_back(); continue; &#125; &#125; else&#123; if(~ps2)&#123; int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt2[i])mn=min(mn,cnt2[i]); for(ri i=1;i&lt;=C;++i)if(cnt2[i]==mn)&#123;ps2=Ps2[i];break;&#125; res.pb(F(0,Y[ps2],a[X[0]][Y[ps2]])); for(ri i=ps2+1;i&lt;Y.size();++i)Y[i-1]=Y[i]; Y.pop_back(); continue; &#125; else&#123; int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt1[i])mn=min(mn,cnt1[i]); for(ri i=1;i&lt;=C;++i)if(cnt1[i]==mn)&#123;ps1=Ps1[i];break;&#125; res.pb(F(1,X[ps1],a[X[ps1]][Y[0]])); for(ri i=ps1+1;i&lt;X.size();++i)X[i-1]=X[i]; X.pop_back(); continue; &#125; &#125; &#125; cout&lt;&lt;res.size()&lt;&lt;'\\n'; for(ri i=res.size()-1;~i;--i)&#123; if(res[i].op)cout&lt;&lt;\"R \"; else cout&lt;&lt;\"C \"; cout&lt;&lt;res[i].x&lt;&lt;' '&lt;&lt;res[i].y&lt;&lt;'\\n'; &#125; return 0;&#125; Cé¢˜æ„ç®€è¿°ï¼š ç»™ä½ ä¸€æ£µå¸¦æƒæ ‘ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªé™åˆ¶ $d_i$ ï¼Œç°åœ¨ä»æ—¶åˆ» $0$ å¼€å§‹çš„æ¯ä¸ªæ—¶åˆ»ï¼Œå¯¹äºæ¯ä¸ªé™åˆ¶è¢«æ‰“ç ´çš„èŠ‚ç‚¹ä¼šæœ‰ä¸€ä¸ªäººå‡ºå‘å‘æ ¹èµ°ï¼Œæ¯ä¸ªå•ä½æ—¶é—´è¡Œèµ°ä¸€ä¸ªå•ä½é•¿åº¦ï¼Œå½“ä¸€ä¸ªäººç»è¿‡æŸä¸ªç‚¹æ—¶ï¼Œå¦‚æœå…¶é™åˆ¶æœªè¢«æ‰“ç ´ï¼Œé‚£ä¹ˆè¯¥ç‚¹é™åˆ¶å‡ä¸€ï¼Œå½“é™åˆ¶ä¸º $0$ æ—¶å°±è§†ä¸ºè¢«æ‰“ç ´ï¼Œä¿è¯å¶å­çš„é™åˆ¶ä¸€å®šæ˜¯ $0$ ï¼Œè¯¢é—®æ ‘ä¸Šçš„æ‰€æœ‰å¶å­çš„é™åˆ¶å…¨éƒ¨è¢«æ‰“ç ´çš„æ—¶åˆ» æ•°æ®èŒƒå›´ï¼š $n\\le10^5$ $w_i\\le1000$ $d_i\\le10^8$ è§£é¢˜æ€è·¯ï¼š è€ƒè™‘å¯¹æ¯ä¸ªèŠ‚ç‚¹å»ºç«‹æ—¶åˆ»ä¸ºæ¨ªè½´ï¼Œå·²ç»è¿‡äººæ•°ä¸ºçºµè½´çš„å‡½æ•°å›¾åƒï¼Œè¿™æ ·çš„è¯å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ç›¸å½“äºè¦æ”¯æŒå¦‚ä¸‹æ“ä½œï¼š å°†æŸä¸ªå­æ ‘çš„å‡½æ•°å›¾åƒçš„æ¨ªåæ ‡æ•´ä½“å³ç§»ä¸€ä¸ªå€¼ å°†æ‰€æœ‰å­æ ‘çš„å‡½æ•°å›¾åƒç»™å åŠ èµ·æ¥ åœ¨å·²ç»å åŠ å¥½çš„å›¾åƒä¸­æ±‚å‡ºè‡ªå·±æ‰“ç ´é™åˆ¶çš„æ—¶é—´ å°†è‡ªå·±æ‰“ç ´é™åˆ¶ä¹‹åçš„ä¸€æ¬¡å‡½æ•°åŠ åˆ°å›¾åƒä¸­ é‚£ä¹ˆè¿™å°±æˆäº†ä¸€é“ç»å…¸çš„æŠ˜çº¿é¢˜ï¼Œè€ƒè™‘ç»´æŠ¤æ‰€æœ‰æ‹ç‚¹ï¼Œé‚£ä¹ˆè¦ç»´æŠ¤çš„å°±æ˜¯æ•´ä½“æ‰“æ ‡è®°ï¼Œå¹³è¡¡æ ‘+å¯å‘å¼åˆå¹¶ï¼ŒäºŒåˆ†æ±‚ç­”æ¡ˆå’Œå•ç‚¹æ’å…¥ï¼Œç›´æ¥ç”¨ $Treap$ ç»´æŠ¤å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=1e5+5;inline int rnd()&#123;return rand()|(rand()&lt;&lt;15);&#125;int rt[N],n,lm[N],tim[N],det[N];vector&lt;pii&gt;e[N];vector&lt;int&gt;tp;namespace bst&#123; #define lc (son[p][0]) #define rc (son[p][1]) int rd[N],vl[N],siz[N],tot=0,top=0,stk[N*20],son[N][2]; ll ss[N]; inline int newidx()&#123;return top?stk[top--]:++tot;&#125; inline int newnode(int v)&#123; int p=newidx(); lc=rc=0,vl[p]=ss[p]=v,rd[p]=rnd(),siz[p]=1; return p; &#125; inline void pushup(int p)&#123; siz[p]=siz[lc]+1+siz[rc]; ss[p]=ss[lc]+vl[p]+ss[rc]; &#125; inline int merge(int a,int b)&#123; if(!a||!b)return a|b; if(rd[a]&lt;rd[b])return son[a][1]=merge(son[a][1],b),pushup(a),a; return son[b][0]=merge(a,son[b][0]),pushup(b),b; &#125; inline pii split(int p,int k)&#123; if(!p)return pii(0,0); pii res; if(siz[lc]&gt;=k)return res=split(lc,k),lc=res.se,pushup(p),pii(res.fi,p); return res=split(rc,k-siz[lc]-1),rc=res.fi,pushup(p),pii(p,res.se); &#125; inline int rank(int p,int v)&#123; if(!p)return 0; if(vl[p]&lt;=v)return siz[lc]+1+rank(rc,v); return rank(lc,v); &#125; inline void insert(int _rt,int v)&#123; int k=rank(rt[_rt],v); pii x=split(rt[_rt],k); rt[_rt]=merge(x.fi,merge(newnode(v),x.se)); &#125; inline void update(int p,int det)&#123; if(!p)return; update(lc,det),update(rc,det); stk[++top]=p; tp.pb(vl[p]+det); &#125; inline int query(int _rt,int lm)&#123; int l=-1e9,r=1e9,res=1e9,mid,k; while(l&lt;=r)&#123; mid=l+r&gt;&gt;1,k=rank(rt[_rt],mid); pii x=split(rt[_rt],k); if((ll)mid*siz[x.fi]-ss[x.fi]&gt;=lm)r=mid-1,res=mid; else l=mid+1; rt[_rt]=merge(x.fi,x.se); &#125; return res; &#125; #undef lc #undef rc&#125;inline void Merge(int a,int b)&#123; if(bst::siz[rt[a]]&lt;bst::siz[rt[b]])swap(rt[a],rt[b]),swap(det[a],det[b]); bst::update(rt[b],det[b]-det[a]); while(tp.size())bst::insert(a,tp.back()),tp.pop_back();&#125;int ans=0,q[N],fa[N],vll[N],hd,tl;int main()&#123; srand(time(NULL)); #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)lm[i]=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); &#125; q[hd=tl=1]=1; while(hd&lt;=tl)&#123; int x=q[hd++]; for(ri i=0,v;i&lt;e[x].size();++i)&#123; if((v=e[x][i].fi)==fa[x])continue; vll[v]=e[x][i].se,fa[v]=x,q[++tl]=v; &#125; &#125; for(ri p,ft,i=n;i;--i)&#123; p=q[i],ft=fa[p]; if(!lm[p])tim[p]=-det[p]; else tim[p]=bst::query(p,lm[p]); ans=max(ans,det[p]+tim[p]); bst::insert(p,tim[p]); det[p]+=vll[p]; if(ft)Merge(ft,p); &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"è€ƒè¯•é¢˜è§£","slug":"è€ƒè¯•é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/è€ƒè¯•é¢˜è§£/"}]},{"title":"2019.10.02 æ¨¡æ‹Ÿæµ‹è¯•é¢˜è§£","slug":"191002test","date":"2019-10-02T12:49:11.000Z","updated":"2019-10-11T15:33:36.965Z","comments":true,"path":"191002test/","link":"","permalink":"http://ldxcaicai.github.io/191002test/","excerpt":"","text":"é¢˜ç›®æ¥æºï¼š $A:TCO499$ $1000pts$ $B:CF613E$ $C:å‡ºé¢˜äººåŸåˆ›$ Aé¢˜æ„ç®€è¿°ï¼š åœ¨åˆå§‹ä½ è‡ªå·±åˆ›é€ ä¸€ä¸ªç”± $A,B,C,D$ ç»„æˆçš„é•¿åº¦ä¸º $n$ çš„å­—ç¬¦ä¸²ï¼Œç»™å‡ºæœ‰ $m$ ç§è½¬ç§»ï¼Œæ¯ç§è½¬ç§»ç”¨ä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„ $ABCD$ ä¸²æ¥è¡¨ç¤ºï¼Œå‰è€…å¯ä»¥å˜æˆåè€…ï¼Œç„¶åè¿›è¡Œè‹¥å¹²æ¬¡å¦‚ä¸‹ä¸¤ç§æ“ä½œï¼š äº¤æ¢å…¶ä¸­ä¸¤ä¸ªç›¸é‚»å­—ç¬¦ è¿›è¡Œä¸€æ¬¡è½¬ç§» é—®å¾—åˆ°çš„ä¸åŒå­—ç¬¦ä¸²æ•°çš„æœ€å¤§å€¼ æ•°æ®èŒƒå›´ï¼š $n\\le30$ $m\\le50$ è§£é¢˜æ€è·¯ï¼š åˆ†æä¸¤ç§æ“ä½œï¼Œç¬¬ä¸€ä¸ªæ“ä½œç›¸å½“äºå‘Šè¯‰æˆ‘ä»¬ä¸€ä¸ªå­—ç¬¦ä¸²å¯ä»¥ç”±ä»¥ä¸‹ä¿¡æ¯è¡¨ç¤º $(cnt_a,cnt_b,cnt_c,cnt_d)$ ï¼Œè€Œæ–¹æ¡ˆæ•°åˆ™æ˜¯ $C_{a}^a\\times C_{a+b}^b\\times C_{a+b+c}^c*C_{a+b+c+d}^d$ ï¼Œç¬¬äºŒä¸ªæ“ä½œç›¸å½“äºæ˜¯å»ºç«‹è¾¹ï¼Œè¿™æ ·ç›¸å½“äºæ±‚ä¸€ä¸ªæœ‰å‘å›¾çš„å¸¦æƒæœ€é•¿é“¾é•¿åº¦ï¼Œåªéœ€è¦æŒ‰ç…§é¢˜æ„å»ºå‡ºå›¾æ¥ç„¶åç”¨ $tarjan+topsort$ å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;typedef long long ll;const int mod=998244353;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=1e6+5;int n,m,all,col[N],trans[2][55][5];bool in[N];ll res=0,F[N],vl[N],C[35][35],mx[N];vector&lt;int&gt;e[N],E[N];char s[35];inline int idx(int a,int b,int c,int d)&#123;return (n+1)*(n+1)*(n+1)*a+(n+1)*(n+1)*b+(n+1)*c+d;&#125;inline void init()&#123; for(ri i=0;i&lt;=n;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125; for(ri a=0,d;a&lt;=n;++a)for(ri b=0;a+b&lt;=n;++b) for(ri c=0;a+b+c&lt;=n;++c)&#123; d=n-a-b-c; F[idx(a,b,c,d)]=C[a][a]*C[a+b][b]*C[n-d][c]*C[n][d]; &#125;&#125;int tot=0,top=0,sig=0,dfn[N],low[N],stk[N],du[N];inline void dfs(int p)&#123; dfn[p]=low[p]=++tot; in[stk[++top]=p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if(!dfn[v=e[p][i]])dfs(v),low[p]=min(low[p],low[v]); else if(in[v])low[p]=min(low[p],dfn[v]); &#125; if(dfn[p]==low[p])&#123; ++sig; int x; while(1)&#123; x=stk[top--]; col[x]=sig,in[x]=0; vl[sig]+=F[x]; if(x==p)break; &#125; &#125;&#125;inline void topsort()&#123; queue&lt;int&gt;q; for(ri i=1;i&lt;=sig;++i)if(!du[i])q.push(i),mx[i]=vl[i]; while(q.size())&#123; int x=q.front(); q.pop(); for(ri i=0,v;i&lt;E[x].size();++i)&#123; v=E[x][i]; mx[v]=max(mx[v],mx[x]+vl[v]); if(!(--du[v]))q.push(v); &#125; &#125; for(ri i=1;i&lt;=sig;++i)res=max(res,mx[i]); cout&lt;&lt;res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); init(); for(ri len,i=1;i&lt;=m;++i)for(ri t=0;t&lt;2;++t)&#123;len=Read(s);for(ri j=1;j&lt;=len;++j)++trans[t][i][s[j]-'A'+1];&#125; int all=n*(n+1)*(n+1)*(n+1); for(ri a=0,d,_a,_b,_c,_d;a&lt;=n;++a)for(ri b=0;a+b&lt;=n;++b) for(ri c=0;a+b+c&lt;=n;++c)&#123; d=n-a-b-c; for(ri i=1;i&lt;=m;++i)&#123; _a=a-trans[0][i][1]; if(_a&lt;0)continue; _a+=trans[1][i][1]; _b=b-trans[0][i][2]; if(_b&lt;0)continue; _b+=trans[1][i][2]; _c=c-trans[0][i][3]; if(_c&lt;0)continue; _c+=trans[1][i][3]; _d=d-trans[0][i][4]; if(_d&lt;0)continue; _d+=trans[1][i][4]; e[idx(a,b,c,d)].pb(idx(_a,_b,_c,_d)); &#125; &#125; for(ri i=1;i&lt;=all;++i)if(!dfn[i])dfs(i); for(ri i=1;i&lt;=all;++i)for(ri j=0;j&lt;e[i].size();++j)if(col[i]^col[e[i][j]])E[col[i]].pb(col[e[i][j]]),++du[col[e[i][j]]]; topsort(); return 0;&#125; Bé¢˜æ„ç®€è¿°ï¼š ç»™å‡ºä¸€ä¸ª $2\\times n$ çš„çŸ©é˜µ $\\boldsymbol{A}$ ï¼ŒçŸ©é˜µä¸­æ¯ä¸ªæ ¼å­éƒ½æ˜¯ä¸€ä¸ªå°å†™å­—æ¯ï¼ŒåŒæ—¶æœ‰ä¸€ä¸ªé•¿åº¦ä¸º $M$ çš„å­—ç¬¦ä¸² $S$é—®åœ¨çŸ©é˜µä¸­èµ·ç‚¹å’Œç»ˆç‚¹ä»»æ„ï¼Œåªå…è®¸å‘ä¸Šã€ä¸‹ã€å·¦ã€å³èµ°ï¼Œä¸ç»è¿‡é‡å¤æ ¼å­ï¼Œä¸”ä¾æ¬¡ç»è¿‡çš„å­—æ¯è¿èµ·æ¥æ˜¯ $S$ çš„è·¯å¾„æœ‰å¤šå°‘ç§ã€‚ æ•°æ®èŒƒå›´ï¼š $n\\le2000$ $m\\le2000$ è§£é¢˜æ€è·¯ï¼š è®¾è·¯å¾„çš„å¼€å¤´ç»“å°¾æ˜¯ $S,T$ ï¼Œé‚£ä¹ˆæ‰€æœ‰åˆæ³•è·¯å¾„å¯ä»¥åˆ’åˆ†æˆä¸‰æ®µ ï¼› ä» $S$ å¼€å§‹å‘å·¦èµ°ä¸€æ®µç„¶åèµ°å›æ¥ ä» $T$ å¼€å§‹å‘å³èµ°ä¸€æ®µç„¶åèµ°å›æ¥ ä¸­é—´æ®µä¸Šä¸‹ä¸Šä¸‹çš„å‘å³èµ° ç„¶åè€ƒè™‘å¯¹ä¸­é—´çš„è¿›è¡Œ $dp$ï¼Œè®¾ $f_{i,j,k}$ è¡¨ç¤ºèµ°åˆ°ç¬¬ $i$ è¡Œ $j$ åˆ—åŒ¹é…åˆ°ç¬¬ $k$ ä¸ªå­—ç¬¦çš„æ–¹æ¡ˆæ•°ï¼Œå·¦è¾¹å’Œå³è¾¹ç›´æ¥ç”¨ $hash$ æä¸€ä¸‹ï¼Œæ³¨æ„ç»†èŠ‚å³å¯ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int mod=1e9+7,N=2005,bas=137;inline int add(const int&amp;a,const int&amp;b)&#123;return a+b&gt;=mod?a+b-mod:a+b;&#125;inline int dec(const int&amp;a,const int&amp;b)&#123;return a&gt;=b?a-b:a-b+mod;&#125;inline int mul(const int&amp;a,const int&amp;b)&#123;return (ll)a*b%mod;&#125;inline void update(int&amp;a,const int&amp;b)&#123;a=add(a,b);&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,a=mul(a,a))if(p&amp;1)ret=mul(ret,a);return ret;&#125;int n,m;int ans,fl[2][N][N],fr[2][N][N],pre[2][N],suf[2][N],h1[N],h2[N],hs[N],ihs[N];char s[2][N],t[N];inline int get_nl(int id,int l,int r)&#123;return mul(dec(pre[id][r],mul(pre[id][l-1],hs[r-l+1])),ihs[r-l+1]);&#125;inline int get_nr(int id,int l,int r)&#123;return mul(dec(suf[id][r],mul(suf[id][l+1],hs[l-r+1])),ihs[l-r+1]);&#125;inline int get_ml(int l,int r)&#123;return mul(dec(h1[r],mul(h1[l-1],hs[r-l+1])),ihs[r-l+1]);&#125;inline int get_mr(int l,int r)&#123;return mul(dec(h2[r],mul(h2[l+1],hs[l-r+1])),ihs[l-r+1]);&#125;inline void init_n()&#123; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;2;++j)pre[j][i]=add(mul(pre[j][i-1],bas),s[j][i]); for(ri i=n;i;--i)for(ri j=0;j&lt;2;++j)suf[j][i]=add(mul(suf[j][i+1],bas),s[j][i]);&#125;inline void init_m()&#123; for(ri i=1;i&lt;=m;++i)h1[i]=add(mul(h1[i-1],bas),t[i]); for(ri i=m;i;--i)h2[i]=add(mul(h2[i+1],bas),t[i]);&#125;inline void init()&#123; hs[0]=ihs[0]=1; for(ri i=1;i&lt;=n;++i)hs[i]=mul(hs[i-1],bas),ihs[i]=ksm(hs[i],mod-2); init_n(); init_m();&#125;int main()&#123; scanf(\"%s%s%s\",s[0]+1,s[1]+1,t+1); n=strlen(s[0]+1),m=strlen(t+1); init(); for(ri i=1;i&lt;=n;++i)&#123; for(ri id=0;id&lt;2;++id)update(fl[id][i+1][2],s[id][i]==t[1]),update(fr[id][i+1][m-1],(m^1)&amp;&amp;s[id][i]==t[m]); for(ri j=2,up=min(n-i+1,m/2);j&lt;=up;++j)for(ri id=0;id&lt;2;++id)&#123; update(ans,get_nl(id^1,i,i+j-1)==get_mr(m,m-j+1)&amp;&amp;get_nr(id,i+j-1,i)==get_mr(m-j,m-j*2+1)&amp;&amp;j*2==m); update(ans,get_nl(id^1,i,i+j-1)==get_mr(m,m-j+1)&amp;&amp;get_nr(id,i+j-1,i)==get_mr(m-j,m-j*2+1)?fl[id][i][m-j*2+1]:0); update(ans,get_nl(id^1,i,i+j-1)==get_ml(1,j)&amp;&amp;get_nr(id,i+j-1,i)==get_ml(j+1,j*2)?fr[id][i][j*2]:0); &#125; for(ri j=1;j&lt;=m;++j)for(ri id=0;id&lt;2;++id)if(s[id][i]==t[j])&#123; update(fl[id][i+1][j+1],fl[id][i][j]),update(fl[id^1][i+1][j+2],(j^m)&amp;&amp;s[id^1][i]==t[j+1]?fl[id][i][j]:0); update(fr[id][i+1][j-1],fr[id][i][j]),update(fr[id^1][i+1][j-2],(j^1)&amp;&amp;s[id^1][i]==t[j-1]?fr[id][i][j]:0); &#125; for(ri id=0;id&lt;2;++id)update(ans,add(fl[id][i+1][m+1],fr[id][i+1][0])); for(ri j=1,up=min(i,m/2);j&lt;=up;++j)for(ri id=0;id&lt;2;++id)&#123; update(ans,get_nr(id^1,i,i-j+1)==get_ml(1,j)&amp;&amp;get_nl(id,i-j+1,i)==get_ml(j+1,j*2)&amp;&amp;j*2==m); update(fl[id][i+1][j*2+1],get_nr(id^1,i,i-j+1)==get_ml(1,j)&amp;&amp;get_nl(id,i-j+1,i)==get_ml(j+1,j*2)); update(fr[id][i+1][m-j*2],get_nr(id^1,i,i-j+1)==get_mr(m,m-j+1)&amp;&amp;get_nl(id,i-j+1,i)==get_mr(m-j,m-j*2+1)); &#125; &#125; cout&lt;&lt;ans; return 0;&#125; Cé¢˜æ„ç®€è¿°ï¼š æ±‚ $\\sum\\limits_{i=1}^n\\mu(i)i^m$ æ•°æ®èŒƒå›´ï¼š $n\\le10^9$ $m\\le2*10^5$ è§£é¢˜æ€è·¯ï¼š ä»¤ $f(x)=\\mu(x)x^m,S(x)=\\sum\\limits_{i=1}^xf(i)$ è€ƒè™‘æ„é€  $g(x)=x^m,h=f\\times g\\Rightarrow h(x)=[i==1]i^m=\\epsilon(x)$ æ•…å¯ä»¥ç”¨æœæ•™ç­›ï¼Œç°åœ¨é—®é¢˜è½¬æ¢æˆæ±‚ $\\sqrt n$ ä¸ª $\\sum\\limits_{i=1}^xi^m$ çš„å€¼ï¼Œåœ¨ç©ºé—´é™åˆ¶ä¸ä¸¥çš„æƒ…å†µä¸‹å¯ä»¥åˆç†çš„å¹³è¡¡ç»“åˆé¢„å¤„ç†èŒƒå›´+æ‹‰æ ¼æœ—æ—¥æ’å€¼æˆ–è€…ç›´æ¥ç”¨å¤šé¡¹å¼å¤šç‚¹æ’å€¼ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef long long ll;const int mod=998244353;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=3e6+5;int mu[N],pri[N],ss[N],F1[N],tot=0,up,n,m,lm,lagup,lagf[N],fac[N],ifac[N],F2[N];bool vs[N],Vs1[N],Vs2[N];map&lt;int,int&gt;S;inline int lagrange(int x)&#123; if(x&lt;=up)return lagf[x]; if(S.count(x))return S[x]; static int pre[N],suf[N]; int res=0; pre[0]=suf[lagup+1]=1; for(ri i=1;i&lt;=lagup;++i)pre[i]=mul(pre[i-1],(x-i)%mod); for(ri i=lagup;i;--i)suf[i]=mul(suf[i+1],(x-i)%mod); for(ri t,i=1;i&lt;=lagup;++i)&#123; t=mul(lagf[i],mul(mul(ifac[i-1],ifac[lagup-i]),mul(pre[i-1],suf[i+1]))); (lagup-i)&amp;1?Dec(res,t):Add(res,t); &#125; return S[x]=res;&#125;inline void init()&#123; lagup=m+2,lagf[1]=fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=lagup;++i)fac[i]=mul(fac[i-1],i),ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); for(ri i=2;i&lt;=lagup;++i)Mul(ifac[i],ifac[i-1]); mu[1]=ss[1]=1; for(ri i=2;i&lt;=up;++i)&#123; if(!vs[i])pri[++tot]=i,mu[i]=mod-1; lagf[i]=ksm(i,m); ss[i]=add(ss[i-1],mul(mu[i],lagf[i])); Add(lagf[i],lagf[i-1]); for(ri j=1,lm=up/i;j&lt;=tot&amp;&amp;pri[j]&lt;=lm;++j)&#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j])&#123;mu[i*pri[j]]=0;break;&#125; mu[i*pri[j]]=dec(0,mu[i]); &#125; &#125;&#125;map&lt;int,int&gt;F;inline int Sum1(int x)&#123; if(x&lt;=up)return ss[x]; if(F.count(x))return F[x]; int res=1; for(ri l=2,r;l&lt;=x;l=r+1)&#123; r=x/(x/l); Dec(res,mul(dec(lagrange(r),lagrange(l-1)),Sum1(x/l))); &#125; return F[x]=res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); up=3e6,init(); cout&lt;&lt;Sum1(n); return 0;&#125; å¤šé¡¹å¼å¤šç‚¹æ’å€¼ä¼°è®¡ç­‰åšä¸»èº«ä½“å¥½äº†å†æ›´ æœ‰ç”Ÿä¹‹å¹´","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"è€ƒè¯•é¢˜è§£","slug":"è€ƒè¯•é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/è€ƒè¯•é¢˜è§£/"}]},{"title":"2019.09.30 æ¨¡æ‹Ÿæµ‹è¯•é¢˜è§£","slug":"190930test","date":"2019-10-01T03:57:51.000Z","updated":"2019-10-11T15:33:38.015Z","comments":true,"path":"190930test/","link":"","permalink":"http://ldxcaicai.github.io/190930test/","excerpt":"","text":"Aé¢˜æ„ç®€è¿°ï¼š ç»™å‡º $n$ ä¸ªé•¿åº¦ç›¸åŒçš„ä¸²ï¼Œç°åœ¨åœ¨è¿™ $n$ ä¸ªä¸²ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªä½œä¸ºç­”æ¡ˆä¸²ï¼Œç„¶åä½ ç°åœ¨æ¯æ¬¡éšæœºçŒœä¸€ä¸ªä¹‹å‰æœªçŒœè¿‡çš„ä½ç½®ï¼Œåœ¨èƒ½å¤Ÿå‡­å€Ÿå·²æœ‰çš„ä¿¡æ¯ç¡®å®šå‡ºç­”æ¡ˆä¸²çš„æ—¶å€™æ¸¸æˆç»“æŸï¼Œé—®çŒœä½ç½®çš„æœŸæœ›æ¬¡æ•° æ•°æ®èŒƒå›´ï¼š $n\\le50$ $len\\le20$ è§£é¢˜æ€è·¯ï¼š è€ƒè™‘ä¸€ä¸ª $O(nl2^l)$ çš„æš´åŠ›çŠ¶å‹ $dp$ ï¼Œå³æšä¸¾ç­”æ¡ˆä¸²æ˜¯å•¥ï¼Œç„¶å $f_{s}$ è¡¨ç¤ºè¯¥æƒ…å†µä¸‹çŒœè¿‡ä½ç½®é›†åˆä¸º $s$ æ—¶ç¦»ç»“æŸçš„æœŸæœ›æ­¥æ•°ï¼Œå¹¶ä»¤ $cnt$ æ˜¯å½“å‰é›†åˆçŒœè¿‡çš„ä½ç½®æ•°é‡ï¼Œé‚£ä¹ˆå¯ä»¥è¿›è¡Œå¦‚ä¸‹è½¬ç§»ï¼š é›†åˆ $s$ ä¸­çš„ä½ç½®å¯ä»¥åŒºåˆ†å‡ºç­”æ¡ˆä¸²å’Œå…¶ä½™ä¸²ï¼Œåˆ™æœ‰ $f_{s}=0$ é›†åˆ $s$ ä¸­çš„ä½ç½®ä¸èƒ½åŒºåˆ†å‡ºç­”æ¡ˆä¸²å’Œå…¶ä½™ä¸²ï¼Œé‚£ä¹ˆ $f_s=1+\\frac1{len-cnt}\\sum\\limits_{i,i\\not \\in s}f_{s\\cup i}$ è¿™æ ·å¯ä»¥æ‹¿åˆ° $60^+pts$ ç°åœ¨è€ƒè™‘ä¼˜åŒ–ï¼Œå®¹æ˜“å‘ç°å¯ä»¥æŠŠ $n$ ä¸ªä¸²å‹åœ¨ä¸€èµ·è½¬ç§»ï¼Œå…·ä½“æ¥è¯´ï¼Œè€ƒè™‘é¢„å¤„ç†å‡º $Cnt_s$ è¡¨ç¤ºé›†åˆ $s$ ä¸èƒ½åŒºåˆ†å¼€çš„ä¸²çš„ä¸ªæ•°ï¼Œè¿™æ ·ç¬¬äºŒç§è½¬ç§»å˜ä¸º $f_s=Cnt_s+\\frac1{len-cnt}\\sum\\limits_{i,i\\not \\in s}f_{s\\cup i}$ æœ€åç­”æ¡ˆä¸º $\\frac{f_0}n$ ï¼Œå› ä¸ºæˆ‘ä»¬æŠŠæ‰€æœ‰ä¸²å‹åœ¨äº†ä¸€èµ·å› æ­¤æœŸæœ›è¦å¸¦ä¸€ä¸ª $\\frac 1n$ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=1e5+5;int n,K,len;char s[55][25];double f[1&lt;&lt;20];int cnt[1&lt;&lt;20];bool vs[1&lt;&lt;20];ll sm[1&lt;&lt;20];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline double dfs(int sta,int ct)&#123; if(vs[sta])return f[sta]; vs[sta]=1,f[sta]=0; if(cnt[sta]==n)return f[sta]=0; int s=((1&lt;&lt;len)-1)^sta,t; while(s)&#123; t=lowbit(s); f[sta]+=dfs(sta|t,ct+1); s^=t; &#125; return (f[sta]/=(len-ct))+=n-cnt[sta];&#125;int main()&#123; n=read(); for(ri i=1;i&lt;=n;++i)len=Read(s[i]); for(ri i=1;i&lt;=n;++i)for(ri st=0,j=1;j&lt;=n;++j,st=0)if(i!=j)&#123; for(ri k=1;k&lt;=len;++k)if(s[i][k]==s[j][k])st|=1&lt;&lt;(k-1); sm[st]|=1ll&lt;&lt;(i-1); &#125; sm[0]=(1ll&lt;&lt;n)-1; for(ri a,b,s=(1&lt;&lt;len)-1;~s;--s)&#123; for(ri i=1;i&lt;=n;++i)if(!(sm[s]&gt;&gt;(i-1)&amp;1))++cnt[s]; a=s; while(a)&#123; b=lowbit(a); sm[s^b]|=sm[s]; a^=b; &#125; &#125; printf(\"%.10lf\",dfs(0,0)/n); return 0;&#125; Bé¢˜æ„ç®€è¿°ï¼š ç»™ä½  $n$ ä¸ªç‚¹ï¼Œç°åœ¨è¯¢é—® $m=1,2,3,\\cdots,n$ ä¸ªç‚¹çš„ç”Ÿæˆæ ‘ä¸ªæ•°ï¼Œå¦‚æœ $i$ åœ¨ç”Ÿæˆæ ‘é‡Œï¼Œå…¶åº¦æ•°ä¸è¶…è¿‡ $d_i$ æ•°æ®èŒƒå›´ï¼š $n\\le100$ è§£é¢˜æ€è·¯ï¼š è€ƒè™‘åˆ©ç”¨ $prufer$ åºåˆ—çš„å¦‚ä¸‹æ€§è´¨ï¼š å¯¹äºä¸€æ£µ $n$ ä¸ªç‚¹çš„æ ‘ï¼Œ $\\sum du_i=2n-2$ å¯¹äºä¸€æ£µ $n$ ä¸ªç‚¹çš„æ ‘ï¼Œæ¯ä¸ªç‚¹åœ¨ $prufer$ åºåˆ—ä¸­å‡ºç° $du_i-1$ æ¬¡ æ¯æ£µæ ‘å’Œå…¶ $prufer$ åºåˆ—æ»¡è¶³åŒå°„å…³ç³» é‚£ä¹ˆé—®é¢˜è½¬åŒ–æˆäº†ä¸€ä¸ªéå¸¸æ˜¾ç„¶çš„äºŒå…ƒç”Ÿæˆå‡½æ•°é—®é¢˜ï¼Œç”±äºæ•°æ®èŒƒå›´å¾ˆå°å¯ä»¥ç›´æ¥ç”¨èƒŒåŒ…ä»£æ›¿å¤šé¡¹å¼ä¹˜æ³• CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=1e9+7;typedef vector&lt;int&gt; poly;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;mod?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=105;int n,f[2][N][N],cur=0,C[N][N];inline void init()&#123; for(ri i=0;i&lt;=n;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j],C[i-1][j-1]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); f[cur=0][0][0]=1; init(); for(ri t=1,du;t&lt;=n;++t)&#123; cur^=1; du=read(); for(ri i=0;i&lt;=t;++i)for(ri j=0;j&lt;=n-2;++j)f[cur][i][j]=f[!cur][i][j]; for(ri i=0;i&lt;=t;++i)for(ri j=0;j&lt;=n-2;++j)if(f[!cur][i][j]) for(ri k=0;k&lt;du&amp;&amp;j+k&lt;=n-2;++k)Add(f[cur][i+1][j+k],mul(f[!cur][i][j],C[j+k][j])); &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;(i==1?n:f[cur][i][i-2])&lt;&lt;' '; return 0;&#125; Cé¢˜æ„ç®€è¿°ï¼š ç»™å‡ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¦æ±‚å¼ºåˆ¶åœ¨çº¿æ”¯æŒå¦‚ä¸‹æ“ä½œï¼š åœ¨å½“å‰ä¸²å°¾åŠ ä¸Šä¸€ä¸ªå­—ç¬¦ $c$ è¯¢é—®åŒºé—´ $[l,r]$ ä¸­çš„ä¸åŒå­ä¸²æ•° æ•°æ®èŒƒå›´ï¼š $n,m\\le50000$ è§£é¢˜æ€è·¯ï¼š æ˜¾ç„¶éœ€è¦è¡¥é›†è½¬åŒ–å˜æˆæ±‚é‡å¤å­ä¸²æ•°ï¼Œè€ƒè™‘å»ºå‡º $link-cut-parent$ $tree$ï¼Œç„¶åè€ƒè™‘åœ¨å­—ç¬¦ä¸²ç»“å°¾åŠ ä¸€ä¸ªå­—ç¬¦å¯¹å­ä¸²æ•°å½±å“ï¼Œå‘ç°å°±æ˜¯æŠŠå…¶å¯¹åº”åŠ¨æ€æ ‘ä¸Šçš„ä¸€æ¡é“¾çš„ä¿¡æ¯æ”¹æ‰ï¼Œè€Œå¯¹äº $endpos$ ç›¸åŒçš„é›†åˆå®ƒä»¬å¯¹åº”çš„å­ä¸²çš„å·¦ç«¯ç‚¹ä¹Ÿæ˜¯è¿ç»­çš„ï¼Œäºæ˜¯å¯ä»¥æŠŠ $endpos$ ç›¸åŒçš„æ”¾åˆ°ä¸€æ£µ $splay$ é‡Œï¼Œç„¶åæ¯æ¬¡åŠ ç‚¹å°±æˆäº† $access$ æ“ä½œï¼Œæ˜¾ç„¶èƒ½ç”¨ä¸»å¸­æ ‘è¾…åŠ©ç»´æŠ¤ç­”æ¡ˆ ä½†ç›´æ¥è¿™æ ·åšæœ‰ä¸ªå°æ¯›ç—…ï¼Œæ˜¯å¯¹äºç»´æŠ¤ç­”æ¡ˆä¿¡æ¯ä¸èƒ½éšæ„çš„è¿›è¡Œ $access$ æ“ä½œï¼Œäºæ˜¯ $cut$ æ“ä½œä¹Ÿä¸èƒ½ç”¨äº†ï¼Œè¿™æ ·çš„è¯åœ¨ $clone$ èŠ‚ç‚¹éœ€è¦å¼„ä¸€ä¸ªå° $trick$ ï¼Œå°±æ˜¯æ¯æ¬¡æˆ‘ä»¬å…ˆ $access$ æ–°çš„ $endpos$ å¯¹åº”çš„é“¾ï¼Œè¿™ä¸ªæ—¶å€™è¢« $clone$ çš„ç‚¹æˆä¸ºè™šå„¿å­ï¼Œå¯ä»¥ç›´æ¥å°† $cut$ å˜æˆæ¢çˆ¶äº²æ“ä½œ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=2e5+5,M=N*100;int lm;namespace sgt&#123; #define lc (son[p][0]) #define rc (son[p][1]) #define mid (l+r&gt;&gt;1) int son[M][2],tg[M],tot=0; ll ss[M]; inline void update(int&amp;o,int l,int r,int ql,int qr,int v)&#123; if(ql&gt;qr)return; int p=++tot; lc=son[o][0],rc=son[o][1],ss[p]=ss[o],tg[p]=tg[o]; o=p; ss[p]+=(ll)(min(qr,r)-max(ql,l)+1)*v; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;tg[p]+=v;return;&#125; if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); &#125; inline ll query(int p,int l,int r,int ql,int qr)&#123; if(!p)return 0ll; if(ql&lt;=l&amp;&amp;r&lt;=qr)return ss[p]; int res=(ll)(min(qr,r)-max(ql,l)+1)*tg[p]; if(qr&lt;=mid)return res+query(lc,l,mid,ql,qr); if(ql&gt;mid)return res+query(rc,mid+1,r,ql,qr); return res+query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); &#125; #undef mid #undef lc #undef rc&#125;int rt[N],n;namespace lct&#123; #define lc (son[p][0]) #define rc (son[p][1]) int son[N][2],fa[N],edpos[N],tg[N],len[N]; inline void pushnow(int p,int v)&#123;tg[p]=edpos[p]=v;&#125; inline void pushdown(int p)&#123;tg[p]&amp;&amp;(pushnow(lc,tg[p]),pushnow(rc,tg[p]),tg[p]=0);&#125; inline bool isroot(int x)&#123;return !fa[x]||((son[fa[x]][0]^x)&amp;&amp;(son[fa[x]][1]^x));&#125; inline bool which(int x)&#123;return x==son[fa[x]][1];&#125; inline void rotate(int x)&#123; int y=fa[x],z=fa[y],t=which(x); if(!isroot(y))son[z][which(y)]=x; fa[x]=z,fa[y]=x,son[y][t]=son[x][t^1],son[x][t^1]=y; son[y][t]&amp;&amp;(fa[son[y][t]]=y); &#125; inline void splay(int x)&#123; static int stk[N],top=0; stk[top=1]=x; for(ri i=x;!isroot(i);i=fa[i])stk[++top]=fa[i]; while(top)pushdown(stk[top--]); while(!isroot(x))&#123; if(!isroot(fa[x]))rotate(which(x)^which(fa[x])?x:fa[x]); rotate(x); &#125; &#125; inline void access(int x,int ps)&#123; int y=0; for(;x;x=fa[y=x])&#123; splay(x),son[x][1]=y; edpos[x]&amp;&amp;(sgt::update(rt[ps],1,lm,edpos[x]-len[x]+1,edpos[x]-len[fa[x]],1),1); &#125; pushnow(y,ps); &#125; inline int queryid(int x)&#123;return splay(x),edpos[x];&#125; inline void link(int x,int y)&#123;splay(x),fa[x]=y;&#125; #undef lc #undef rc&#125;namespace sam&#123; int son[N][26],tot,last,len[N],link[N]; inline void init()&#123;tot=last=1;&#125; inline void insert(int x,int id)&#123; int np=++tot,p=last; rt[id]=rt[id-1]; last=np,lct::len[np]=len[np]=len[p]+1; while(p&amp;&amp;!son[p][x])son[p][x]=np,p=link[p]; if(!p)&#123;lct::link(np,link[np]=1),lct::access(np,id);return;&#125; int q=son[p][x],nq; if(len[q]==len[p]+1)&#123;lct::link(np,link[np]=q),lct::access(np,id);return;&#125; nq=++tot,len[nq]=lct::len[nq]=len[p]+1,memcpy(son[nq],son[q],sizeof(son[q])); lct::edpos[nq]=lct::queryid(q); lct::link(nq,link[nq]=link[q]); lct::link(np,link[np]=nq),lct::access(np,id); lct::link(q,link[q]=nq); while(p&amp;&amp;son[p][x]==q)son[p][x]=nq,p=link[p]; &#125;&#125;int D,m;char s[N],ch;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif D=read(),n=Read(s),m=read(); ll lastans=0; lm=m+n; sam::init(); for(ri i=1;i&lt;=n;++i)sam::insert(s[i]-'a',i); for(ri op,l,r;m;--m)&#123; op=read(); if(op==1)&#123; ch=gc(); while(!isalpha(ch))ch=gc(); ++n; sam::insert(((ll)(ch-'a')+lastans)%26,n); &#125; else&#123; l=(lastans-1+read())%n+1; r=(lastans-1+read())%n+1; cout&lt;&lt;(lastans=(((ll)(r-l+1)*(r-l+2)/2)-sgt::query(rt[r],1,lm,l,r)))&lt;&lt;'\\n'; &#125; lastans*=D; &#125; return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"è€ƒè¯•é¢˜è§£","slug":"è€ƒè¯•é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/è€ƒè¯•é¢˜è§£/"}]},{"title":"CodeForces 1208 ç®€è¦é¢˜è§£","slug":"CF1208","date":"2019-09-29T07:31:41.000Z","updated":"2019-10-22T23:48:12.081Z","comments":true,"path":"CF1208/","link":"","permalink":"http://ldxcaicai.github.io/CF1208/","excerpt":"","text":"AæŒ‰ç…§æ¨¡ $3$ ä½™æ•°åˆ†ç±»å³å¯ CODE 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read()&#123; #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;int a[3];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; a[0]=read(),a[1]=read(),a[2]=a[1]^a[0]; cout&lt;&lt;a[read()%3]&lt;&lt;'\\n'; &#125; return 0;&#125; BåŒæŒ‡é’ˆæ¨¡æ‹Ÿå³å¯ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read()&#123; #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=2005;int a[N],n;map&lt;int,int&gt;id;int cnt[N],sum=0;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int tot=0; for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); if(!id[a[i]])id[a[i]]=++tot; ++cnt[id[a[i]]]; if(cnt[id[a[i]]]==2)++sum; &#125; if(!sum)return puts(\"0\"),0; int ans=n; for(ri l=1;l&lt;=n;++l)&#123; for(ri r=l;r&lt;=n;++r)&#123; --cnt[id[a[r]]]; if(cnt[id[a[r]]]==1)--sum; if(!sum)ans=min(ans,r-l+1); &#125; for(ri r=l;r&lt;=n;++r)&#123; ++cnt[id[a[r]]]; if(cnt[id[a[r]]]==2)++sum; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; Cæ¯ $16$ ä¸ªæ•°ä¸ºä¸€ç»„æ„é€ å³å¯ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read()&#123; #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=2005;int n,ans[N][N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri l=0,r=15,a,b,i=0;i&lt;n;i+=4)for(ri j=0;j&lt;n;j+=4)&#123; a=i,b=j; ans[a][b]=l; ans[a][b+1]=l+1; ans[a+1][b]=l+2; ans[a+1][b+1]=l+3; a=i,b=j+2; l+=4; ans[a][b]=l+2; ans[a][b+1]=l+3; ans[a+1][b]=l; ans[a+1][b+1]=l+1; a=i+2,b=j; l+=4; ans[a][b]=l+1; ans[a][b+1]=l; ans[a+1][b]=l+3; ans[a+1][b+1]=l+2; a=i+2,b=j+2; l+=4; ans[a][b]=l+3; ans[a][b+1]=l+2; ans[a+1][b]=l+1; ans[a+1][b+1]=l; l+=4; &#125; for(ri i=0;i&lt;n;++i,puts(\"\"))for(ri j=0;j&lt;n;++j)cout&lt;&lt;ans[i][j]&lt;&lt;' '; return 0;&#125; Dç”¨ä¸ªçº¿æ®µæ ‘æ¨¡æ‹Ÿå³å¯ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read()&#123; #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline ll readl()&#123; #define gc getchar ll ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=2e5+5;int n,w;namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) ll ss[N&lt;&lt;2]; inline void build(int p,int l,int r)&#123; if(l==r)&#123;ss[p]=l;return;&#125; build(lc,l,mid),build(rc,mid+1,r); ss[p]=ss[lc]+ss[rc]; &#125; inline void update(int p,int l,int r,int k)&#123; if(l==r)&#123;ss[p]=0;return;&#125; if(k&lt;=mid)update(lc,l,mid,k); else update(rc,mid+1,r,k); ss[p]=ss[lc]+ss[rc]; &#125; inline int query(int p,int l,int r,ll v)&#123; if(l==r)return l; if(ss[lc]&gt;v)return query(lc,l,mid,v); return query(rc,mid+1,r,v-ss[lc]); &#125; #undef lc #undef rc #undef mid&#125;int a[N];ll s[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); sgt::build(1,1,n); for(ri i=1;i&lt;=n;++i)s[i]=readl(); for(ri i=n;i;--i)&#123; a[i]=sgt::query(1,1,n,s[i]); sgt::update(1,1,n,a[i]); &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;a[i]&lt;&lt;' '; return 0;&#125; Eè§‚å¯Ÿä¸€ä¸‹å‘ç°å¯ä»¥å¯¹æ¯ä¸€è¡Œç”¨çš„è´¡çŒ®ç”¨å•è°ƒé˜Ÿåˆ—/çº¿æ®µæ ‘/stè¡¨ç»Ÿè®¡ï¼Œä½†æ˜¯æœ€åè¦ç»Ÿè®¡ $m$ è¡Œçš„æ€»è´¡çŒ®ï¼Œç„¶åå‘ç°æ¯è¡Œçš„çŠ¶æ€æœ‰ä»¥ä¸‹å‡ ç±»ï¼š å¼€å§‹çš„å‰ $k$ ä¸ª ç»“å°¾çš„å‰ $k$ ä¸ª ä¸­é—´éƒ¨åˆ† è¿™ä¸‰æ®µçš„è´¡çŒ®æ˜¯ç±»ä¼¼çš„ï¼Œå¯ä»¥åˆ†ç±»+å·®åˆ†ç»Ÿè®¡ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=1e6+50;int n,w,a[N];ll ans[N],ad[N];namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) ll mx[N&lt;&lt;2]; inline void build(int p,int l,int r)&#123; if(l==r)&#123;mx[p]=a[l];return;&#125; build(lc,l,mid),build(rc,mid+1,r); mx[p]=max(mx[lc],mx[rc]); &#125; inline int query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return mx[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return max(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr)); &#125; #undef lc #undef rc #undef mid&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),w=read()+2; for(ri tt=1,m;tt&lt;=n;++tt)&#123; m=read(); for(ri i=2;i&lt;=m+1;++i)a[i]=read(); m+=2; a[1]=a[m]=0; sgt::build(1,1,m); if(w&lt;=m*3-1)for(ri i=1;i&lt;=w;++i)ans[i]+=sgt::query(1,1,m,max(1,i-w+m),min(i,m)); else&#123; for(ri i=1;i&lt;m;++i)ans[i]+=sgt::query(1,1,m,1,i); for(ri i=w;i&gt;w-m+1;--i)ans[i]+=sgt::query(1,1,m,m+i-w,m); ad[m]+=sgt::mx[1]; ad[w-m+2]-=sgt::mx[1]; &#125; &#125; for(ri i=1;i&lt;=w;++i)&#123; ad[i]+=ad[i-1]; ans[i]+=ad[i]; &#125; for(ri i=2;i&lt;=w-1;++i)cout&lt;&lt;ans[i]&lt;&lt;' '; return 0;&#125; Fç›´æ¥æš´åŠ›+äºŒè¿›åˆ¶æšä¸¾å­é›†æ›´æ–°å³å¯ï¼Œæ¯ä¸ªé›†åˆæœ€å¤šè¢«æ›´æ–°ä¸¤æ¬¡å› æ­¤å¤æ‚åº¦æ˜¯å¯¹çš„~ æ²¡æƒ³åˆ°å§ ç„¶åæ¯”èµ›çš„æ—¶å€™æ˜¯ä¸ªdd å…¶å®æˆ‘ç°åœ¨ä¹Ÿæ˜¯dd CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=1&lt;&lt;21|5;int cnt[N],a[N],n,lst[N],ans=0;inline void update(int vl,int ps)&#123; if(cnt[vl]&gt;=2||lst[vl]==ps)return; lst[vl]=ps,++cnt[vl]; for(ri i=21;~i;--i)if(vl&gt;&gt;i&amp;1)update(vl^(1&lt;&lt;i),ps);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); for(ri t,res,i=n;i;--i)&#123; if(i&lt;=n-2)&#123; t=((1&lt;&lt;22)-1)^a[i],res=0; for(ri j=21;~j;--j)if(t&gt;&gt;j&amp;1)if(cnt[res|(1&lt;&lt;j)]==2)res|=1&lt;&lt;j; ans=max(ans,res|a[i]); &#125; update(a[i],i); &#125; cout&lt;&lt;ans; return 0;&#125; Gé’¦å®šæ‰€æœ‰çš„å¤šè¾¹å½¢çš„æŸä¸€ä¸ªé¡¶ç‚¹é‡åˆä¸åŒä¸€ä¸ªç‚¹ï¼Œå‘ç°ä¹‹åå‡å¦‚è¦é€‰ $x,x\\ge3$ ï¼Œä¸” $x$ çš„æ‰€æœ‰çº¦æ•°å·²ç»è¢«é€‰ï¼Œé‚£ä¹ˆå®ƒä¼šå¢åŠ  $\\phi (x)$ ä¸ªç‚¹ ï¼Œç”±äºå¯¹äºæ¯ä¸ªæ•° $x$ å’Œå®ƒçš„å› å­ $y$ æ»¡è¶³ $\\phi(x)\\ge\\phi(y)$ ï¼Œå› æ­¤ç›´æ¥è€ƒè™‘æŠŠæ‰€æœ‰åˆæ³•çš„æ•°æŒ‰ç…§ $\\phi$ å€¼å¤§å°æ’åºè¿‡åè´ªå¿ƒé€‰æ‹©ï¼Œæ³¨æ„ç‰¹åˆ¤ä¸€ä¸‹ $k=1,2$ çš„æƒ…å†µ~ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef long long ll;const int N=2e6+5;int n,k,pri[N],tot=0,phi[N];bool vis[N];inline void init()&#123; phi[1]=1; for(ri i=2;i&lt;=n;++i)&#123; if(!vis[i])pri[++tot]=i,phi[i]=i-1; for(ri j=1;j&lt;=tot&amp;&amp;i*pri[j]&lt;=n;++j)&#123; vis[i*pri[j]]=1; if(i==i/pri[j]*pri[j])&#123; phi[i*pri[j]]=phi[i]*pri[j]; break; &#125; phi[i*pri[j]]=phi[i]*(pri[j]-1); &#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),k=read(); if(k==1)return puts(\"3\"),0; init(); sort(phi+3,phi+n+1); ll ans=0; for(ri i=3,j=1;j&lt;=k;++j,++i)ans+=phi[i]; cout&lt;&lt;ans+2; return 0;&#125; Hç¥ä»™ $DDP$ é¦–å…ˆè½¬åŒ–é—®é¢˜ï¼Œå‘ç°æ˜¯å½“ $b-r&lt;k$ æ—¶é¢œè‰²ä¸º $r$ è€ƒè™‘å¯¹æ¯ä¸ªç‚¹è§„å®šä¸€ä¸ªæ—¶é—´ $t(x)$ ,å¯¹äºå¶å­ç»“ç‚¹ï¼Œè¡¨ç¤ºç‚¹ $x$ åœ¨ $k\\ge t(x)$ æ—¶ä¼šå˜æˆ $r$ ï¼Œå¦‚æœé¢œè‰²ä¸º $r$ ï¼Œ $t(x)=-inf$ å¦åˆ™ $t(x)=inf$ ï¼Œå¯¹äºéå¶å­èŠ‚ç‚¹æ˜¾ç„¶å¯ä»¥æŠŠå®ƒå„¿å­çš„ä¿¡æ¯æ’å…¥åˆ°å¹³è¡¡æ ‘ä¸­ç„¶åé€šè¿‡è°ƒæ•´æ³•æ±‚å‡º $t(x)$ è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬åªéœ€è¦å¯¹äºä¸€ä¸ª $x$ ï¼Œåˆ¤æ–­å…¶ $t(x)$ å’Œ $k$ çš„å¤§å°å…³ç³»è¿›è€Œåˆ¤æ–­å®ƒçš„é¢œè‰² äºæ˜¯åªéœ€è¦è€ƒè™‘å¦‚ä½•ä¿®æ”¹å¶å­çš„é¢œè‰² ç»è¿‡æ€è€ƒå‘ç°å•çº¯çš„ $t(x)$ å¹¶ä¸å¥½åˆå¹¶ï¼Œäºæ˜¯æˆ‘ä»¬è¿›è¡Œå¦‚ä¸‹ç²¾å½©å˜æ¢ï¼š å¯¹æ ‘è¿›è¡Œé‡é“¾å‰–åˆ†ï¼Œå®šä¹‰ $t(x,0/1)$ è¡¨ç¤ºå½“ $x$ çš„é‡å„¿å­æ˜¯ $r/b$ çš„æ—¶å€™å®ƒæˆä¸º $r$ çš„æœ€å°æ—¶åˆ»ï¼Œè¿™æ ·å°±å¯ä»¥å°† $t(x,0/1)$ è¿›è¡Œåˆå¹¶ï¼Œè€Œè½»å„¿å­çš„ç»´æŠ¤æ²¿ç”¨ä¸Šè¿°å¹³è¡¡æ ‘åšæ³•å³å¯ CODE(fhq_treap) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef pair&lt;int,int&gt; pii;const int N=1e6+5;int rt[N],n;inline int rnd()&#123;return rand()|(rand()&lt;&lt;15);&#125;namespace bst&#123; #define lc (son[p][0]) #define rc (son[p][1]) int son[N][2],siz[N],vl[N],rd[N]; int stk[N],top=0,tot=0; inline int newidx()&#123;return ++tot;&#125; inline int newnode(int v)&#123; int p=newidx(); lc=rc=0,siz[p]=1,vl[p]=v,rd[p]=rnd(); return p; &#125; inline int pushup(int p)&#123;siz[p]=(!p?0:siz[lc]+1+siz[rc]);&#125; inline int merge(int a,int b)&#123; if(!a||!b)return a|b; if(rd[a]&lt;rd[b])return son[a][1]=merge(son[a][1],b),pushup(a),a; return son[b][0]=merge(a,son[b][0]),pushup(b),b; &#125; inline pii split(int p,int k)&#123; if(!p)return pii(0,0); pii res; if(siz[lc]&gt;=k)return res=split(lc,k),lc=res.se,pushup(p),pii(res.fi,p); return res=split(rc,k-siz[lc]-1),rc=res.fi,pushup(p),pii(p,res.se); &#125; inline int rank(int p,int v)&#123; if(!p)return 0; if(vl[p]&gt;v)return rank(lc,v); return siz[lc]+1+rank(rc,v); &#125; inline void insert(int&amp;rt,int v)&#123; int rk=rank(rt,v); pii x=split(rt,rk); rt=merge(merge(x.fi,newnode(v)),x.se); &#125; inline void delet(int&amp;rt,int v)&#123; int rk=rank(rt,v); pii x=split(rt,rk-1),y=split(x.se,1); rt=merge(x.fi,y.se),y.fi&amp;&amp;(stk[++top]=y.fi); &#125; #undef lc #undef rc&#125;struct F&#123; int l,r; F(int l=0,int r=0):l(l),r(r)&#123;&#125; friend inline F operator+(F a,F b)&#123;return F(min(max(a.l,b.l),a.r),min(max(a.l,b.r),a.r));&#125;&#125;;const int inf=1e9;int K,tg[N];int siz[N],hson[N],dep[N],top[N],fa[N],num[N],pred[N],bot[N],col[N],tot=0;vector&lt;int&gt;e[N];void dfs1(int p)&#123; siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==fa[p])continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]])hson[p]=v; &#125;&#125;void dfs2(int p,int tp)&#123; top[p]=tp,bot[tp]=p,pred[num[p]=++tot]=p; if(!hson[p])return; dfs2(hson[p],tp); for(ri i=0,v;i&lt;e[p].size();++i)if((v=e[p][i])!=fa[p]&amp;&amp;v!=hson[p])dfs2(v,v);&#125;namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) F vl[N&lt;&lt;2]; inline void pushup(int p)&#123;vl[p]=vl[lc]+vl[rc];&#125; inline F query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); &#125; inline bool check(int p,int k,int dt)&#123; int R=bst::rank(rt[p],k)+dt,B=bst::siz[rt[p]]+1-R; return B-R&lt;k; &#125; inline void fix(int p,int&amp;k,int dt)&#123; while(check(p,k-1,dt))--k; while(!check(p,k,dt))++k; &#125; inline void getval(int p,int k)&#123; if(col[k]==1)vl[p]=F(inf,inf); else if(!col[k])vl[p]=F(-inf,-inf); else&#123; fix(k,vl[p].l,1); fix(k,vl[p].r,0); &#125; &#125; inline void build(int p,int l,int r)&#123; if(l==r)&#123; int k=pred[l]; getval(p,k); if(k==top[k]&amp;&amp;fa[k])&#123; if(bot[k]==k)bst::insert(rt[fa[k]],tg[k]=vl[p].l); else bst::insert(rt[fa[k]],tg[k]=(vl[p]+query(1,1,n,l+1,num[bot[k]])).l); &#125; return; &#125; build(rc,mid+1,r),build(lc,l,mid); pushup(p); &#125; inline void update(int p,int l,int r,int k)&#123; if(l==r)return getval(p,pred[l]); k&lt;=mid?update(lc,l,mid,k):update(rc,mid+1,r,k); pushup(p); &#125; #undef mid #undef lc #undef rc&#125;inline void change(int p)&#123; int tp,ftp; while(p)&#123; tp=top[p],ftp=fa[top[p]]; sgt::update(1,1,n,num[p]); if(ftp)&#123; bst::delet(rt[ftp],tg[tp]); bst::insert(rt[ftp],tg[tp]=sgt::query(1,1,n,num[tp],num[bot[tp]]).l); &#125; p=ftp; &#125;&#125;int main()&#123; srand(time(NULL)); #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; for(ri i=1;i&lt;=n;++i)col[i]=read(); dfs1(1),dfs2(1,1); sgt::build(1,1,n); for(ri op,x,tt=read();tt;--tt)&#123; op=read(); switch(op)&#123; case 1:&#123;x=read(),cout&lt;&lt;(sgt::query(1,1,n,num[x],num[bot[top[x]]]).l&gt;K)&lt;&lt;'\\n';break;&#125; case 2:&#123;x=read(),col[x]=read(),change(x);break;&#125; case 3:&#123;K=read();break;&#125; &#125; &#125; return 0;&#125; CODE(pbds) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;#include&lt;ext/pb_ds/assoc_container.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;template &lt;class T&gt;using Tree=tree&lt;T,null_type,less&lt;T&gt;,rb_tree_tag,tree_order_statistics_node_update&gt;;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef pair&lt;int,int&gt; pii;inline pii operator+(pii a,pii b)&#123;return pii(min(max(a.fi,b.fi),a.se),min(max(a.fi,b.se),a.se));&#125;const int N=3e5+5;const int inf=1e9;int n,K,tg[N];int siz[N],hson[N],dep[N],top[N],fa[N],num[N],pred[N],bot[N],col[N],tot=0;vector&lt;int&gt;e[N];Tree&lt;pii&gt;T[N];decltype(begin(T[0])) D[N];namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) pii vl[N&lt;&lt;2]; inline int rank(const Tree&lt;pii&gt; &amp;A,const int &amp;x)&#123; return A.order_of_key(pii(x,inf)); &#125; inline void pushup(int p)&#123;vl[p]=vl[lc]+vl[rc];&#125; inline pii query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); &#125; inline bool check(int p,int k,int dt)&#123; int R=rank(T[p],k)+dt,B=(int)(T[p].size())+1-R; return B-R&lt;k; &#125; inline void fix(int p,int&amp;k,int dt)&#123; while(check(p,k-1,dt))--k; while(!check(p,k,dt))++k; &#125; inline void getval(int p,int k)&#123; if(col[k]==1)vl[p]=pii(inf,inf); else if(!col[k])vl[p]=pii(-inf,-inf); else&#123; fix(k,vl[p].fi,1); fix(k,vl[p].se,0); &#125; &#125; inline void build(int p,int l,int r)&#123; if(l==r)&#123; int k=pred[l]; getval(p,k); if(k==top[k]&amp;&amp;k!=1)D[k]=T[fa[k]].insert(pii(bot[k]==k?vl[p].fi:(vl[p]+query(1,1,n,l+1,num[bot[k]])).fi,k)).fi; return; &#125; build(rc,mid+1,r),build(lc,l,mid); pushup(p); &#125; inline void update(int p,int l,int r,int k)&#123; if(l==r)return getval(p,pred[l]); k&lt;=mid?update(lc,l,mid,k):update(rc,mid+1,r,k); pushup(p); &#125; #undef mid #undef lc #undef rc&#125;void dfs1(int p)&#123; siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==fa[p])continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]])hson[p]=v; &#125;&#125;void dfs2(int p,int tp)&#123; top[p]=tp,bot[tp]=p,pred[num[p]=++tot]=p; if(!hson[p])return; dfs2(hson[p],tp); for(ri i=0,v;i&lt;e[p].size();++i)if((v=e[p][i])!=fa[p]&amp;&amp;v!=hson[p])dfs2(v,v);&#125;inline void change(int p)&#123; int tp,ftp; while(p)&#123; ftp=fa[tp=top[p]]; sgt::update(1,1,n,num[p]); if(ftp)&#123; T[ftp].erase(D[tp]); D[tp]=T[ftp].insert(pii(sgt::query(1,1,n,num[tp],num[bot[tp]]).fi,tp)).fi; &#125; p=ftp; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; for(ri i=1;i&lt;=n;++i)col[i]=read(); dfs1(1),dfs2(1,1); sgt::build(1,1,n); for(ri op,x,tt=read();tt;--tt)&#123; op=read(); switch(op)&#123; case 1:&#123;x=read(),cout&lt;&lt;(sgt::query(1,1,n,num[x],num[bot[top[x]]]).fi&gt;K)&lt;&lt;'\\n';break;&#125; case 2:&#123;x=read(),col[x]=read(),change(x);break;&#125; case 3:&#123;K=read();break;&#125; &#125; &#125; return 0;&#125; å‘Šè¾","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"CometOJæ¨¡æ‹Ÿèµ›æµ‹è¯•Day2 ç®€è¦é¢˜è§£","slug":"COJ70","date":"2019-09-28T15:35:27.000Z","updated":"2019-10-11T15:33:23.915Z","comments":true,"path":"COJ70/","link":"","permalink":"http://ldxcaicai.github.io/COJ70/","excerpt":"","text":"21:10åˆ†è¿›å…¥æ¯”èµ›ç•Œé¢ç»“æœæ‰‹é€Ÿæ…¢äº†Cæ²¡å†™å®Œ100+100+0æ»šäº† Aè²Œä¼¼å½’å¹¶å°±è¡Œäº†ã€‚ã€‚ã€‚ ä½†æˆ‘æ¯”è¾ƒæ™ºéšœå†™äº†ä¸ªé“¾è¡¨ï¼Œå‡‘åˆçœ‹çœ‹å§~ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=1e5+5;int pre[N],suf[N],n,b[N],m;inline void delet(int x)&#123; suf[pre[x]]=suf[x]; pre[suf[x]]=pre[x];&#125;int main()&#123; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)pre[i]=i-1,suf[i]=i+1; suf[0]=1,pre[n+1]=n; for(ri i=1;i&lt;=m;++i)delet(b[i]=read()); int ps=1; while(ps&lt;=m)&#123; int p=suf[0]; while(p!=n+1&amp;&amp;p&lt;b[ps])cout&lt;&lt;p&lt;&lt;'\\n',p=suf[p]; for(ri i=pre[p];i;i=pre[i])delet(i); cout&lt;&lt;b[ps]&lt;&lt;'\\n'; ++ps; &#125; for(ri i=suf[0];i!=n+1;i=suf[i])cout&lt;&lt;i&lt;&lt;'\\n'; return 0;&#125; Bè€ƒè™‘ç”¨ $trie$ å°†æ‰€æœ‰å­—ç¬¦ä¸²ä»å°åˆ°å¤§æ’åºï¼Œç„¶åé—®é¢˜è½¬åŒ–æˆä¸ºä¸€ä¸ªæ’åˆ—åœ¨å…¨æ’åˆ—ä¸­çš„æ’å æˆ‘å¹¶ä¸ä¼šåº·æ‹“å±•å¼€ç„¶åè·‘å»rushäº†ä¸€ä¸ªbit CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int mod=1e9+7;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;const int N=1e6+5;char s[N];int son[N][26],rk[N],cnt=0,ed[N];int tot=1;inline void insert(char*s,int len,int idx)&#123; int p=1; for(ri x,i=1;i&lt;=len;++i)&#123; x=s[i]-'a'; if(!son[p][x])son[p][x]=++tot; p=son[p][x]; &#125; ed[p]=idx;&#125;void dfs(int p)&#123; if(ed[p])rk[ed[p]]=++cnt; for(ri i=0;i&lt;26;++i)if(son[p][i])dfs(son[p][i]);&#125;int n,k,a[N],top=0,fac[N],ifac[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)fac[i]=mul(fac[i-1],i),ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int A(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],ifac[n-m]);&#125;int bit[N];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void update(int x,int v)&#123;for(ri i=x;i&lt;=n;i+=lowbit(i))bit[i]+=v;&#125;inline int query(int x)&#123;int ret=0;for(ri i=x;i;i-=lowbit(i))ret+=bit[i];return ret;&#125;int main()&#123; n=read(),k=read(); for(ri i=1,len;i&lt;=n;++i)len=Read(s),insert(s,len,i); dfs(1); int p=1,len=Read(s); for(ri i=1;i&lt;=len;++i)&#123; p=son[p][s[i]-'a']; if(ed[p])&#123; ++top; a[top]=rk[ed[p]]; p=1; &#125; &#125; init(); int res=0; for(ri i=1;i&lt;=k;++i)&#123; Add(res,mul(a[i]-1-query(a[i]),A(n-i,k-i))); update(a[i],1); &#125; cout&lt;&lt;res+1; return 0;&#125; Cæ„Ÿè§‰è¿˜æ²¡ $Day1çš„C$ éš¾ ç›´æ¥è€ƒè™‘æšä¸¾åˆ å»çš„åˆ—çš„çŠ¶æ€ï¼Œç„¶ååªç”¨çœ‹å¯è¡Œçš„ä¿ç•™è¡Œçš„æ•°é‡ï¼Œè¿™ä¸ªç›´æ¥å‹ä¸€ä¸‹æ¯ä¸¤è¡Œæ¯ä¸ªä½ç½®çš„å¤§å°çŠ¶æ€ç„¶å $f_{i,j}$ è¡¨ç¤ºå‰ $i$ è¡Œä¸€å®šä¿ç•™ç¬¬ $i$ è¡Œçš„æ–¹æ¡ˆæ•° é€šè¿‡å•æ¬¡é€šè¿‡é¢„å¤„ç†+æ‰“æ—¶é—´æ ‡è®°å¯ä»¥åšåˆ° $O(n^2)dp$ ç„¶åæˆ‘æ˜¯ä¸ª $zz$ ï¼Œå…ˆå†™äº†ä¸€ä¸ªä»¥ä¸ºæ˜¯ $O(n^3)$ çš„ $O(n^4)dp$ ç„¶ååªæœ‰ $90pts$ å”‰æ€ä¹ˆä¼šæœ‰90pts CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int n,m,p,q;int a[25][25];int b[25][25];ll f[25][25];inline bool check(int x,int y,int z)&#123; for(ri i=1;i&lt;=q;++i)if((b[x][i]&gt;b[y][i])^(b[y][i]&gt;b[z][i]))return 0; return 1;&#125;int main()&#123; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s)&#123; X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i)&#123; bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]]))&#123;ff=0;break;&#125; if(ff)X.pb(i); &#125; p=X.size(),q=Y.size(); for(ri i=0;i&lt;X.size();++i)for(ri j=0;j&lt;Y.size();++j)b[i+1][j+1]=a[X[i]][Y[j]]; res+=p; for(ri i=1;i&lt;=p;++i)&#123; for(ri j=i+1;j&lt;=p;++j)&#123; f[i][j]=1; for(ri k=i-1;k;--k)&#123; if(check(k,i,j))f[i][j]+=f[k][i]; &#125; res+=f[i][j]; &#125; &#125; &#125; cout&lt;&lt;res; return 0;&#125; ç„¶åå‘ç°äº‹æƒ…ä¸å¯¹ï¼Œæ”¹æˆäº† $O(n^3)$ çš„ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int n,m,p,q;int a[25][25];int b[25][25];ll f[25][25],ban[25][25];inline ll calc(int x,int y)&#123; ll res=0; for(ri i=1;i&lt;=q;++i)res+=(1ll*(b[x][i]&gt;b[y][i]))&lt;&lt;(i-1); return res;&#125;int main()&#123; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s)&#123; X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i)&#123; bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]]))&#123;ff=0;break;&#125; if(ff)X.pb(i); &#125; p=X.size(),q=Y.size(); for(ri i=0;i&lt;X.size();++i)for(ri j=0;j&lt;Y.size();++j)b[i+1][j+1]=a[X[i]][Y[j]]; res+=p; for(ri i=1;i&lt;=p;++i)for(ri j=i+1;j&lt;=p;++j)ban[i][j]=calc(i,j); for(ri i=1;i&lt;=p;++i)&#123; for(ri j=i+1;j&lt;=p;++j)&#123; f[i][j]=1; for(ri k=i-1;k;--k)if(ban[k][i]==ban[i][j])f[i][j]+=f[k][i]; res+=f[i][j]; &#125; &#125; &#125; cout&lt;&lt;res; return 0;&#125; ç„¶åå‘ç°è¢«å¡å¸¸äº†ï¼ŒåŠ äº†ä¸ªæ—¶é—´æ ‡è®°æ”¹æˆäº†ä»¥ä¸ºæ˜¯ $O(n^2)$ çš„ $O(n^3)dp$ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int n,m,p,q;int a[25][25];int b[25][25],tim[21][1&lt;&lt;20|5],Tim=0;int f[21][1&lt;&lt;20|5];int ban[25][25];inline int calc(int x,int y)&#123; int res=0; for(ri i=1;i&lt;=q;++i)res+=(b[x][i]&gt;b[y][i])&lt;&lt;(i-1); return res;&#125;inline int query(int x,int y)&#123;return tim[x][y]^Tim?0ll:f[x][y];&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s)&#123; X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i)&#123; bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]]))&#123;ff=0;break;&#125; if(ff)X.pb(i); &#125; p=X.size(),q=Y.size(); for(ri i=0;i&lt;X.size();++i)for(ri j=0;j&lt;Y.size();++j)b[i+1][j+1]=a[X[i]][Y[j]]; res+=p; ++Tim; for(ri i=1;i&lt;=p;++i)&#123; for(ri j=i+1;j&lt;=p;++j)&#123; ban[i][j]=calc(i,j); if(tim[j][ban[i][j]]^Tim)tim[j][ban[i][j]]=Tim,f[j][ban[i][j]]=0; f[j][ban[i][j]]+=query(i,ban[i][j])+1; res+=query(i,ban[i][j])+1; &#125; &#125; &#125; cout&lt;&lt;res; return 0;&#125; æœ€åç»ˆäºè¿‡äº† CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int n,m,p,q;int a[25][25];int b[25][25],tim[21][1&lt;&lt;20|5],Tim=0;int f[21][1&lt;&lt;20|5];int ban[25][25];inline int calc(int x,int y)&#123; int res=0; for(ri i=1;i&lt;=m;++i)res+=(a[x][i]&gt;a[y][i])&lt;&lt;(i-1); return res;&#125;inline int query(int x,int y)&#123;return tim[x][y]^Tim?0:f[x][y];&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); for(ri i=1;i&lt;=n;++i)for(ri j=i+1;j&lt;=n;++j)ban[i][j]=calc(i,j); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s)&#123; X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i)&#123; bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]]))&#123;ff=0;break;&#125; if(ff)X.pb(i); &#125; p=X.size(),q=Y.size(); res+=p; ++Tim; for(ri i=1,ss;i&lt;=p;++i)&#123; for(ri j=i+1;j&lt;=p;++j)&#123; ss=ban[X[i-1]][X[j-1]]&amp;((up-1)^s); (tim[j][ss]^Tim)&amp;&amp;(tim[j][ss]=Tim,f[j][ss]=0); f[j][ss]+=query(i,ss)+1; res+=query(i,ss)+1; &#125; &#125; &#125; cout&lt;&lt;res; return 0;&#125; è¢«å…¨åœºåŠæ‰“äº†ï¼Œå‘Šè¾","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"CometOJæ¨¡æ‹Ÿèµ›æµ‹è¯•Day1 ç®€è¦é¢˜è§£","slug":"COJ69","date":"2019-09-28T02:27:35.000Z","updated":"2019-10-11T15:33:25.061Z","comments":true,"path":"COJ69/","link":"","permalink":"http://ldxcaicai.github.io/COJ69/","excerpt":"","text":"NMDå› ä¸ºç½‘ç»œåŸå› äº¤é”™äº†é¢˜ï¼Œæœ€åå¯¼è‡´B,Cçˆ†ç‚¸äº† Aæˆ‘çš„ä¹±æåšæ³•ï¼š å…ˆå–å¯¹æŠŠä¹˜æ³•è½¬åŒ–æˆåŠ æ³•ï¼Œç„¶åæ‰“è¡¨æ±‚å‡ºæ¯ä¸ªæ•°çš„ä¸è¶…è¿‡å…¶ä¸€åŠçš„æœ€å¤§çš„æœ€ä¼˜å†³ç­–ç‚¹ å‘ç°å†³ç­–æ¨¡ $6$ ä¹‹åæœ‰è§„å¾‹ï¼Œå»ºç«‹ä¸€ä¸ª $solve(x)$ å‡½æ•°ï¼š $x\\le3$ ï¼Œè¿”å› $x$ $(x-3)\\%6&lt;4$ ï¼Œè¿”å› $solve(x/2)*solve(x-x/2)$ $(x-3)\\%6&gt;=4$ ï¼Œè¿”å› $solve(x/2-1)*solve(x-x/2+1)$ ç„¶ååŠ ä¸ªè®°å¿†åŒ–å°±èƒ½è¿‡äº† CODE 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;map&lt;ll,int&gt;S;ll n;const int mod=1e9+7;inline int solve(ll n)&#123; if(S.count(n))return S[n]; if(n&lt;=3)return S[n]=n; int t=(n-4)%6; if(t&gt;=4)return S[n]=1ll*solve(n/2-1)*solve(n-n/2+1)%mod; return S[n]=1ll*solve(n/2)*solve(n-n/2)%mod;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif cin&gt;&gt;n; cout&lt;&lt;solve(n); return 0;&#125; Bä¸€é“çº¯æ¨¡æ‹Ÿé¢˜ï¼Œåˆ†å¦‚ä¸‹å‡ ç±»éšä¾¿è®¨è®ºä¸€ä¸‹ï¼š å½¢å¦‚ â€œ###â€ æˆ–è€… â€œ##.â€ ï¼Œé‚£ä¹ˆè¿™ä¸¤ç§æƒ…å†µåªéœ€è€ƒè™‘å®ƒä»¬å‰é¢çš„æœ€ä¼˜å€¼ å½“å‰èº«ä¸Šæœ‰ $2$ ä¸ªå¹²æ‰°å™¨ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥æ‰«ä¸€éæ±‚ç­”æ¡ˆï¼Œ $Ans=å¹²æ‰°å™¨ä¸ªæ•°-$â€##â€œ$ä¸ªæ•°$ å½“å‰èº«ä¸Šæœ‰ $1$ ä¸ªå¹²æ‰°å™¨ï¼Œä¸”å‰é¢æœ‰ä¸€ä¸ªå½¢å¦‚ â€œ*#â€ çš„ï¼Œ é‚£ä¹ˆç­”æ¡ˆè·Ÿç¬¬äºŒç§æƒ…å†µç›¸åŒ è¿˜æœ‰å‡ ç±»æ¯”è¾ƒå®¹æ˜“çš„å°±ä¸åˆ—å‡ºæ¥äº†ã€‚ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='.'&amp;&amp;ch!='*'&amp;&amp;ch!='#')ch=gc(); while(ch=='.'||ch=='*'||ch=='#')s[++top]=ch,ch=gc(); return top;&#125;const int N=3e6+5;char s[N];int n;inline int calc(int l,int r)&#123; int res=0; for(ri i=l;i&lt;=r;++i)if(s[i]=='*')++res; for(ri i=l;i&lt;r;++i)if(s[i]=='#'&amp;&amp;s[i+1]=='#')--res; return res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=Read(s); s[n+1]=s[n+2]='#'; for(ri i=1;i&lt;=n;++i)&#123; if(s[i]=='#'&amp;&amp;s[i+1]=='#'&amp;&amp;s[i+2]!='*')&#123; n=i-1; break; &#125; &#125; int res=0; for(ri ff=0,ct=0,i=1;i&lt;=n;++i)&#123; if(s[i]=='.')continue; if(s[i]=='*')&#123; ++ct,res=max(res,ct); if(ct==2)&#123; res=calc(1,n); break; &#125; if(ff)&#123; res=calc(1,n); break; &#125; continue; &#125; if(s[i]=='#')&#123; if(!ct)&#123; if(s[i+1]!='*')break; ff=0; continue; &#125; else&#123; if(s[i+1]=='#')&#123; ff=0; i+=2; continue; &#125; --ct,ff=1; continue; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125; Cä¸€é“æ¯”è¾ƒå®¹æ˜“çš„ $dp$ è€ƒè™‘æšä¸¾æ–­è¾¹ç„¶åå¤„ç†å‡ºä¸¤ä¸ªè¿é€šå—çš„è·¯å¾„å’Œæœ€å€¼ç„¶åä¹˜èµ·æ¥æ›´æ–°ç­”æ¡ˆï¼Œä¸‹é¢é‚£ä¸ªè¿é€šå—çš„ç­”æ¡ˆå¯ä»¥ç›´æ¥ $O(n)$ æ ‘å½¢ $dp$ ä¸€éå¾—åˆ°ï¼Œè€Œä¸Šé¢çš„ç»´æŠ¤ç­”æ¡ˆå¦‚æœä¸æƒ³ç¹æ‚è®¨è®ºçš„è¯å¯ä»¥å¯¹æ¯ä¸ªç‚¹æä¸ªå¯åˆ å †/multisetï¼Œä¸è¿‡ä¸å¼€ $O2$ ä¼šè¢«å¡æ‰ å¦åˆ™å¯ä»¥ç»´æŠ¤å„¿å­ç­”æ¡ˆå‰åç¼€çš„ $min/max$ æ¥å®ç°å¯åˆ å †ä¸€æ ·çš„ä¸œè¥¿ï¼Œä½†è¿™ç§ $O(n)$ çš„åšæ³•ä¹Ÿè¢«å¡ $TLE$ äº†ä¸€ä¸ªç‚¹ï¼Œéœ€è¦æ‰‹åŠ¨ $O2$ å¯åˆ å † 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=2e5+5;int n,dep[N],mn[N],mx[N],fmn[N],fmx[N],gmx[N],gmn[N];typedef pair&lt;int,int&gt; pii;vector&lt;pii&gt;e[N];struct Q1&#123; priority_queue&lt;int&gt;a,b; inline void push(int x)&#123;a.push(x);&#125; inline void del(int x)&#123;b.push(x);&#125; inline int top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline int stop()&#123;int t=top(),ret;return pop(),ret=top(),a.push(t),ret;&#125; inline int size()&#123;return a.size()-b.size();&#125;&#125;S1[N],Mx[N];struct Q2&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;a,b; inline void push(int x)&#123;a.push(x);&#125; inline void del(int x)&#123;b.push(x);&#125; inline int top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline int stop()&#123;int t=top(),ret;return pop(),ret=top(),a.push(t),ret;&#125; inline int size()&#123;return a.size()-b.size();&#125;&#125;S2[N],Mn[N];void dfs1(int p,int fa)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; dfs1(v,p); S1[p].push(S1[v].top()+e[p][i].se); S2[p].push(S2[v].top()+e[p][i].se); &#125; mx[p]=S1[p].top()+S1[p].stop(); mn[p]=S2[p].top()+S2[p].stop(); for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; mx[p]=max(mx[p],mx[v]); mn[p]=min(mn[p],mn[v]); Mx[p].push(mx[v]); Mn[p].push(mn[v]); &#125;&#125;ll res=0;void dfs2(int p,int fa)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; S1[p].del(S1[v].top()+e[p][i].se); S2[p].del(S2[v].top()+e[p][i].se); Mx[p].del(mx[v]); Mn[p].del(mn[v]); fmx[v]=max(0,max(fmx[p],S1[p].top())+e[p][i].se); fmn[v]=min(0,min(fmn[p],S2[p].top())+e[p][i].se); gmx[p]=max(gmx[fa],Mx[p].top()); gmx[p]=max(gmx[p],max(S1[p].stop(),fmx[p])+S1[p].top()); gmn[p]=min(gmn[fa],Mn[p].top()); gmn[p]=min(gmn[p],min(S2[p].stop(),fmn[p])+S2[p].top()); res=max(res,(ll)mx[v]*gmx[p]); res=max(res,(ll)mn[v]*gmn[p]); dfs2(v,p); S1[p].push(S1[v].top()+e[p][i].se); S2[p].push(S2[v].top()+e[p][i].se); Mx[p].push(mx[v]); Mn[p].push(mn[v]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); &#125; for(ri i=1;i&lt;=n;++i)S1[i].push(0),S1[i].push(0),S2[i].push(0),S2[i].push(0),Mn[i].push(0),Mx[i].push(0); dfs1(1,0); dfs2(1,0); cout&lt;&lt;res; return 0;&#125; å‰åç¼€max 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=2e5+5;int n,mx[N],fmx[N],gmx[N],dmx[N];typedef pair&lt;int,int&gt; pii;vector&lt;pii&gt;e[N];struct Mxx&#123; int mx,sx; Mxx(int mx=0,int sx=0):mx(mx),sx(sx)&#123;&#125; friend inline Mxx operator+(Mxx a,Mxx b)&#123;return Mxx(max(a.mx,b.mx),a.mx&gt;b.mx?max(a.sx,b.mx):max(a.mx,b.sx));&#125;&#125;;vector&lt;Mxx&gt;pmx[N],smx[N],Pmx[N],Smx[N];inline void init(int p,int fa)&#123; int n=e[p].size(); pmx[p].resize(n+1),smx[p].resize(n+1); Pmx[p].resize(n+1),Smx[p].resize(n+1); for(ri vl,i=1,ps=1;i&lt;=n;++i,++ps)&#123; if(e[p][i-1].fi==fa)&#123;--ps;continue;&#125; vl=dmx[e[p][i-1].fi]+e[p][i-1].se; pmx[p][ps]=pmx[p][ps-1]+Mxx(max(vl,0),0); vl=mx[e[p][i-1].fi]; Pmx[p][ps]=Pmx[p][ps-1]+Mxx(max(vl,0),0); &#125; for(ri vl,i=n,ps=n-1;i;--i,--ps)&#123; if(e[p][i-1].fi==fa)&#123;++ps;continue;&#125; vl=dmx[e[p][i-1].fi]+e[p][i-1].se; smx[p][ps]=smx[p][ps+1]+Mxx(max(vl,0),0); vl=mx[e[p][i-1].fi]; Smx[p][ps]=Smx[p][ps+1]+Mxx(max(vl,0),0); &#125;&#125;void dfs1(int p,int fa)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; dfs1(v,p); &#125; init(p,fa); dmx[p]=smx[p][1].mx; mx[p]=max(smx[p][1].mx+smx[p][1].sx,Smx[p][1].mx);&#125;ll res=0;void dfs2(int p,int fa)&#123; Mxx mx1,mx2; for(ri i=0,v,ps=1;i&lt;e[p].size();++i,++ps)&#123; if((v=e[p][i].fi)==fa)&#123;--ps;continue;&#125; mx1=pmx[p][ps-1]+smx[p][ps+1]; mx2=Pmx[p][ps-1]+Smx[p][ps+1]; fmx[v]=max(0,max(fmx[p],mx1.mx)+e[p][i].se); gmx[p]=max(gmx[fa],mx2.mx); gmx[p]=max(gmx[p],max(mx1.sx,fmx[p])+mx1.mx); res=max(res,(ll)mx[v]*gmx[p]); dfs2(v,p); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); &#125; e[1].pb(pii(0,0)); dfs1(1,0); dfs2(1,0); for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;e[i].size();++j)e[i][j].se*=-1; dfs1(1,0); dfs2(1,0); cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"æ¯”èµ›é¢˜è§£","slug":"æ¯”èµ›é¢˜è§£","permalink":"http://ldxcaicai.github.io/tags/æ¯”èµ›é¢˜è§£/"}]},{"title":"Linear programming","slug":"LP","date":"2019-09-27T02:20:44.000Z","updated":"2019-10-11T15:33:21.577Z","comments":true,"path":"LP/","link":"","permalink":"http://ldxcaicai.github.io/LP/","excerpt":"","text":"çº¿æ€§è§„åˆ’ä¸¤ç§å¸¸è§å½¢å¼çš„è½¬åŒ–æ ‡å‡†å‹ï¼š \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j\\le b_i\\\\ &x_i\\ge0 \\end{aligned}æ¾å¼›å‹ï¼š \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j= b_i\\\\ &x_i\\ge0 \\end{aligned}ä¸‹é¢æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„æ ‡å‡†å‹è½¬æ¾å¼›å‹å¥—è·¯ï¼š åŸçº¿æ€§è§„åˆ’ï¼š \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j\\le b_i\\\\ &x_i\\ge0 \\end{aligned}ä»¤ $x_{i+m}=b_i-\\sum\\limits_{j=1}^na_{i,j}x_j\\ge 0$ é‚£ä¹ˆæœ‰æ–°çš„çº¿æ€§è§„åˆ’ï¼š \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j+x_{i+m}=b_i\\\\ &x_i\\ge0 \\end{aligned}å•çº¯å½¢æ³•æ±‚è§£çº¿æ€§è§„åˆ’å°†ä¸Šé¢çš„æ¾å¼›å‹çº¿æ€§è§„åˆ’è¿›è¡Œç§»é¡¹ï¼š \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&x_{i+m}=b_i-\\sum\\limits_{j=1}^na_{i,j}x_j\\\\ &x_i\\ge0 \\end{aligned}ç„¶åä¸€ç›´é‡å¤ä¸‹é¢çš„æ“ä½œï¼š åœ¨ç›®æ ‡å‡½æ•°ä¸­æ‰¾å‡ºä¸€ä¸ª $c_e&gt;0$ çš„ $e$ åœ¨çº¦æŸæ¡ä»¶ä¸­æ‰¾å‡ºæ»¡è¶³ $a_{l,e}&gt;0ä¸”\\frac{a_{l,0}}{a_{l,e}}æœ€å¤§$ çš„ $l$ å°†ç¬¬ $l$ ä¸ªçº¦æŸç­‰å¼ç§»é¡¹å˜å½¢ï¼š $x_e=\\frac{b_i}{a_{l,e}}-\\sum\\limits_{j=1,j\\not=e}^n\\frac{a_{l,j}}{a_{l,e}}x_j-\\frac1{a_{l,e}}x_{l+m}$ å°†ç§»é¡¹å¾—åˆ°çš„ç­‰å¼å¸¦å…¥å…¶ä½™çš„çº¦æŸç­‰å¼å’Œç›®æ ‡å‡½æ•°ä¸­ï¼Œæ¶ˆå»æ‰€æœ‰çš„ $x_e$ ï¼Œæ·»åŠ ä¸Š $x_{l+m}$ ï¼Œå¹¶æ›´æ–°å‰©ä½™é¡¹çš„ç³»æ•° è®¨è®ºä¸‹é¢å‡ ç§è¾¹ç•Œæƒ…å†µï¼š å½“ç¬¬ä¸€æ­¥æ— æ³•æ‰¾åˆ°åˆæ³•çš„ $e$ æ—¶ï¼Œè¯´æ˜æ±‚å‡ºäº†æœ€ä¼˜è§£ å½“ç¬¬äºŒæ­¥æ— æ³•æ‰¾åˆ°åˆæ³•çš„ $l$ æ—¶ï¼Œè¯´æ˜è¯¥çº¿æ€§è§„åˆ’æ— ç•Œ å¤æ‚åº¦æŒ‡æ•°çº§ï¼Œä½†è·‘çš„æ¯”è°éƒ½å¿« æ­£ç¡®æ€§:çº¿æ€§è§„åˆ’æœ‰ç•Œæ—¶è§£ç©ºé—´æ˜¯ä¸€ä¸ªå‡¸å½¢åŒºåŸŸï¼Œå› æ­¤å•çº¯å½¢ç®—æ³•æ±‚å‡ºçš„å±€éƒ¨æœ€ä¼˜å€¼å³ä¸ºå…¨å±€æœ€ä¼˜å€¼ å½“ç„¶æœ‰æ—¶å€™éœ€è¦æ„é€ ä¸€ç»„åˆå§‹è§£å‡ºæ¥ï¼ˆå¤§éƒ¨åˆ†æ—¶å€™ä¸éœ€è¦ï¼‰ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹æŠ€å·§æ„é€ è¾…åŠ©çº¿æ€§è§„åˆ’ï¼š \\begin{aligned} maximize:&-x_0\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j+x_0=b_i\\\\ &x_i\\ge0 \\end{aligned}å®¹æ˜“çœ‹å‡ºå¦‚æœè¯¥æƒ…å†µæ— è§£é‚£ä¹ˆåŸé—®é¢˜æ— è§£ ä¾‹é¢˜ï¼š UVA Happiness CC Flight Distance TCO precious stones æ•´æ•°çº¿æ€§è§„åˆ’æœ¬æ¥åº”è¯¥æ˜¯ $NP-hard$ é—®é¢˜ ä½†æ˜¯å¦‚æœè¯æ˜æœ€ä¼˜è§£ä¸€å®šæ˜¯åœ¨æ•´æ•°è§£æ—¶å¯ä»¥å–å¾—çš„è¯å¯ä»¥ç”¨å•çº¯å½¢ åŸå› è¿˜æ˜¯æ¥æºäºä¸Šé¢è¯´è¿‡çš„å‡¸å½¢åŒºåŸŸ æˆ–è€…å¯ä»¥ä¸€çœ¼çœ‹å‡ºè¯¥çº¿æ€§è§„åˆ’çš„ $\\boldsymbol A$ æ˜¯ä¸€ä¸ªå…¨å¹ºæ¨¡çŸ©é˜µä¹Ÿè¡Œ å¯¹å¶åŸç†è€ƒè™‘ç°åœ¨æœ‰å¦‚ä¸‹çº¿æ€§è§„åˆ’ï¼š \\begin{aligned} minimize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j\\ge b_i\\\\ &x_i\\ge0 \\end{aligned}åˆ©ç”¨å¾…å®šç³»æ•°æ³•çš„æ€æƒ³å¯ä»¥çŸ¥é“ï¼Œè¯¥çº¿æ€§è§„åˆ’çš„ä»»æ„å¯è¡Œè§£$(x_1^{\\times},x_2^\\times,â€¦,x_n^\\times)$ä¸€å®šèƒ½è¡¨ç¤ºæˆå¦‚ä¸‹å½¢å¼ï¼š \\begin{aligned} \\sum\\limits_{i=1}^nc_ix_i^\\times=&\\sum\\limits_{i=1}^my_i(\\sum\\limits_{j=1}^na_{i,j}x_j^\\times)\\ge\\sum\\limits_{i=1}^mb_iy_i\\\\ \\sum\\limits_{i=1}^my_ia_{i,j}\\le&c_j\\\\ y_i\\ge&0 \\end{aligned}ç°åœ¨è¦æ‰¾å‡º $\\sum\\limits_{i=1}^nc_ix_i$ çš„ä¸‹ç•Œï¼Œç­‰ä»·äºæ‰¾å‡º $\\sum\\limits_{i=1}^mb_iy_i$ çš„ä¸Šç•Œ äºæ˜¯æˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªæ–°çš„çº¿æ€§è§„åˆ’ï¼š \\begin{aligned} maximize:&\\sum_{i=1}^mb_iy_i\\\\ limits:&\\sum_{j=1}^ma_{j,i}y_j\\le c_j\\\\ &y_j\\ge0 \\end{aligned}åŒæ ·çš„ï¼Œå°†æ–°å¾—åˆ°çš„çº¿æ€§è§„åˆ’åšç±»ä¼¼è½¬åŒ–å¯ä»¥è½¬å›åŸæ¥çš„çº¿æ€§è§„åˆ’ï¼Œæˆ‘ä»¬ç§°è¿™ä¸¤ä¸ªçº¿æ€§è§„åˆ’äº’ä¸ºå¯¹å¶é—®é¢˜ äº’ç›¸è½¬åŒ–çš„å…³é”®æ˜¯è¿™ä¸ªç­‰å¼ï¼š $\\sum\\limits_{i=1}^nc_ix_i\\ge\\sum\\limits_{i=1}^mb_iy_i$ ï¼Œå³ç­‰å·å³è¾¹çš„ä¸Šç•Œä¸è¶…è¿‡ç­‰å·å·¦è¾¹çš„ä¸‹ç•Œ ä¸Šè¿°ç­‰å¼å³æ˜¯çº¿æ€§è§„åˆ’å¼±å¯¹å¶æ€§ï¼Œå³å¯¹äºä¸¤ä¸ªçº¿æ€§è§„åˆ’çš„ä»»æ„å¯è¡Œè§£ $\\boldsymbol x^\\times,\\boldsymbol y^\\times$ï¼Œå‡æ»¡è¶³ $\\sum\\limits_{i=1}^nc_ix_i^\\times\\ge\\sum\\limits_{i=1}^mb_iy_i^\\times$ çº¿æ€§è§„åˆ’çš„å¯¹å¶åŸç†ç”¨çŸ©é˜µçš„å½¢å¼å¯ä»¥ç®€å•è¡¨ç¤ºä¸ºï¼š \\min\\{\\boldsymbol{c}^T \\boldsymbol x|\\boldsymbol A\\boldsymbol x\\ge \\boldsymbol b,\\boldsymbol x\\ge\\boldsymbol0\\}\\Longleftrightarrow\\max\\{\\boldsymbol b^T\\boldsymbol x|\\boldsymbol A^T\\boldsymbol y\\ge\\boldsymbol c,\\boldsymbol y\\ge \\boldsymbol 0\\}ä¸‹é¢è¯æ˜ä¸€ä¸ªé‡è¦å®šç†ï¼š çº¿æ€§è§„åˆ’å¯¹å¶æ€§ï¼šå¯¹äºä¸¤ä¸ªçº¿æ€§è§„åˆ’çš„ä»»æ„æœ€ä¼˜è§£è§£ $\\boldsymbol x^\\times,\\boldsymbol y^\\times$ï¼Œå‡æ»¡è¶³ $\\sum\\limits_{i=1}^nc_ix_i^\\times=\\sum\\limits_{i=1}^mb_iy_i^\\times$ è¯æ˜ï¼š å¯¹äºç¬¬ä¸€ä¸ªçº¿æ€§è§„åˆ’ï¼Œè€ƒè™‘æ„é€ ä¸€ä¸ªå‡½æ•° $f(\\boldsymbol y)=\\boldsymbol c^T\\boldsymbol x+\\boldsymbol y^T(\\boldsymbol b-\\boldsymbol A\\boldsymbol x),\\boldsymbol y\\ge\\boldsymbol0$ ä»¤ $g(\\boldsymbol y)=\\min\\{f(\\boldsymbol y)|\\boldsymbol A\\boldsymbol x\\ge \\boldsymbol b,\\boldsymbol x\\ge\\boldsymbol0\\}$ æ˜¾ç„¶$\\forall \\boldsymbol y,g(\\boldsymbol y)\\le \\boldsymbol c^T\\boldsymbol x^\\times$ å³$\\max\\{g(\\boldsymbol y)\\}=\\boldsymbol c^T\\boldsymbol x^\\times$ è½¬åŒ–é—®é¢˜ï¼š \\begin{aligned} \\boldsymbol c^T\\boldsymbol x^\\times=&\\max\\{g(\\boldsymbol y)\\}\\\\ =&\\max\\{\\boldsymbol y^T\\boldsymbol b+\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}\\}\\\\ =&\\max\\{\\boldsymbol b^T\\boldsymbol y+\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}\\} \\end{aligned}å½“ $\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A\\ge \\boldsymbol0$ æ—¶ï¼Œ$\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}=0$ å½“ $\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A\\not\\ge \\boldsymbol0$ æ—¶ï¼Œ$\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}=-inf$ ç®€å•åˆ†æä¸å˜å½¢åå¯çŸ¥ï¼š \\begin{aligned} \\boldsymbol c^T\\boldsymbol x^\\times=&\\max\\{\\boldsymbol b^T\\boldsymbol y|\\boldsymbol A^T\\boldsymbol y\\le\\boldsymbol c,\\boldsymbol y\\ge\\boldsymbol0\\} \\end{aligned}å¾—è¯ è€Œä¸”å®¹æ˜“çŸ¥é“åŸé—®é¢˜å’Œå¯¹å¶é—®é¢˜åŒæ—¶å–åˆ°ç›®æ ‡å–å€¼~ åˆ©ç”¨ä¸Šè¿°ä¸¤ä¸ªå®šç†å®¹æ˜“è¯æ˜å‡ºçº¿æ€§è§„åˆ’çš„äº’ç›¸æ¾å¼›å®šç†ï¼š å¯¹äºåŸé—®é¢˜å’Œå¯¹å¶é—®é¢˜çš„å¯è¡Œè§£ $\\boldsymbol x^\\times,\\boldsymbol y^\\times$ ï¼Œå®ƒä»¬å‡ä¸ºé—®é¢˜çš„æœ€ä¼˜è§£å½“å‰ä»…å½“å¦‚ä¸‹æ¡ä»¶è¢«æ»¡è¶³ï¼š $\\forall 1\\le j\\le n,s.t.\\ x_j^\\times=0æˆ–\\sum\\limits_{i=1}^ma_{i,j}y_i^\\times=c_j$ $\\forall 1\\le i\\le m,s.t.\\ y_i^\\times=0æˆ–\\sum\\limits_{j=1}^na_{i,j}x_i^\\times=b_i$ å¯¹å¶åŸç†çš„å‡ ä¸ªæ€§è´¨ï¼š å¯¹äºæ— é™åˆ¶å˜é‡ $x_i$ ï¼Œå¯¹å¶åå¯¹åº”é™åˆ¶ $\\sum\\limits_{j=1}^ma_{j,i}y_j=c_i$ å¯¹äºå˜é‡ $x_i=0$ ï¼Œå¯¹å¶åå¯¹åº” $\\sum\\limits_{j=1}^ma_{j,i}y_j$ æ— é™åˆ¶ å¯¹äºå˜é‡ $x_i\\ge0$ ï¼Œå¯¹å¶åå¯¹åº”é™åˆ¶ $\\sum\\limits_{j=1}^ma_{j,i}y_j\\ge0$ å¯¹äºå˜é‡ $x_i\\le0$ ï¼Œå¯¹å¶åå¯¹åº”é™åˆ¶ $\\sum\\limits_{j=1}^ma_{j,i}y_j\\le0$ å¯¹äºé™åˆ¶ $\\sum\\limits_{j=1}^ma_{j,i}y_j=c_i$ ï¼Œå¯¹å¶åå¯¹åº”æ— é™åˆ¶å˜é‡ $x_i$ å¯¹äºé™åˆ¶$\\sum\\limits_{j=1}^ma_{j,i}y_j$ ï¼Œå¯¹å¶åå¯¹åº”å˜é‡ $x_i=0$ å¯¹äºé™åˆ¶ $\\sum\\limits_{j=1}^ma_{j,i}y_j\\ge0$ ï¼Œå¯¹å¶åå¯¹åº”å˜é‡ $x_i\\le0$ å¯¹äºé™åˆ¶ $\\sum\\limits_{j=1}^ma_{j,i}y_j\\le0$ ï¼Œå¯¹å¶åå¯¹åº”å˜é‡ $x_i\\ge0$ å¯¹å¶åŸç†åœ¨ç½‘ç»œé—®é¢˜ä¸­çš„è¿ç”¨åˆ©ç”¨ä¸Šè¿°å®šç†å’Œæ€§è´¨å¯ä»¥å¾ˆå¿«è¯æ˜å¦‚ä¸‹ä¸¤ä¸ªç»“è®ºï¼š æœ€å°å‰²å’Œæœ€å¤§æµæ˜¯å¯¹å¶é—®é¢˜ äºŒåˆ†å›¾æœ€å¤§æƒåŒ¹é…å’Œæœ€å°è´¹ç”¨æµæ˜¯å¯¹å¶é—®é¢˜ è¯æ˜æ¯”è¾ƒå®¹æ˜“ï¼Œè¿™é‡Œç•¥å» ä¾‹é¢˜ï¼š [SHOI2004]æœ€å°ç”Ÿæˆæ ‘ CC Flight Distance çº¿æ€§è§„åˆ’ä¸åŠå¹³é¢äº¤çš„è½¬åŒ– å¯¹äºåªæœ‰ä¸¤ä¸ªå˜é‡çš„çº¿æ€§è§„åˆ’ï¼Œå¯ä»¥é€šè¿‡ç§»é¡¹å˜æˆåŠå¹³é¢äº¤é—®é¢˜ å¯¹äºåªç”¨ä¸¤ä¸ªé™åˆ¶çš„çº¿æ€§è§„åˆ’ï¼Œå¯ä»¥é€šè¿‡å¯¹å¶åŸç†+ç§»é¡¹å˜æˆåŠå¹³é¢äº¤é—®é¢˜ ä¾‹é¢˜ï¼š poj equations çº¿æ€§è§„åˆ’ä¸ç½‘ç»œæµé—®é¢˜çš„è½¬åŒ–è€ƒè™‘åˆ°ç½‘ç»œæµé—®é¢˜çš„æœ€ä¼˜è§£éƒ½æ˜¯æ•´æ•°è§£ï¼Œå› æ­¤åœ¨è½¬åŒ–çš„æ—¶å€™åŠ¡å¿…è®°ä½åˆ¤å®šåˆ—å‡ºçš„çº¿æ€§è§„åˆ’æ˜¯ä¸æ˜¯å…¨å¹ºæ¨¡çŸ©é˜µå¦åˆ™ä¸ä¸€å®šè§£å‡ºçš„æœ€ä¼˜è§£æ˜¯æ•´æ•°æœ€ä¼˜è§£~ ä¾‹é¢˜ï¼š CC Chefbook bzoj Orz the MST [ZJOI2013]æˆ˜çº¿é˜²å®ˆ çº¿æ€§è§„åˆ’ä¸åšå¼ˆä¸€ä¸ªåŸºæœ¬ä¸å¯èƒ½å¡«çš„å‘ å¥½éš¾å•Šæˆ‘ä¸ä¼šçº³ä»€å‡è¡¡ï¼Œè¿˜æ˜¯å¾—cyktxdyå­¦ä¼šäº†ä¹‹åç»™æˆ‘è®²","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]},{"title":"Generating function","slug":"gf","date":"2019-09-25T14:25:20.000Z","updated":"2019-11-27T14:37:49.752Z","comments":true,"path":"gf/","link":"","permalink":"http://ldxcaicai.github.io/gf/","excerpt":"","text":"ç”Ÿæˆå‡½æ•°å®šä¹‰ï¼š ä¸€èˆ¬ç”Ÿæˆå‡½æ•°ï¼ˆOGFï¼‰ä¸€èˆ¬ç”¨äºå¤„ç†ç»„åˆé—®é¢˜ï¼ˆæ— æ ‡å·ï¼‰ $F(x)=\\sum_{i=0}^{\\infty}f_ix^i$ OGFçš„è¿ç®—å‡è®¾ç°åœ¨æœ‰ä¸¤ç±»ç»„åˆå¯¹è±¡$A,B$ é¦–å…ˆè€ƒè™‘å¦‚ä½•å¯¹å®ƒä»¬å–å¹¶ æ˜¾ç„¶å¯¹äºä¸€ä¸ªå…ƒç´ $t$ï¼Œåœ¨$A$ä¸­å‡ºç°äº†$a_t$æ¬¡ï¼Œåœ¨$B$ä¸­å‡ºç°äº†$b_t$æ¬¡ï¼Œä¸€å…±ä¼šå‡ºç°$a_t+b_t$æ¬¡ è®°ä¸º$C(x)=A(x)+B(x)$ é‚£ä¹ˆå¯¹åº”æ ‡å·çš„ç³»æ•°ç›¸åŠ å³å¯ ç„¶åè€ƒè™‘å¦‚ä½•æ±‚å®ƒä»¬çš„ç¬›å¡å°”ç§¯ å‡è®¾$A,B$ç¬›å¡å°”ç§¯ä¸º$C$ï¼Œé‚£ä¹ˆè¡¨ç¤º$C$ä¸­æ¯ä¸ªå…ƒç´ $c$éƒ½æ˜¯ç”±$A$ä¸­çš„ä¸€ä¸ªå…ƒç´ $a$å’Œ$B$ä¸­çš„ä¸€ä¸ªå…ƒç´ $b$æ‹¼æˆçš„äºŒå…ƒç»„$(a,b),|c|=|a|+|b|$ è®°ä¸º$C(x)=A(x)B(x)$ åœ¨ç”Ÿæˆå‡½æ•°ä¸ºæœ‰é™é¡¹çš„æ—¶å€™ç”¨$FFT/NTT$å¤šé¡¹å¼ä¹˜æ³•å³å¯ OGFç”Ÿæˆåºåˆ—ç°åœ¨æœ‰ä¸€ç±»ç»„åˆå¯¹è±¡$A$ï¼Œå®šä¹‰$seq(A)$ æ˜¯ç”±$A$çš„å…ƒç´ æ’åˆ—æˆçš„åºåˆ—ç»„æˆçš„é›†åˆï¼Œä¸€ä¸ªåºåˆ—çš„å¤§å°å®šä¹‰ä¸ºå…¶å…ƒç´ å¤§å°æ€»å’Œã€‚$eg1:A=\\{â€œ0â€,â€1â€\\}$ï¼Œ$seq(A)=\\{all\\ 01\\ string\\}$$eg2:N^\\times=\\{1,2,3,â€¦\\}$ï¼Œå…ƒç´ çš„å¤§å°å®šä¹‰ä¸ºå®ƒçš„æ•°å€¼ï¼Œåˆ™$seq(N)=\\{æ­£æ•´æ•°çš„æœ‰åºæ‹†åˆ†\\}$è§„å®šA ä¸­ä¸å«å¤§å°ä¸º0 çš„å…ƒç´ ï¼Œåˆ™$seq(A)=1+A+A^2+A^3+â€¦=\\frac1{1-A}$ æŒ‡æ•°ç”Ÿæˆå‡½æ•°(EGF)ä¸€èˆ¬ç”¨äºå¤„ç†ç»„åˆé—®é¢˜ï¼ˆæœ‰æ ‡å·ï¼‰å¸¸è§å¸¦æ ‡å·çš„ç»„åˆå¯¹è±¡ï¼šæ ‡å·å›¾ï¼Œç½®æ¢å°†ä¸¤ä¸ªå…ƒç´ $a,b$æ‹¼æ¥èµ·æ¥ï¼Œ$|a|=n,|b|=m$æ— æ ‡å·æ—¶ï¼Œåªæœ‰ä¸€ç§æ–¹æ³•ï¼›å¸¦æ ‡å·æ—¶ï¼Œè§„å®šæ‹¼æ¥æ—¶æ‹¼æ¥å¯¹è±¡å†…éƒ¨ç›¸å¯¹æ ‡å·é¡ºåºä¸å˜ï¼Œè€Œäº’ç›¸çš„æ ‡å·å¯ä»¥æ”¹å˜ï¼Œåˆ™æœ‰$\\frac{(n+m)!}{n!m!}=C_{n+m}^n$ç§æ–¹æ³• $F(x)=\\sum_{i=0}^{\\infty}f_i\\frac{x^i}{i!}$ EGFçš„è¿ç®—å¹¶é›†ï¼š$C(x)=A(x)+B(x)$ç¬›å¡å°”ç§¯ï¼š$C(x)=A(x)B(x)$å¯¹æ¯”ç³»æ•°åå¾ˆå¥½ç†è§£ EGFç”Ÿæˆåºåˆ—åŒ$OGF$ï¼Œ$seq(A)=\\frac1{1-A}$ EGFç”Ÿæˆé›†åˆé›†åˆä¸åºåˆ—çš„åŒºåˆ«ï¼šåŒæ ·ç”±$i$ä¸ª$EGF$ç”Ÿæˆï¼Œé›†åˆçš„é¡ºåºä¸é‡è¦ï¼Œåºåˆ—çš„é¡ºåºç¡®å®ç¡®å®šçš„ã€‚å› æ­¤ç”±$i$ä¸ª$EGF$ç”Ÿæˆçš„é›†åˆåº”è¯¥æœ‰ä¸€ä¸ª$\\frac1{i!}$çš„ç³»æ•°ã€‚$set(A)=\\sum_{i=0}^{\\infty}\\frac{A^i}{i!}=e^{A}$ ç”Ÿæˆå‡½æ•°è®¡æ•°ç½®æ¢è®¡æ•°ä¸€ä¸ªç½®æ¢æ˜¯ç”±è‹¥å¹²è½®æ¢ç»„æˆçš„é›†åˆã€‚$k$è½®æ¢çš„ä¸ªæ•°æœ‰$(k-1)!$ä¸ªï¼Œå¯¹åº”$EGF$ä¸º$(k-1)!\\frac{x^k}{k!}=\\frac{x^k}k$äºæ˜¯å…¨ä½“è½®æ¢çš„$EGF=\\sum_{i=0}^{\\infty}\\frac{x^k}k$è®¾$f(x)=\\sum_{i=0}^{\\infty}\\frac{x^k}k$é‚£ä¹ˆ$fâ€™(x)=\\sum_{i=0}^{\\infty}x^k=\\frac1{1-x}$é‚£ä¹ˆ$f(x)=\\int fâ€™(x)\\,dx=\\int\\frac1{1-x}\\,dx=-\\ln(1-x)$æ ¹æ®å®šä¹‰ï¼Œå…¨ä½“ç½®æ¢çš„$EGF$ä¸º$e^{f(x)}=e^{-\\ln(1-x)}=\\frac1{1-x}$è¿™æ ·çœ‹æ¥ï¼Œ$k$ç½®æ¢çš„ä¸ªæ•°æœ‰$k!$ä¸ªç¬¦åˆäº‹å®ã€‚å¦‚æœé™åˆ¶æ¯ä¸ªè½®æ¢çš„å¤§å°éƒ½åœ¨é›†åˆ$S$å†…å‘¢ï¼Ÿé‚£ä¹ˆå¯ç”Ÿæˆç½®æ¢çš„$EGF=e^{\\sum_{k\\in S}\\frac{x^k}k}$ å¤šé¡¹å¼$exp$å³å¯ èƒŒåŒ…è®¡æ•° æœ‰$\\sum_{i=1}^na_i$ç§ç‰©å“ï¼Œä½“ç§¯ä¸º$i$çš„ç‰©å“æœ‰$a_i$ç§ï¼Œæ¯ç§ç‰©å“æœ‰æ— é™ä¸ªã€‚ æœ‰$\\sum_{i=1}^na_i$ç§ç‰©å“ï¼Œä½“ç§¯ä¸º$i$çš„ç‰©å“æœ‰$a_i$ç§ï¼Œæ¯ç§ç‰©å“æœ‰æ— é™ä¸ªã€‚ æœ‰$n$ç§ç‰©å“ï¼Œç¬¬$i$ç§ç‰©å“ä½“ç§¯ä¸º$i$ï¼Œç¬¬$i$ç§ç‰©å“æœ‰$a_i$ä¸ªã€‚ å¯¹äºæ‰€æœ‰$1\\le i\\le n$ï¼Œå›ç­”é€‰å–ç‰©å“ä½“ç§¯ä¸º$i$çš„æ–¹æ¡ˆæ•°ã€‚ å‡å¯åœ¨$O(n\\log n)$çš„æ—¶é—´å†…æ±‚è§£ã€‚ Q1ä½“ç§¯ä¸º$i$çš„ç‰©å“çš„ç”Ÿæˆå‡½æ•°ä¸º$\\sum_{j=0}^{\\infty}(x^i)^j=1+x^i+x^{2i}+\\cdot\\cdot\\cdot$é‚£ä¹ˆç­”æ¡ˆçš„ç”Ÿæˆå‡½æ•°ä¸º$F(x)=\\prod_{i=1}^n(1+x^i+x^{2i}+\\cdot\\cdot\\cdot)^{a_i}=\\prod_{i=1}^n(\\frac1{1-x^i})^{a_i}$ æ„é€ ç”Ÿæˆå‡½æ•°$A(x)=\\sum_{i=1}^na_ix^i$ è€ƒè™‘ç”¨$ln$å’Œ$exp$è½¬åŒ–ã€‚ \\begin{aligned}\\ln F(x)=&\\sum_{i=1}^na_i\\times(-\\ln(1-x^i))\\\\=&\\sum_{i=1}^na_i\\times(\\int(\\sum_{j=0}^{\\infty}(x^i)^j)\\,dx)\\\\=&\\sum_{i=1}^na_i\\times(\\sum_{j=1}^{\\infty}\\frac{(x^i)^j}j)\\\\=&\\sum_{j=1}^{\\infty}\\frac1jA(x^j)\\\\F(x)=&e^{\\ln F(x)}\\\\=&e^{\\sum_{j=1}^{\\infty}\\frac1jA(x^j)}\\end{aligned}$A(x^j)$ä¸­åªæœ‰$\\left\\lfloor\\frac nj\\right\\rfloor$é¡¹æœ‰è´¡çŒ®ã€‚æ‰€ä»¥æš´åŠ›è°ƒå’Œè®¡æ•°ç®—å‡ºå¹‚å¯¹åº”çš„å¤šé¡¹å¼ç„¶ååŠ ä¸€ä¸ªå¤šé¡¹å¼$exp$å³å¯ã€‚å¤æ‚åº¦$O(n\\log n)$ Q2\\begin{aligned}F(x)=&\\prod_{i=1}^n(1+x^i)^{a_i}\\\\\\ln F(x)=&\\sum_{i=1}^na_i\\times\\ln(1+x^i)\\\\=&\\sum_{i=1}^na_i\\times(\\sum_{j=1}^{\\infty}(-1)^{j+1}\\frac{(x^i)^j}j)\\\\=&\\sum_{j=1}^{\\infty}\\frac{(-1)^{j+1}}jA(x^j)\\\\F(x)=&e^{\\ln F(x)}\\\\=&e^{\\sum_{j=1}^{\\infty}\\frac{(-1)^{j+1}}jA(x^j)}\\end{aligned}åŒ$Q1$å¤„ç†å³å¯ã€‚ Q3\\begin{aligned}A(x)=&\\sum_{i=1}^{n}x^i\\\\B(x)=&\\sum_{i=1}^nx^{a_ii}\\\\F(x)=&\\prod\\limits_{i=1}^n(1+x^i+x^{2i}+\\cdot\\cdot\\cdot+x^{a_ii})\\\\=&\\prod\\limits_{i=1}^n\\frac{1-x^{(a_i+1)i}}{1-x^i}\\\\\\ln F(x)=&\\sum_{i=1}^n(\\ln(1-x^{(a_i+1)i})-\\ln(1-x^i))\\\\=&\\sum_{j=1}^{\\infty}\\frac 1j(A(x^j)-B(x^j))\\\\F(x)=&e^{\\ln F(x)}\\\\=&e^{\\sum_{j=1}^{\\infty}\\frac 1j(A(x^j)-B(x^j))}\\end{aligned}$A(x^j),B(x^j)$ä¸­åªæœ‰$\\left\\lfloor\\frac nj\\right\\rfloor$é¡¹æœ‰è´¡çŒ®ã€‚äºæ˜¯åŒ$Q1,2$å¤„ç†å³å¯ã€‚ æ ‘çš„è®¡æ•°æ±‚$n$ä¸ªç‚¹çš„æ ‘çš„ä¸ªæ•°ã€‚ æœ‰æ ‡å·æ— æ ¹æ ‘è®¡æ•°åˆ©ç”¨$prufer$æ•°åˆ—å¯ä»¥çŸ¥é“ç­”æ¡ˆä¸º$n^{n-2}$ æœ‰æ ‡å·æœ‰æ ¹æ ‘è®¡æ•°å…ˆç”Ÿæˆæœ‰æ ‡å·æ— æ ¹æ ‘ï¼Œç„¶åæœ‰$n$ç§æ–¹æ¡ˆé€‰å‡ºæ ¹èŠ‚ç‚¹ï¼Œç­”æ¡ˆä¸º$n^{n-2}\\times n=n^{n-1}$ æ— æ ‡å·æœ‰æ ¹æ ‘è®¡æ•°æˆ‘ä»¬è®¾å‡ºç­”æ¡ˆçš„ç”Ÿæˆå‡½æ•°$F(x)=\\sum_{i=0}^{\\infty}f_ix^i$ï¼Œé‚£ä¹ˆ$f_i$å¯¹åº”$i$ä¸ªç‚¹çš„ç­”æ¡ˆã€‚ç°åœ¨å‡è®¾å·²ç»æ¨å‡º$f_{1,2,3,â€¦,n}$ï¼Œè¦æ¨$f_{n+1}$ã€‚ è€ƒè™‘åˆ°$n+1$ä¸ªç‚¹çš„æœ‰æ ¹æ ‘ç›¸å½“äº$n$ä¸ªç‚¹çš„æ£®æ—åŠ ä¸Šä¸€ä¸ªæ ¹ã€‚é‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦æ±‚å‡º$n$ä¸ªç‚¹æ£®æ—çš„æ–¹æ¡ˆæ•°ã€‚ ç”±äºç‚¹æ— æ ‡å·ï¼Œå› æ­¤ç›¸åŒå¤§å°çš„æ ‘ä¹‹é—´æ²¡æœ‰é¡ºåºï¼Œæˆ‘ä»¬åº”å½“æŒ‰ç…§æ ‘çš„å¤§å°å½’ç±»åˆ†åˆ«æ±‚å‡ºå…¶ç”Ÿæˆå‡½æ•°ç„¶åæ¥æ‹¼æ¥è¿™ä¸ªæ£®æ—ã€‚ ç”±äºå¤§å°ä¸º$k$çš„æ ‘å¯¹åº”çš„ç”Ÿæˆå‡½æ•°ä¸º$\\sum\\limits_{i}x^{ik}=\\frac1{1-x^k}$æ‰€ä»¥æ‰€æœ‰å¤§å°ä¸º$k$çš„æ ‘å½¢æˆæ£®æ—çš„ç”Ÿæˆå‡½æ•°ä¸º$c$ é‚£ä¹ˆ$F(x)=x\\prod\\limits_{i=1}^{\\infty}(\\frac1{1-x^i})^{f_i}$ æœæ–­ä¸Šå¤šé¡¹å¼å–å¯¹ï¼š \\begin{aligned}F(x)=&x\\prod\\limits_{i=1}^{\\infty}(\\frac1{1-x^i})^{f_i}\\\\\\ln F(x)=&\\ln x-\\sum_{i=1}^{\\infty}f_i\\ln (1-x^i)\\\\ (\\ln F(x))'=&(\\ln x-\\sum_{i=1}^{\\infty}f_i\\ln (1-x^i))'\\\\\\frac{F'(x)}{F(x)}=&\\frac1x+\\sum_{i=1}^{\\infty}f_ii\\frac{x^{i-1}}{1-x^i}\\\\xF'(x)=&F(x)+F(x)(\\sum_{i=1}^{\\infty}f_ii\\frac{x^i}{1-x^i})\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj([x^{n-i}]\\frac{x^j}{1-x^j})\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj([x^{n-i}](\\sum_{k=1}^{\\infty}[j|k]x^k))\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj[j|n-i]\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj[j|n-i]\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j|n-i}f_jj\\\\f_n=&\\frac{\\sum_{i=1}^{n-1}f_i\\sum_{j|n-i}f_jj}{n-1}\\end{aligned}è€ƒè™‘ä»¤$g_n=\\sum_{i|n}f_ii$é‚£ä¹ˆ$f_n=\\frac{\\sum_{i=1}^{n-1}f_ig_{n-i}}{n-1}$äºæ˜¯å¯ä»¥åˆ†æ²»$fft$å¤„ç†$f$ï¼Œæšä¸¾å€æ•°æ›´æ–°$g$ã€‚æ—¶é—´å¤æ‚åº¦$O(n\\log^2n)$ æ— æ ‡å·æ— æ ¹æ ‘è®¡æ•°ä½ éœ€è¦è®¡ç®—å‡ºæœ‰æ ¹æ ‘çš„ç­”æ¡ˆï¼Œç„¶åå»ä¸–å®¹æ–¥ã€‚è®°$n$ä¸ªç‚¹ç­”æ¡ˆä¸º$h_n$ã€‚ å‘ç°åªæœ‰æ ¹èŠ‚ç‚¹æ˜¯æ ‘çš„è´¨å¿ƒæ—¶æˆ‘ä»¬æ‰è®¡ç®—çš„è¯å°±ä¸ä¼šç®—é‡ã€‚ è‹¥ä¸€ä¸ªæ ¹ä¸ä¸ºè´¨å¿ƒï¼Œé‚£ä¹ˆæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå­æ ‘å¤§å°å¤§äº$\\left\\lfloor\\frac n2\\right\\rfloor$ï¼Œè€ƒè™‘å®¹æ–¥æ‰è¿™äº›ä¸åˆæ³•çš„ã€‚ç„¶åè¦æŒ‰$n$çš„å¥‡å¶æ€§åˆ†ç±»è®¨è®ºä¸€æ³¢ï¼š $n$ä¸ºå¥‡æ•°ï¼š$h_n=f_n-\\sum\\limits_{i=1}^{\\left\\lfloor\\frac{n}2\\right\\rfloor}f_if_{n-i}$ $n$ä¸ºå¶æ•°ï¼šæ­¤æ—¶å¯èƒ½å­˜åœ¨ä¸¤ä¸ªè´¨å¿ƒï¼Œå› æ­¤æšä¸¾åˆ°$i=\\frac n2$æ—¶åªèƒ½å‡å»ä¸¤è¾¹ä¸ä¸€æ ·çš„æƒ…å†µï¼Œå³$h_n=f_n-\\sum\\limits_{i=1}^{\\frac{n}2-1}f_if_{n-i}-\\binom{f_\\frac n2}2$ æ—¶é—´å¤æ‚åº¦$O(n\\log^2n)$ æ¦‚ç‡ç”Ÿæˆå‡½æ•°å¯¹äºä¸€ä¸ªéšæœºç¦»æ•£å˜é‡ $X$ ï¼Œæˆ‘ä»¬å®šä¹‰å…¶æ¦‚ç‡ç”Ÿæˆå‡½æ•° $f(z)=\\mathbb{E}(z^{X})=\\sum\\limits_{i=0}^{+\\infty}Pr(X=i)z^i$ ä¸éš¾å‘ç°ä»¥ä¸‹æ€§è´¨ï¼š \\begin{aligned}f(1)=&1\\\\f'(1)=&\\mathbb{E}(X)\\\\f^{(k)}(1)=&\\mathbb{E}(X^{\\underline{k}})\\\\Var(X)=&f''(1)+f'(1)-f'(1)^2\\end{aligned}å¯¹äºæ·éª°å­çš„é—®é¢˜æˆ‘ä»¬ä¸€èˆ¬ç”¨ä»¥ä¸‹å‡ ç§å…³ç³»æ¥å»ºç«‹ç­‰å¼ï¼š è®¾æ—¶åˆ» $i$ ç»“æŸçš„æ¦‚ç‡ç”Ÿæˆå‡½æ•°ä¸º $F(x)$ ï¼Œ æœªç»“æŸçš„æ¦‚ç‡ç”Ÿæˆå‡½æ•°ä¸º $G(x)$ é‚£ä¹ˆ \\begin{aligned}F(x)+G(x)=&\\cdot\\cdot\\cdot\\\\G(x)\\times(å¼ºåˆ¶ç»“æŸçš„æ¦‚ç‡)=&\\sum\\limits_{i}F(x)\\times(æå‰iæ­¥ç»“æŸçš„æ¦‚ç‡)\\\\\\end{aligned}ç„¶åå¯¹ç¬¬ä¸€ä¸ªå¼å­æ±‚å¯¼ï¼Œå¯¹ç¬¬äºŒä¸ªç­‰å¼å¸¦å…¥ $x=1$ å³å¯ ä¾‹é¢˜ï¼š[CTSC2006]æ­Œå”±ç‹å›½,hdu4652 è€Œåœ¨æœ‰å¤šä¸ªç»ˆæ€çš„æ—¶å€™ä¸€èˆ¬è€ƒè™‘å¦‚ä¸‹æ–¹æ³•å˜å½¢ï¼š $min-max$ å®¹æ–¥ åˆ©ç”¨ $\\sum\\limits_{i}F_i(1)=1$è¿™ä¸ªç­‰å¼å’Œä¹‹å‰çš„ç­‰å¼å»ºç«‹æ–¹ç¨‹ç»„è·‘é«˜æ–¯æ¶ˆå…ƒè§£æ–¹ç¨‹ ä¾‹é¢˜ï¼š[SDOI2017]ç¡¬å¸æ¸¸æˆ","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]},{"title":"polynomial","slug":"poly","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-16T00:18:56.688Z","comments":true,"path":"poly/","link":"","permalink":"http://ldxcaicai.github.io/poly/","excerpt":"","text":"å¤šé¡¹å¼çš„è¿ç®—å¤šé¡¹å¼çš„åŠ å‡æ³•ï¼Œæ•°ä¹˜è¿™ä¸ªå¤§å®¶åº”è¯¥éƒ½ä¼šå§ä¸æ¨äº†ã€‚ å¤šé¡¹å¼ä¹˜æ³•è¿™ä¸ªå¤§å®¶åº”è¯¥éƒ½ä¼šå§è¿˜æ˜¯æ¨ä¸€æ¨å§ã€‚å·²çŸ¥çš„ï¼š$A(x)=\\sum_{i=0}^na_ix^i$$B(x)=\\sum_{i=0}^mb_ix^i$è¦æ±‚çš„ï¼š$C(x)=A(x)B(x)=\\sum_{i=0}^{n+m}(\\sum_{j=0}^{min\\{i,n\\}}a_j\\times b_{i-j})x^i$ æ˜¾ç„¶ç›´æ¥æš´åŠ›åšæ˜¯$O(n^2)$çš„ï¼Œè€ƒè™‘å¦‚ä½•ä¼˜åŒ–ã€‚ é‚£ä¹ˆæˆ‘ä»¬ä½¿ç”¨$fft$æˆ–è€…$ntt$æ¥å®ç°ç‚¹å€¼è¡¨ç¤ºæ³•å’Œç³»æ•°è¡¨ç¤ºæ³•ä¹‹é—´çš„å¿«é€Ÿè½¬åŒ–ã€‚ ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œæˆ‘ä»¬å°†$A,B$çš„æœ€é«˜æ¬¡æ•°ç»Ÿä¸€æˆä¸€ä¸ª$2$çš„å¹‚ï¼ˆå¯¹äºè¶…è¿‡$n/m$çš„é¡¹çš„ç³»æ•°çœ‹æˆ0å³å¯ï¼‰ æ‰€è°“çš„ç³»æ•°è¡¨ç¤ºæ³•å°±æ˜¯æˆ‘ä»¬å¹³å¸¸ç”¨çš„é‚£ç§ã€‚ è€Œç‚¹å€¼è¡¨ç¤ºæ³•ï¼Œå°±æ˜¯æŠŠè¿™ä¸ªå¤šé¡¹å¼ç†è§£æˆä¸€ä¸ªå‡½æ•°ï¼Œç”¨è¿™ä¸ªå‡½æ•°ä¸Šçš„è‹¥å¹²ä¸ªç‚¹çš„åæ ‡æ¥æè¿°è¿™ä¸ªå¤šé¡¹å¼:$f(x)=(x_0,y_0),(x_1,y_1),â€¦,(x_n,y_n)=p_0,p_1,p_2,â€¦,p_n$ å‡è®¾æˆ‘ä»¬å·²ç»å°†$A,B$ä¸¤ä¸ªå‡½æ•°è½¬åŒ–æˆäº†ç‚¹å€¼è¡¨ç¤ºï¼Œäºæ˜¯å°±å¯ä»¥é©¬ä¸Šæ±‚å‡º$C$çš„ç‚¹å€¼è¡¨ç¤ºï¼š$A(x)=(x_{a,0},y_{a,0}),(x_{a,1},y_{a,1}),â€¦,(x_{a,n-1},y_{a,n-1})=p_{a,0},p_{a,1},â€¦,p_{a,n-1}$$B(x)=(x_{b,0},y_{b,0}),(x_{b,1},y_{b,1}),â€¦,(x_{b,n-1},y_{b,n-1})=p_{b,0},p_{b,1},â€¦,p_{b,n-1}$é‚£ä¹ˆ$C(x)=p_{a,0}\\times p_{b,0}, p_{a,1}\\times p_{b,1},â€¦,p_{a,n-1}\\times p_{b,n-1}=p_{c,0},p_{c,1},â€¦,p_{c,n-1}$ç„¶åå†æŠŠ$C(x)$è¿˜åŸæˆç³»æ•°è¡¨è¾¾å¼å³å¯ã€‚æ³¨æ„ï¼šæˆ‘ä»¬éœ€è¦ä¿è¯$x_{ai},x_{bi}$äº’ä¸ç›¸åŒ ç°åœ¨å°±åªç”¨è€ƒè™‘å¦‚ä½•å®ç°ç‚¹å€¼è¡¨ç¤ºå’Œç³»æ•°è¡¨ç¤ºçš„äº’æ¢äº†ã€‚ä¹Ÿå°±æ˜¯å¦‚ä½•ç”¨æ›´å°‘çš„è®¡ç®—æ¬¡æ•°æ¥æ±‚å‡º$n$ä¸ªä¸åŒçš„$x$å€¼å¯¹åº”çš„$y$å€¼ã€‚è€ƒè™‘æœ‰ä¸€ä¸ªå…·æœ‰ç‰¹æ®Šæ€§è´¨çš„ä¸œè¥¿ï¼šå•ä½æ ¹å•ä½æ ¹ä¿è¯äº†$w_n^0,w_n^1,â€¦,w_n^{n-1}$æ˜¯äº’ä¸ç›¸åŒçš„å¹¶ä¸”æœ‰$w_n^{ij}=(w_n^i)^j$è€ŒåŸæ ¹åœ¨æ¨¡æ•°ä¸ºè´¨æ•°$p$çš„æ—¶å€™ä¹Ÿæœ‰$g^0,g^1,g^2,â€¦,g^{n-1}$æ˜¯äº’ä¸ç›¸åŒçš„å¹¶ä¸”$g^{ij}\\equiv (g^i)^j \\mod p$è¿™æ»¡è¶³äº†æˆ‘ä»¬ä¸Šé¢çš„æ€§è´¨ï¼Œå› æ­¤æˆ‘ä»¬è€ƒè™‘å°†$w_n^0,w_n^1,â€¦w_n^{n-1}$ä½œä¸º$x_0,x_1,â€¦x_{n-1}$å¸¦å…¥æ±‚ç‚¹å€¼ã€‚ ç„¶åè¦ç”¨åˆ°ä¸¤ä¸ªå¼•ç†ï¼š æŠ˜åŠå¼•ç†ï¼š$w_n^{k\\times 2}=w_{\\frac n2}^k$(nä¸ºå¶æ•° ) æ¶ˆå»å¼•ç†ï¼š$w_n^{k}=-w_n^{k+\\frac n2}$ è¿™ä¸¤ä¸ªå¼•ç†å¯ä»¥ç”»ä¸ªå•ä½åœ†ç®€å•è¯æ˜ ç„¶ååˆ©ç”¨æŒ‰ç…§ä¸‹æ ‡çš„å¥‡å¶æ€§æ¥è¿›è¡Œåˆ†æ²»å¤„ç†ï¼š $f(x)=\\sum_{i=0}^na_ix^i$$\\Rightarrow f(w_n^k)=\\sum_{i=0}^na_i w_n^{ik}$$\\Rightarrow f(w_n^k)=\\sum_{i=0}^{\\frac n2-1}a_{2i}w_n^{2ik}+w_n^k\\sum_{i=0}^{\\frac n2-1}a_{2i+1}w_n^{2ik}$ åŒæ—¶åˆæœ‰ï¼š $f(w_n^{k+\\frac n2})=\\sum_{i=0}^{\\frac n2-1}a_{2i}w_n^{2ik}-w_n^k\\sum_{i=0}^{\\frac n2-1}a_{2i+1}w_n^{2ik}$ è¿™ä¸€æ­¥éœ€è¦ç”¨åˆ°å¼•ç† æ‰€ä»¥æˆ‘ä»¬åªè¦ç®—å‡ºä¸¤ä¸ªé‡æ–°åˆ†é…äº†ç³»æ•°çš„å¤šé¡¹å¼çš„å€¼å°±å¯ä»¥äº†ã€‚æ˜¾ç„¶ä¸€ç›´åˆ†ä¸‹å»åªæœ‰$log$å±‚ã€‚äºæ˜¯æ€»æ—¶é—´å¤æ‚åº¦$O(nlogn)$ æ³¨æ„åˆ°é€’å½’çš„æ•ˆç‡å¾ˆä½ï¼Œæˆ‘ä»¬å¯ä»¥é¢„å¤„ç†æœ€åä¸€å±‚çš„ç³»æ•°çš„ä½ç½®ç„¶åç”¨è¿­ä»£çš„æ–¹å¼è¿˜åŸå›å»æ¥ä¼˜åŒ–å¸¸æ•° åŸç†ï¼šæˆ‘ä»¬å‘ç°åˆ†æ²»å®Œä¹‹åç›¸å½“äºå°†$i$å’Œ$i$å¯¹åº”çš„äºŒè¿›åˆ¶æ•°åœ¨$lim$ä¸‹åè½¬ä¹‹åå¯¹åº”çš„æ–°äºŒè¿›åˆ¶æ•°$iâ€™$è¿™ä¸¤ä¸ªä½ç½®çš„ç³»æ•°$a_i,a_iâ€™$äº¤æ¢äº†ä½ç½®ã€‚è¿™å°±æˆåŠŸçš„å®ç°äº†ç³»æ•°è½¬ç‚¹å€¼ã€‚ ä¸‹é¢æ¥çœ‹ç‚¹å€¼è½¬ç³»æ•°ï¼š æ³¨ï¼šä¸‹é¢çš„å›¾ç‰‡æœ‰å‡ ç‚¹æ²¡å†™æ¸…æ¥šï¼š æœ€åçš„æ—¶å€™$e_{i,i}=0,e_{i,j|i\\not=j}$ é‚£ä¸ª$I_n$æŒ‡çš„å°±æ˜¯ $n\\times n$ çš„å•ä½çŸ©é˜µã€‚ ä»¥ä¸Šæ˜¯$fft$çš„è¯æ˜ï¼Œ$ntt$åŒç†ã€‚ å¤šé¡¹å¼æ±‚é€† å®šä¹‰ï¼šå¯¹äºä¸€ä¸ªå¤šé¡¹å¼$A(x)$ï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ªå¤šé¡¹å¼$B(x)$ï¼Œæ»¡è¶³$B(x)$çš„æ¬¡æ•°å°äºç­‰äº$A(x)$ä¸”$A(x)B(x)â‰¡1 \\mod x^n$ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°B(x)ä¸º$A(x)$åœ¨æ¨¡$x^n$æ„ä¹‰ä¸‹çš„é€†å…ƒï¼Œç®€å•è®°ä½œ$A^{âˆ’1}(x)$ æ±‚æ³•ï¼š$n=1?$é‚£ä¸å°±æ˜¯$c$çš„é€†å…ƒä¹ˆã€‚ $n&gt;1?$æˆ‘ä»¬ä»¤$B(x)=A^{-1}(x)$ é‚£ä¹ˆæœ‰$A(x)B(x)\\equiv 1 \\mod x^n$ç„¶åå¯ä»¥ç”¨ç±»ä¼¼å€å¢çš„æ–¹æ³•æ±‚ã€‚ å‡è®¾æˆ‘ä»¬å·²ç»çŸ¥é“$C(x)$æ»¡è¶³$A(x)C(x)\\equiv 1\\mod x^{\\frac n2}$ï¼ˆè¿™é‡Œçš„$\\frac n2$éƒ½æ˜¯å‘ä¸Šå–æ•´ï¼‰ æ˜¾ç„¶$A(x)B(x)\\equiv 1\\mod x^{\\frac n2}$æ˜¯æˆç«‹çš„ã€‚ æˆ‘ä»¬å°†ä¸¤å¼ç›¸å‡ï¼š $A(x)(B(x)-C(x))\\equiv 0\\mod x^{\\frac n2}$ æ‰€ä»¥$B(x)-C(x)\\equiv 0\\mod x^{\\frac n2}$ ç„¶åå°†ä¸¤è¾¹å¹³æ–¹ï¼š $B^2(x)-2B(x)C(x)+C^2(x)\\equiv 0\\mod x^{\\frac n2}$ =&gt;$B^2(x)-2B(x)C(x)+C^2(x)\\equiv 0\\mod x^n$ è¿™ä¸€æ­¥å¾ˆå…³é”®ï¼Œè¯·ç¥çŠ‡ä»¬ä»”ç»†æ€è€ƒåŸå›  ç„¶åä¸¤è¾¹åŒæ—¶ä¹˜ä¸Š$A(x)$ =&gt;$B(x)-2C(x)+A(x)C^2(x)\\equiv 0\\mod x^n)$ äºæ˜¯$B(x)\\equiv2C(x)-A(x)C^2(x)\\mod x^n$ ä¹˜æ³•å¯ä»¥ç”¨$fft/ntt$åŠ é€Ÿï¼Œå› ä¸ºæ¯æ¬¡é€’å½’çš„æ—¶å€™å¤šé¡¹å¼æœ€é«˜æ¬¡é¡¹éƒ½å‡å°‘ä¸€åŠï¼Œæ‰€ä»¥æ€»å¤æ‚åº¦ä»ç„¶æ˜¯ $O(nlogn)$ ä¸€é“æ¿é¢˜ï¼šæ´›è°·4238 å¤šé¡¹å¼æ±‚å¯¼é»˜è®¤å¤§å®¶éƒ½ä¼šå‡½æ•°æ±‚å¯¼ è¿™ä¸ªå¤šé¡¹å¼æ±‚å¯¼å±äºæœ€ç®€å•çš„é‚£ä¸€ç§ å¯¹äºä¸€ä¸ªå¤šé¡¹å¼$f(x)=\\sum_{i=0}^na_ix^i$ å®ƒæ±‚å¯¼çš„ç»“æœ$fâ€™(x)=\\sum_{i=0}^{n-1}(i+1)a_{i+1}x^i$ äºæ˜¯ç›´æ¥æ¨¡æ‹Ÿå³å¯ã€‚ å¤šé¡¹å¼ç§¯åˆ†ç›¸å½“äºæ˜¯å¤šé¡¹å¼æ±‚å¯¼çš„é€†è¿ç®—ã€‚å¯¹äºä¸€ä¸ªå¤šé¡¹å¼$f(x)=\\sum_{i=0}^na_ix^i$ å®ƒæ±‚å¯¼çš„ç»“æœ$\\int\\mathrm f(x)dx=\\sum_{i=1}^{n+1}\\frac{a_{i-1}}ix^i$ å¯ä»¥çœ‹å‡ºæ¥ä¸€ä¸ªå‡½æ•°çš„å¯¼å‡½æ•°ç§¯åˆ†èµ·æ¥ç­‰ä»·äºè‡ªå·±ã€‚ å¤šé¡¹å¼å–å¯¹æˆ‘ä»¬ä»¤$g(x)=lnf(x)$é‚£ä¹ˆæ ¹æ®é“¾å¼æ³•åˆ™æ±‚å¯¼çŸ¥ï¼š$gâ€™(x)=\\frac{fâ€™(x)}{f(x)}$æˆ‘ä»¬å·²ç»ä¼šå¤šé¡¹å¼æ±‚é€†å’Œå¤šé¡¹å¼ç§¯åˆ†ï¼Œå¤šé¡¹å¼æ±‚å¯¼äº†ï¼Œäºæ˜¯å°±æˆåŠŸè§£å†³äº†å¤šé¡¹å¼å–å¯¹ã€‚ å¤šé¡¹å¼å–expè¿™ä¸ªæ—¶å€™æˆ‘ä»¬è¦æåˆ°ä¸€ä¸ªé‡è¦çš„æ–¹æ³•ï¼šç‰›é¡¿è¿­ä»£æ³• å‡è®¾æˆ‘ä»¬è¦æ±‚$h(B(x))\\equiv A(x) \\mod x^n$ä¸­çš„$B(x)$ ç°åœ¨è€ƒè™‘æ„é€ æœ‰ä¸€ä¸ªä»¥å¤šé¡¹å¼ä¸ºå˜é‡çš„å‡½æ•°$g(f)=h(f)-A$ é‚£ä¹ˆè¦æ±‚çš„å°±æ˜¯$g(f)$æ¨¡$x^n$æ„ä¹‰ä¸‹çš„é›¶ç‚¹ã€‚ å‡è®¾å·²ç»æ±‚å‡ºäº†$g(f)$æ¨¡$x^{\\left\\lfloor\\frac x 2\\right\\rfloor}$çš„é›¶ç‚¹$f_0$é‚£ä¹ˆç°åœ¨$g(f_a)=g(f_0)+gâ€™(f_0)(f_a-f_0)+\\frac{gâ€™â€™(f_0)}2(f_a-f_0)^2+â€¦$ ç”±äº$f_0$æ˜¯æ¨¡$x^{\\left\\lfloor\\fracx 2\\right\\rfloor}$çš„é›¶ç‚¹ï¼Œæ‰€ä»¥æœ‰ï¼š$g(f_a)\\equiv g(f_0)+gâ€™(f_0)(f_a-f_0)\\equiv0\\mod x^{n}$ æ‰€ä»¥ç§»é¡¹åå‘ç°$f_a=f_0-\\frac{g(f_0)}{gâ€™(f_0)}$ è¿™ä¸ªä¸œè¥¿æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿ æˆ‘ä»¬ç®€å•ä¸¾ä¸ªä¾‹å­ï¼š æ¯”å¦‚è¯´å¤šé¡¹å¼æ±‚é€†ï¼Œå¯ä»¥æ„é€ $g(f)=\\frac1f-A$ï¼Œç®—å‡ºæ¥$f_a=2f_0-Af_0^2$ã€‚ å†æ¯”å¦‚è¯´ç°åœ¨è¦æ±‚çš„å¤šé¡¹å¼å–$exp$:æ„é€ $g(f)=e^f-A$ï¼Œç®—å‡ºæ¥$f_a=f_0(1-lnf_0+A)$ ç„¶åå°±åšå®Œäº†ã€‚ å¤šé¡¹å¼å¼€æ–¹ç›´æ¥ä½¿ç”¨ä¸Šé¢æ‰€è¯´çš„ç‰›é¡¿è¿­ä»£çš„ç»“è®ºï¼Œä»¤$g(x)=f^2-A$ï¼Œå¸¦å…¥å¾—åˆ°:$f_a=\\frac{f_0^2+A}{2f_0}$ ç„¶åç”¨å¤šé¡¹å¼æ±‚é€†æä¸€æå³å¯ã€‚ å¤šé¡¹å¼çš„é™¤æ³•/å–æ¨¡ç°åœ¨æœ‰ä¸¤ä¸ªå¤šé¡¹å¼: $A(x)=\\sum_{i=0}^na_ix^i,B(x)=\\sum_{i=0}^mb_ix^i,n&gt;m$ è¦æ±‚å‡º$C(x)=\\sum_{i=0}^{n-m}c_ix^i,D(x)=\\sum_{i=0}^td_ix^i,d&lt;m$ï¼Œæ»¡è¶³$A(x)=B(x)C(x)+D(x)$ï¼Œå…¶ä¸­$C(x)$ç±»æ¯”å•†,$D(x)$ç±»æ¯”ä½™æ•°ã€‚ æ„Ÿè§‰æƒ³æ³•æ¯”è¾ƒç¥å¥‡ã€‚ å¯¹äºä¸€ä¸ªå¤šé¡¹å¼$f(x)$ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ª$f_R(x)$è¡¨ç¤ºå°†è¿™ä¸ªå¤šé¡¹å¼çš„ç³»æ•°ç¿»è½¬ä¹‹åå¾—åˆ°çš„æ–°å¤šé¡¹å¼ï¼Œå¦‚$f(x)=2x^3+3x^2+x+5$æ—¶ï¼Œ$f_R(x)=5x^3+x^2+3x+2$ç„¶åå¯ä»¥æƒŠå¥‡çš„å‘ç°ï¼š$f_R(x)=x^nf(\\frac1x)$ ç„¶åå°±æœ‰$A(\\frac 1x)=B(\\frac 1x)C(\\frac 1x)+D(\\frac 1x)$ æ‰€ä»¥$x^nA(\\frac 1x)=x^nB(\\frac 1x)C(\\frac 1x)+x^mD(\\frac 1x)$ æ‰€ä»¥$A_R(x)=B_R(x)C_R(x)+D_R(x)\\times x^{n-m}$ å› æ­¤$A_R(x)\\equiv B_R(x)C_R(x)\\mod x^{n-m}$ æ‰€ä»¥$C_R(x)\\equiv A_R(x) (B_R(x))^{-1} \\mod x^{n-m}$ $D(x)=A(x)-B(x)C(x)$ åˆ†æ²»FFTä¸€ä¸ª\\times å¬èµ·æ¥æŒºé«˜å¤§ä¸Š\\times çš„ä¸œè¥¿ï¼Œç„¶è€Œå¾ˆç®€å•ã€‚ å‰ç½®çŸ¥è¯†ï¼šcdqåˆ†æ²»ï¼Œfft è€ƒè™‘è¿™æ ·ä¸€ä¸ªè½¬ç§»å¼å­$f_0=0,f_i=\\sum_{j=1}^if_{i-j}g_j$ï¼Œå…¶ä¸­$g$æ•°ç»„å·²çŸ¥ï¼Œè®©ä½ æ±‚$f$æ•°ç»„ã€‚ å®¹æ˜“è§‚å¯Ÿåˆ°ï¼Œè¿™ä¸ªè½¬ç§»å¼æ˜¯ä¸€ä¸ªå·ç§¯çš„å½¢å¼ã€‚ ç„¶è€Œå¹¶ä¸èƒ½ç›´æ¥$fft$å› ä¸º$f$çš„è½¬ç§»è·Ÿè‡ªèº«æœ‰å…³ï¼Œå½“ç„¶ä½ å¯ä»¥ä½¿ç”¨æˆ‘ä»¬é©¬ä¸Šä¸‹é¢è®²çš„ç”Ÿæˆå‡½æ•°ç§’æ‰ã€‚ ç”Ÿæˆå‡½æ•°åšæ³• æˆ‘ä»¬å¯¹$f,g$æ„é€ ç”Ÿæˆå‡½æ•°$F(x),G(x)$é‚£ä¹ˆ$F(x)-f_0=G(x)F(x)$ æ‰€ä»¥$F(x)=\\frac{f_0}{G(x)-1}$ï¼Œç›´æ¥ä¸Šå¤šé¡¹å¼æ±‚é€†å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(nlog_n)$åŠæ‰“åˆ†æ²»FFTã€‚ æ–°çš„åšæ³•ï¼šåˆ†æ²»FFT å‡è®¾ç°åœ¨è¦æ±‚çš„$f$å€¼çš„ä¸‹æ ‡ä¸º$[l,r]$ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨ç±»ä¼¼$cdq$åˆ†æ²»çš„æ€æƒ³ï¼Œå…ˆé€’å½’æ±‚å‡º$[l,mid]$è¿™ä¸€æ®µçš„$f$å€¼ï¼Œç„¶åè€ƒè™‘$[l,mid]$å¯¹$[mid+1,r]$çš„è´¡çŒ®ï¼Œæœ€åé€’å½’$[mid+1,r]$å³å¯ã€‚ é‚£ä¹ˆç°åœ¨è¦è€ƒè™‘çš„å°±åªæœ‰$[l,mid]$å¯¹$[mid+1,r]$çš„è´¡çŒ®å•¦ï¼ å¯¹äº$f_i,i\\in[mid+1,r],f_j,j\\in[l,mid],f_i+=f_j\\times g_{i-j}$ï¼Œç„¶åæŠŠæ‰€æœ‰çš„æ”¾åœ¨ä¸€èµ·è€ƒè™‘å°±æˆäº†ä¸€ä¸ªå·ç§¯çš„å½¢å¼ã€‚ äºæ˜¯æˆ‘ä»¬å°†$f_{l,l+1,â€¦,mid}$æ„æˆçš„å¤šé¡¹å¼å’Œ$g_{0,1,â€¦,r-l}$æ„æˆçš„å¤šé¡¹å¼ä¹˜èµ·æ¥æ›´æ–°$f_{mid+1,mid+2,â€¦,r}$å³å¯ã€‚ ç„¶è€Œæ—¶é—´å¤æ‚åº¦ä¸º$O(nlog^2_n)$ ç”Ÿæˆå‡½æ•° å‰ç½®çŸ¥è¯†ï¼šæ³°å‹’å±•å¼€æˆ‘å¯¹äºç”Ÿæˆå‡½æ•°çš„ç†è§£ï¼šç”Ÿæˆå‡½æ•°å°±ç›¸å½“äºå¯¹ä¸€ä¸ªé›†åˆçš„è¡¨ç¤ºï¼š ä¸€èˆ¬ç”Ÿæˆå‡½æ•°(Ordinary Generating Function) ä¹Ÿå°±æ˜¯å¤§å®¶å¸¸è¯´çš„$OGF$: $F(x)=\\sum_{i=0}^{\\infty}a_ix^i$ æŒ‡æ•°ç”Ÿæˆå‡½æ•°(Exponential Generating Function) ä¹Ÿå°±æ˜¯å¤§å®¶å¸¸è¯´çš„$EGF$: $F(x)=\\sum_{i=0}^{\\infty}a_i\\frac{x^i}{i!}$ å®ƒä»¬å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¤„ç†ä¸€äº›ç»„åˆé—®é¢˜ã€‚ ä¸¤ä¸ªç»å¸¸ç”¨åˆ°çš„å…¬å¼ï¼š $1+x+x^2+â€¦=\\frac{1}{1-x}$ $1+x+x^3+â€¦+x^n=\\frac{1-x^{n+1}}{1-x}$å°å­¦çš„ç­‰æ¯”æ•°åˆ—æ±‚å’Œå…¬å¼ ä»¥åŠæˆ‘ä»¬çš„æ³°å‹’å±•å¼€å…¬å¼ã€‚ è§£å†³ç»„åˆé—®é¢˜çš„æ—¶å€™æˆ‘ä»¬é€šå¸¸å°†$x^i$çš„ç³»æ•°çœ‹æˆå€¼ä¸º$i$çš„æ•°è¢«å‡‘å‡ºçš„æ–¹æ¡ˆæ•° äº‹å®ä¸Šï¼Œæˆ‘è®¤ä¸ºåŠ æ³•åŸç†å’Œä¹˜æ³•åŸç†åœ¨ç”Ÿæˆå‡½æ•°ä¸ŠåŒæ ·å¯¹åº”äº†å…·ä½“çš„è¿ç®—ã€‚ æ¯”å¦‚è¯´ç°åœ¨æˆ‘ä»¬è¦ä»é›†åˆ$A_1,A_2,A_3,..,A_n$ä¸­é€‰ä¸€ä¸ªå€¼ä¸º$i$çš„æ•°å‡ºæ¥é—®æœ‰å¤šå°‘ç§é€‰æ³•ï¼ˆåŠ æ³•åŸç†ï¼‰ï¼Œé‚£ä¹ˆè€ƒè™‘è¿™$n$ä¸ªç”Ÿæˆå‡½æ•°çš„å’Œ$C$ï¼Œ$C$ä¸­$x^i$çš„ç³»æ•°å°±æ˜¯ç­”æ¡ˆã€‚ å†æ¯”å¦‚è¯´æˆ‘ä»¬è¦ä»$A_1,A_2,A_3,â€¦,A_n$ä¸­å„é€‰ä¸€ä¸ªæ•°åŠ èµ·æ¥ï¼Œé—®åŠ å’Œä¸º$i$çš„æ–¹æ¡ˆæ•°ï¼ˆä¹˜æ³•åŸç†ï¼‰ï¼Œé‚£ä¹ˆè€ƒè™‘è¿™$n$ä¸ªç”Ÿæˆå‡½æ•°çš„ç§¯$C$ï¼Œ$C$ä¸­$x^i$çš„ç³»æ•°å°±æ˜¯ç­”æ¡ˆã€‚ æ˜¯ä¸æ˜¯æœ‰ç‚¹æ„Ÿè§‰äº†ï¼Ÿ æˆ‘ä»¬ä¸¾ä¸€ä¸ªä¾‹å­ï¼šæ­£æ•´æ•°é›†$N=\\{1,2,3,4,â€¦\\}$ï¼Œå…ƒç´ çš„å¤§å°å®šä¹‰ä¸ºå®ƒçš„æ•°å€¼ï¼Œå®šä¹‰$SEQ(A)$ æ˜¯ç”±$A$çš„å…ƒç´ æ’æˆçš„åºåˆ—ç»„æˆçš„é›†åˆï¼Œä¸€ä¸ªåºåˆ—çš„å¤§å°å®šä¹‰ä¸ºå…¶å…ƒç´ å¤§å°æ€»å’Œï¼Œç°åœ¨è®©æˆ‘ä»¬æ±‚ä¸€æ±‚$SEQ(N)$ã€‚ $SEQ(N) = \\{æ­£æ•´æ•°æœ‰åºæ‹†åˆ†\\}=\\{0,1,1+1,2,1+1+1,1+2, 2+1,3\\}$ è€ƒè™‘æ„é€ ä¸€ä¸ªå‡½æ•°$N(x)=x+x^2+â€¦=\\frac x{1-x}$ äºæ˜¯$SEQ(N)=1+N(x)+N^2(x)+â€¦=\\frac 1{1-N(x)}=1+\\frac x{1-2x}=1+x+2x+4x^2+â€¦$ æ˜¯ä¸æ˜¯æ„Ÿè§‰æŒºå¥½ç”¨çš„ ä¸¤é“æ¿é¢˜ï¼šbzoj3028,poj3734 å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼ç°åœ¨å·²çŸ¥$f(x)=\\sum_{i=0}^na_ix^i$ä¸$m$ä¸ªæ•°$b_1,b_2,â€¦,b_m$ã€‚ æ±‚$f(b_1),f(b_2),â€¦,f(b_m)$ æœ‰å¾ˆæ˜¾ç„¶çš„$O(nm)$æš´åŠ›åšæ³•ï¼Œè¿™é‡Œç›´æ¥ç•¥è¿‡ã€‚ è€ƒè™‘æ„é€ ä¸€ä¸ªå‡½æ•°$g_{l,r}(x)=\\prod_{i=l}^r(x-b_i)$ é‚£ä¹ˆ$\\forall x_0\\in[l,r]$ï¼Œæœ‰$f(x_0)=(f\\%g_{l,r})(x_0)$ è¯æ˜ï¼š ä»¤$f(x)=g_{l,r}(x)\\times B(x)+R(x)=(x-x_0)\\times (\\frac{g_{l,r}(x)}{x-x_0}\\times B(x))+R(x)$å½“$x=x_0$æ—¶ï¼š$f(x_0)=0+R(x_0)=R(x_0)=(f\\%g_{l,r})(x_0)$ æœ‰äº†è¿™ä¸ªç»“è®ºå°±å¯ä»¥åˆ†æ²»å¤„ç†äº†ã€‚ å¤šé¡¹å¼å¿«é€Ÿæ’å€¼ç»™å‡º$n$ä¸ªç‚¹$(x_i,y_i)$ï¼Œæ±‚å¯¹åº”å¤šé¡¹å¼ã€‚ æœ‰ä¸€ç§å«åšæ‹‰æ ¼æœ—æ—¥æ’å€¼çš„ä¸œè¥¿éœ€è¦äº†è§£ä¸€ä¸‹ã€‚ å¹¶ä¸”è¦ä¼šä¸Šé¢çš„å¤šé¡¹å¼å¤šç‚¹æ±‚å€¼ã€‚ ä»”ç»†è§‚å¯Ÿæ‹‰æ ¼æœ—æ—¥æ’å€¼çš„ä»£æ•°å¼ï¼š f(x)=\\sum_{i=1}^ny_i\\prod_{j=\\not i}\\frac{x-x_j}{x_i-x_j}\\\\è€ƒè™‘å¦‚ä½•å¿«é€Ÿæ±‚$val_i=\\prod_{j=\\not i}(x_i-x_j)$ æ„é€ å‡½æ•°$M(x)=\\prod_i(x-x_i)$ åˆ™$val_i=\\lim\\limits_{x\\rightarrow x_i}\\frac{M(x)}{x-x_i}=\\lim\\limits_{x\\rightarrow x_i}\\frac{Mâ€™(x)}{(x-x_i)â€™}=\\lim\\limits_{x\\rightarrow x_i}Mâ€™(x)=Mâ€™(x_i)$ äºæ˜¯æˆ‘ä»¬å¯ä»¥ç”¨å¤šç‚¹æ±‚å€¼æ±‚å‡º$val$æ•°ç»„ã€‚ ç°åœ¨è®²æ‹‰æ ¼æœ—æ—¥æ’å€¼çš„ä»£æ•°å¼æ’ç­‰å˜å½¢ï¼š f(x)=\\sum_{i=1}^ny_i\\prod_{j=\\not i}\\frac{x-x_j}{x_i-x_j}\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\sum_{i=1}^n\\frac{y_i}{val_i}\\prod_{j=\\not i}(x-x_j)\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =(\\sum_{i=1}^{mid}\\frac{y_i}{val_i}\\prod_{j=\\not i}(x-x_j))(\\prod_{i=mid+1}^n(x-x_i))\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ +(\\sum_{i=mid+1}^{n}\\frac{y_i}{val_i}\\prod_{j=\\not i}(x-x_j))(\\prod_{i=1}^{mid}(x-x_i))ç”¨åˆ†æ²»$ntt$è§£å†³å³å¯ã€‚ ä¸‹é™å¹‚å¤šé¡¹å¼ä¹˜æ³•è€ƒè™‘æ±‚å‡ºå¦‚ä¸‹ä¸¤ä¸ªå¤šé¡¹å¼çš„ä¹˜ç§¯ï¼š $A(x)=\\sum_{i=0}^na_ix^{\\underline i},B(x)=\\sum_{i=0}^mb_ix^{\\underline i}$ ç„¶åè€ƒè™‘æŠŠå®ƒä»¬è½¬æˆç‚¹å€¼å½¢å¼ç„¶åä¹˜èµ·æ¥å†è½¬å›å»ã€‚ è®¾ç°åœ¨$F(x)=\\sum_{i=0}^nf_ix^{\\underline i}ï¼Œ\\hat F(x)$ä¸ºå…¶ç‚¹å€¼çš„ç”Ÿæˆå‡½æ•°ã€‚ ç°åœ¨å…ˆè€ƒè™‘$x^{\\underline n}$çš„$EGF$ =\\sum_{i=0}^{\\infty}\\frac{i^{\\underline n}}{i!}x^i=\\sum_{i=0}^{\\infty}\\frac{1}{(i-n)!}x^i=\\sum_{i=n}^{\\infty}\\frac{1}i!x^{i+n}=x^ne^xç„¶åæœ‰ \\hat F(x)=\\sum_{i=0}^{\\infty}\\frac{F(i)}{i!}x^i\\hat F(x)=\\sum_{i=0}^{\\infty}\\frac{x^i}{i!}\\sum_{j=0}^{\\infty}f_jj^{\\underline i}\\hat F(x)=\\sum_{i=0}^{\\infty}f_i\\sum_{j=0}^{\\infty}\\frac{x^j}{j!}i^{\\underline j}\\hat F(x)=\\sum_{i=0}^{\\infty}f_x^ie^x\\hat F(x)=e^x\\sum_{i=0}^{\\infty}f_ix^iäºæ˜¯å°±è½¬åŒ–æˆäº†å¸¸è§„å¤šé¡¹å¼ä¹˜æ³•é—®é¢˜ã€‚ æˆ‘ä»¬æŠŠ$\\sum_{i=0}^{n}f_ix^i$è¿™ä¸ªå¤šé¡¹å¼ä¸$e^x$ç›¸ä¹˜å°±èƒ½å¾—åˆ°ç‚¹å€¼çš„ç”Ÿæˆå‡½æ•°ï¼ŒåŒç†ï¼Œç‚¹å€¼çš„ç”Ÿæˆå‡½æ•°ä¹˜ä¸Š$e^{-x}$å°±èƒ½è¿˜åŸå¤šé¡¹å¼ã€‚ å› æ­¤å¯ä»¥ç»“åˆ$ntt/$æš´åŠ›å¤šé¡¹å¼ä¹˜æ³•åœ¨$O(n\\log n)/O(n^2)$çš„æ—¶é—´å†…å®Œæˆä¸‹é™å¹‚å¤šé¡¹å¼ä¹˜æ³•ã€‚ æ™®é€šå¤šé¡¹å¼è½¬ä¸‹é™å¹‚å¤šé¡¹å¼å·²çŸ¥æ™®é€šå¤šé¡¹å¼$A(x)=\\sum_{i=0}^na_ix^i$ ç°åœ¨æ±‚ä¸‹é™å¹‚å¤šé¡¹å¼$B(x)=\\sum_{i=0}^nb_ix^{\\underline i}$ä½¿å¾—$A(x)=B(x)$ æ€è·¯ï¼šè€ƒè™‘å…ˆå¤šç‚¹æ±‚å€¼ï¼Œç„¶å$iffp$å³å¯æ±‚å‡ºå¯¹åº”çš„ä¸‹é™å¹‚å¤šé¡¹å¼ã€‚ ä¸‹é™å¹‚å¤šé¡¹å¼è½¬æ™®é€šå¤šé¡¹å¼å·²çŸ¥ä¸‹é™å¹‚å¤šé¡¹å¼$A(x)=\\sum_{i=0}^na_ix^{\\underline i}$ ç°åœ¨æ±‚æ™®é€šå¤šé¡¹å¼$B(x)=\\sum_{i=0}^nb_ix^i$ä½¿å¾—$A(x)=B(x)$ æ€è·¯ï¼šè€ƒè™‘å…ˆ$ffp$è½¬ç‚¹å€¼ï¼Œç„¶åå¿«é€Ÿæ’å€¼å³å¯æ±‚å‡ºå¯¹åº”çš„æ™®é€šå¤šé¡¹å¼ã€‚","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]},{"title":"Berlekamp-Massey algorithm","slug":"bm-algorithm","date":"2019-09-25T14:25:20.000Z","updated":"2019-12-04T03:42:43.671Z","comments":true,"path":"bm-algorithm/","link":"","permalink":"http://ldxcaicai.github.io/bm-algorithm/","excerpt":"","text":"ç®—æ³•å¼•å…¥Berlekamp-Masseyç®—æ³•å¯ä»¥åœ¨$O(n^2)$çš„æ—¶é—´å†…æ±‚å‡ºé•¿åº¦ä¸º$n$çš„å·²çŸ¥æ•°åˆ—çš„æœ€çŸ­é€’æ¨å¼ï¼Œå†é…åˆå¸¸ç³»æ•°é½æ¬¡çº¿æ€§é€’æ¨å°±å¯ä»¥å¿«é€Ÿæ±‚å‡ºæ•°åˆ—çš„ä»»æ„é¡¹ã€‚ ç°åœ¨ç»™ä½ ä¸€ä¸ªæ•°åˆ—ï¼Œè€ƒè™‘å¦‚ä½•æ„é€ å‡ºå…¶æœ€çŸ­é€’æ¨å¼ã€‚ ç®—æ³•æµç¨‹å¯¹äºä¸€ä¸ª$n$é¡¹çš„æ•°åˆ— $A=\\{a_1,a_2,â€¦,a_n\\}$ å’Œå¦ä¸€ä¸ª$m$é¡¹çš„æ•°åˆ— $R=\\{r_1,r_2,â€¦,r_m\\}(m\\le n)$ ï¼Œå½“$\\forall k&gt;m$ï¼Œéƒ½æ»¡è¶³$a_k=\\sum\\limits_{i=1}^mr_ia_{k-i}$æ—¶ï¼Œæˆ‘ä»¬ç§°$Ræ˜¯$Açš„ä¸€ä¸ªé€’æ¨å¼ï¼Œå¯¹äºæ‰€æœ‰æ»¡è¶³æ¡ä»¶çš„$R$ï¼Œæˆ‘ä»¬å°†$m$æœ€å°çš„$R$ç§°ä¸º$A$çš„æœ€çŸ­çº¿æ€§é€’æ¨å¼ã€‚ ç°åœ¨æˆ‘ä»¬è€ƒè™‘ç”¨å¢é‡æ„é€ æ³•æ„é€ ä¸€ä¸ª$N$é¡¹çš„æ•°åˆ—$A$çš„æœ€çŸ­çº¿æ€§é€’æ¨å¼$R$ å‡è®¾æˆ‘ä»¬å½“å‰å¤„ç†åˆ°ä½ç½®$n$ï¼Œ$\\{a_1,a_2,â€¦,a_{n-1}\\}$çš„æœ€çŸ­çº¿æ€§é€’æ¨å¼ä¸º$\\{r_1,r_2,â€¦,r_m\\}$ï¼Œè®°ç¬¬$i$æ¬¡æ›´æ”¹æœ€çŸ­çº¿æ€§é€’æ¨å¼ä¸º$R_i$ï¼Œç‰¹åˆ«çš„ï¼Œ$R_0=\\{\\emptyset\\},R_{cur}=\\{r_1,r_2,â€¦,r_m\\}$å³ä¸ºå½“å‰æœ€çŸ­çº¿æ€§é€’æ¨å¼ã€‚ è®¾$\\Delta n=a_n-\\sum\\limits_{i=1}^mr_ia_{n-i}$ï¼Œç°åœ¨æŒ‰$\\Delta n$çš„å–å€¼åˆ†ä¸¤ç§æƒ…å†µè€ƒè™‘ $\\Delta n=0$ï¼Œåˆ™$R_{cur}$ä¸º$\\{a_1,a_2,â€¦,a_n\\}$çš„æœ€çŸ­çº¿æ€§é€’æ¨å¼ $\\Delta n\\not=0$ï¼Œåˆ™$R_{cur}$åœ¨ä½ç½®$n$å‡ºé”™ï¼Œæˆ‘ä»¬è¦æ„é€ å‡º$R_{cur+1}$æ¥ä¿®æ­£è¿™ä¸ªé€’æ¨å¼ã€‚ ä¿®æ­£é€’æ¨å¼æ—¶åˆè¦åˆ†ä¸¤ç§æƒ…å†µ $cur=0$ï¼Œæˆ‘ä»¬ç›´æ¥æ„é€ ä¸€ä¸ªé€’æ¨å¼ $R_1=\\{r_1,r_2,r_3,â€¦,r_n\\}$ï¼Œå…¶ä¸­ $r_1=r_2=\\cdot\\cdot\\cdot=r_n=0$ $cur\\not=0$ï¼Œè€ƒè™‘æ„é€ ä¸€ä¸ªå¢é‡æ„é€ å¼$R_{\\Delta}$æ»¡è¶³$R_{cur+1}=R_{cur}+R_{\\Delta}$ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°†å¯¹å¦‚ä½•æ„é€ $R_{\\Delta}$å±•å¼€è®¨è®ºã€‚ å®šä¹‰$fail_{i}$è¡¨ç¤ºé€’æ¨å¼$R_{i}$å‡ºé”™çš„æœ€æ—©ä½ç½®ï¼Œé‚£ä¹ˆæ­¤æ—¶æŒ‰ç…§å®šä¹‰$fail_{cur}=n$ã€‚ å‡è®¾$R_{\\Delta}$ä¸€å…±æœ‰$mâ€™$é¡¹ï¼Œè€ƒè™‘$R_{\\Delta}$è¦æ»¡è¶³çš„æ¡ä»¶ï¼š $\\Delta n=\\sum\\limits_{i=1}^{mâ€™}R_{\\Delta,i}a_{n-i}$ $\\forall mâ€™&lt;k&lt;n,0=\\sum\\limits_{i=1}^{mâ€™}R_{\\Delta,i}a_{k-i}$ è€ƒè™‘åˆ°$R_{best}$è¿™ä¸ªé€’æ¨å¼æ»¡è¶³ç±»ä¼¼çš„æ¡ä»¶ï¼Œå…¶ä¸­ $best$ æ˜¯æ»¡è¶³ $fail_{best}-len_{best}$ æœ€å°çš„ä¸€é¡¹ï¼š $\\Delta fail_{best}=a_{fail_{best}}-\\sum\\limits_{i=1}^{m_{best}}R_{best,i}a_{fail_{best}-i}$ $\\forall m_{best}&lt;k&lt;fail_{best},0=a_k-\\sum\\limits_{i=1}^{m_{best}}R_{best,i}a_{k-i}$ æˆ‘ä»¬è®¾$t=\\frac{\\Delta n}{\\Delta fail_{best}},b=\\{t,-t\\times r_{best,1},-t\\times r_{best,2},â€¦,-t\\times r_{best,m_{best}}\\}$ è¿™å¯ç¤ºæˆ‘ä»¬æŒ‰ç…§å¦‚ä¸‹æ–¹å¼æ„é€ $R_{\\Delta}$ï¼š $\\forall fail_{best}&lt;k&lt;n$ï¼Œæˆ‘ä»¬ç»™$a_{n-k}$åˆ†é…$0$ä½œä¸ºç³»æ•° $\\forall fail_{best}-m_{best}\\le k\\le fail_{best}$,æˆ‘ä»¬ç»™$a_{n-k}$åˆ†é…$b_{fail_{best}-k+1}$ä½œä¸ºç³»æ•°ã€‚ è¿™æ ·æ„é€ å‡ºæ¥çš„æ•°åˆ— R_{\\Delta}=\\{0,0,...,0,t,-t\\times r_{best,1},-t\\times r_{best,2},...,-t\\times r_{best,m_{best}}\\}æ»¡è¶³æ¡ä»¶ å†è®©$R_{cur+1}=R_{cur}+R_{\\Delta}$å³å¯ã€‚ ç”±äºæœ€åæƒ…å†µä¸‹å¯èƒ½ä¼šä¿®æ”¹$O(n)$æ¬¡ï¼Œæ‰€ä»¥å¤æ‚åº¦$O(n^2)$","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]},{"title":"AAA tree","slug":"AAA-tree","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-15T14:31:38.445Z","comments":true,"path":"AAA-tree/","link":"","permalink":"http://ldxcaicai.github.io/AAA-tree/","excerpt":"","text":"AAAæ ‘å¼•å…¥åœ¨å­¦ä¹ äº† $LCT$ ä¹‹åï¼Œæ ‘ä¸Šä¸€äº›å¸¸è§çš„é—®é¢˜å·²ç»ä¸èƒ½æ»¡è¶³é€‰æ‰‹ä»¬çš„éœ€æ±‚ï¼Œä»è€Œå‡ºç°äº†è¿™æ ·ä¸€é“é¢˜ï¼š [bzoj3153]Sone1 å®ƒè¦æ±‚é€‰æ‰‹ä»¬ç»´æŠ¤å­æ ‘è¦†ç›–ï¼Œå­æ ‘åŠ ï¼Œå­æ ‘æœ€å€¼ï¼Œå­æ ‘å’Œï¼Œé“¾è¦†ç›–ï¼Œé“¾åŠ ï¼Œé“¾æœ€å€¼ï¼Œé“¾å’Œï¼Œæ¢çˆ¶äº²ï¼Œæ¢æ ¹è¿™åäºŒä¸ªåŸºæœ¬æ“ä½œ å‡å¦‚æ²¡æœ‰æ¢çˆ¶äº²çš„ç¡®æ˜¯æ ‘é“¾å‰–åˆ†çš„åŸºæœ¬æ“ä½œ å‡å¦‚æ²¡æœ‰å­æ ‘ä¿®æ”¹ä¸æŸ¥è¯¢çš„ç¡®æ˜¯ $LCT$ çš„åŸºæœ¬æ“ä½œ ç„¶è€Œç°åœ¨éƒ½æœ‰äº† äºæ˜¯å°±æœ‰äº† $AAA$ æ ‘å’Œ $toptree$ æ¥è§£å†³ä¸Šè¿°é—®é¢˜ï¼Œç”±äºç¬”è€…ç°åœ¨å¹¶ä¸ä¼šåè€…ï¼Œå› æ­¤è¯¥ç¯‡æ–‡ç« ä¸»è¦è®²è¿° $AAA$ æ ‘çš„åŸç†ä¸å®ç° åŸç† $LCT$ æ— æ³•è§£å†³å­æ ‘é—®é¢˜çš„åŸå› æ˜¯å®ƒåªç»´æŠ¤äº†å®é“¾çš„ä¿¡æ¯è€Œå­æ ‘é—®é¢˜è¦æ¶‰åŠåˆ°è™šå­æ ‘çš„ä¿¡æ¯ åœ¨é™æ€æ ‘é—®é¢˜ä¸­ï¼Œæœ‰é“¾åˆ†æ²»è¿™ç§åˆ†æ²»æ–¹æ³•ï¼Œå…¶åŸç†æ˜¯ç”¨ä¸åŒçš„æ•°æ®ç»“æ„å¯¹é‡é“¾å’Œå®é“¾åˆ†å¼€è¿›è¡Œç»´æŠ¤å¹¶åŠæ—¶åˆå¹¶è½»é‡é“¾ä¿¡æ¯ è€ƒè™‘å¯¹æ¯ä¸ª $LCT$ ä¸Šçš„ç‚¹å»ºä¸€ä¸ªæ•°æ®ç»“æ„æ¥ç»Ÿè®¡å…¶è™šå­æ ‘çš„ä¿¡æ¯ï¼Œå®ƒè¦å…·å¤‡å¦‚ä¸‹åŠŸèƒ½ï¼š èƒ½å¤Ÿå¿«é€Ÿåˆ é™¤ä¸åŠ å…¥æ–°çš„èŠ‚ç‚¹ èƒ½å¤Ÿå¿«é€Ÿåˆå¹¶å…¶ç®¡è¾–ç‚¹çš„ä¿¡æ¯ ä¸éš¾æƒ³åˆ°å»ºå‡ºä¸€æ£µå¹³è¡¡æ ‘æ¥ç»´æŠ¤å…¶è™šå­æ ‘çš„ä¿¡æ¯ï¼Œåœ¨è¿™é‡Œç¬”è€…é€‰æ‹©ä½¿ç”¨ $splay$ ï¼Œæˆ‘ä»¬å°†åŸæ ‘è¿›è¡Œæ”¹é€ ï¼Œä½¿å¾—æ¯ä¸ªç‚¹ $p$ æœ‰å››ä¸ªå„¿å­ï¼Œå…¶ä¸­ $son_{p,0/1}$ è¡¨ç¤ºç»´æŠ¤å…¶å®é“¾ $LCT$ çš„å„¿å­ï¼Œè€Œ $son_{p,2/3}$ åˆ†åˆ«æ˜¯ç»´æŠ¤å…¶è™šå­æ ‘çš„ $splay$ çš„æ ¹ï¼Œå¯¹äºç»´æŠ¤è™šå­æ ‘çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¼ºåˆ¶å…¶åœ¨ $splay$ çš„å¶èŠ‚ç‚¹ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š åŸæ ‘ï¼š$AAA$ æ ‘ï¼š ç°åœ¨è¦å®ç°åŠ ç‚¹å’Œåˆ ç‚¹è¿›å…¶è™šå„¿å­æ‰€åœ¨çš„ $splay$ åŠ ç‚¹ï¼šå°†è¯¥ç‚¹æ’å…¥ $splay$ ä¸­ï¼ˆå¯èƒ½ä¼šæ–°å»ºä¸€ä¸ªå¦‚ä¸Šå›¾ä¸­çš„ $A$ èŠ‚ç‚¹ï¼‰åˆ ç‚¹ï¼šè‹¥è¯¥ç‚¹çˆ¶äº²æ˜¯ $A$ ç‚¹ï¼Œå°±åˆ æ‰è¯¥ç‚¹å’Œå…¶çˆ¶äº²ï¼Œå¹¶å°†è‡ªå·±çš„å…„å¼Ÿæ”¾åˆ°çˆ¶äº²çš„ä½ç½®ï¼Œå¦åˆ™ç›´æ¥åˆ æ‰è¯¥ç‚¹å³å¯ ç„¶å $access$ æ“ä½œå°±ç›´æ¥åœ¨æ¢å³å„¿å­çš„æ—¶å€™åˆ©ç”¨ä¸Šè¿°ä¸¤ä¸ªå‡½æ•°å³å¯ï¼ŒåŠ ç‚¹å¯¹åº”å°†å®è¾¹æ¢æˆè™šè¾¹ï¼Œåˆ ç‚¹å¯¹åº”å°†è™šè¾¹æ¢æˆå®è¾¹ ç»´æŠ¤æ ‡è®°ï¼š æ¯ä¸ªèŠ‚ç‚¹è®°å½•ä»¥ä¸‹ä¸‰ç§ä¿¡æ¯ï¼š $cha,sub,all$ è¡¨ç¤ºå®é“¾çš„ä¿¡æ¯ï¼Œæ•´æ£µå® $splay$ ä¸Šé¢æŒ‚ç€çš„æ‰€æœ‰è™šå­æ ‘çš„ä¿¡æ¯ï¼Œä»¥åŠæ•´æ£µå­æ ‘çš„ä¿¡æ¯ $pushup$ æ“ä½œï¼š \\begin{aligned} cha=&son[0]->cha+son[1]->cha\\\\ sub=&son[0]->sub+son[1]->sub+son[2]->all+son[3]->all\\\\ all=&cha+sub\\\\ \\end{aligned}ç®€å•æ˜“æ‡‚ å…ˆè¦ç»´æŠ¤ä¸¤ä¸ªç»´æŠ¤æ ‘å½¢æ€çš„æ ‡è®°ï¼š $rev,inr$ åˆ†åˆ«è¡¨ç¤ºç¿»è½¬æ ‡è®°ä»¥åŠå…¶æ˜¯å¦æ˜¯ $A$ ç‚¹ ç„¶åè¦ç»´æŠ¤ä¸¤ä¸ªæ ‡è®° $All,Cha$ $All$ è¡¨ç¤ºå¯¹æ•´æ£µå­æ ‘è¿›è¡Œçš„ä¿®æ”¹ï¼Œä½†ä¸ä¿®æ”¹å®é“¾çš„ä¿¡æ¯ï¼Œ $Cha$ è¡¨ç¤ºå¯¹å®é“¾è¿›è¡Œä¿®æ”¹ $All$ æ ‡è®°åœ¨ä¼ å®å„¿å­çš„æ—¶å€™ä¸ä¿®æ”¹é“¾ï¼Œåœ¨ä¼ è™šå„¿å­çš„æ—¶å€™è¦ä¿®æ”¹é“¾ $cut(v)$ æ“ä½œï¼š $access(fa_v)$ ï¼Œç„¶ååœ¨å…¶è™š $splay$ ä¸­åˆ æ‰ $v$ $link(u,v)$ æ“ä½œï¼š$access(v)$ ï¼Œç„¶åæŠŠ $u$ åŠ è¿›å…¶è™š $splay$ ä¸­ é“¾æ“ä½œåŒ $LCT$ ï¼Œä¸è¿‡åªè·Ÿ $cha$ æœ‰å…³ å­æ ‘æ“ä½œï¼šä¿®æ”¹/æŸ¥è¯¢ç‚¹ $u$ çš„æ—¶å€™ï¼Œç›´æ¥ $access(u)$ ï¼Œç„¶åå…¶å­æ ‘ä¿¡æ¯éƒ½åœ¨è™š $splay$ ä¸­ï¼Œç”¨ $u$ çš„å•ç‚¹ä¿¡æ¯å’Œå…¶è™šå­æ ‘ä¿¡æ¯æ‹¼æ¥èµ·æ¥å³å¯ è¿™æ ·å°±å¯ä»¥å°è¯•è§£å†³è¯¥é¢˜æˆ–è€…ç›´æ¥å»ä¸–äº†","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]},{"title":"segement tree trick","slug":"SGTtrick","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-11T15:30:11.450Z","comments":true,"path":"SGTtrick/","link":"","permalink":"http://ldxcaicai.github.io/SGTtrick/","excerpt":"","text":"SGTtrick$By\\ è’Ÿè’»\\ ldxcaicai$ Chapter 1.å…³äºçº¿æ®µæ ‘æ“ä½œçš„ä¸€äº›åˆ†ææˆ‘ä»¬çŸ¥é“ï¼Œçº¿æ®µæ ‘æœ‰ä¸¤ä¸ªæ ¸å¿ƒçš„å‡½æ•°$pushdown$å’Œ$pushup$ã€‚ ä»¥åŠä¸¤ç±»å¯¹äºä¸€æ®µåŒºé—´è¿›è¡Œæ“ä½œçš„å‡½æ•°$update$å’Œ$query$ åšä¸»åœ¨è¿™é‡Œç®€å•è®²ä¸€ä¸‹å‡ ä¸ªå‡½æ•°çš„åŠŸèƒ½ï¼š é¦–å…ˆæˆ‘ä»¬å‡è®¾ç”¨$Val$è¡¨ç¤ºç»´æŠ¤ä¿¡æ¯çš„ç±»å‹ï¼Œ$Tag$è¡¨ç¤ºæ‡’æ ‡è®°çš„ç±»å‹ã€‚ æ˜¾ç„¶ä¸€ä¸ªçº¿æ®µæ ‘èŠ‚ç‚¹ï¼ˆç±»å‹ä¸º$Node$ï¼‰æ˜¯ç”±ä¸€ä¸ª$Val$å…ƒç´ å’Œä¸€ä¸ª$Tag$ä»¥åŠè¡¨ç¤ºåŒºé—´ç®¡è¾–èŒƒå›´çš„$l,r$æ„æˆçš„ã€‚ 123struct Tag&#123;...&#125;;struct Val&#123;...&#125;;struct Node&#123;Val val;Tag tag;int l,r;&#125;T[N&lt;&lt;2]; $pushdown(int\\ p)$è¡¨ç¤ºå°†$p$çš„æ ‡è®°ä¸‹ä¼ ç»™$p$çš„å„¿å­å¹¶æ›´æ–°å®ƒä»¬çš„ä¿¡æ¯å’Œæ ‡è®° $pushup(int\\ p)$è¡¨ç¤ºæŠŠ$p$å„¿å­çš„ä¿¡æ¯åˆå¹¶æˆ$p$çš„ä¿¡æ¯ $query(int\\ p,int\\ ql,int\\ qr)$è¡¨ç¤ºæŸ¥è¯¢åŒºé—´$[ql,qr]$çš„ä¸€äº›ä¿¡æ¯ $update(int\\ p,int\\ ql,int\\ qr,Tag\\ v)$è¡¨ç¤ºç”¨æ ‡è®°$v$å¯¹åŒºé—´$[ql,qr]$çš„ä¿¡æ¯å’Œæ ‡è®°è¿›è¡Œæ›´æ–° å¯ä»¥çœ‹å‡ºæ¥è¿™äº›å‡½æ•°åˆ†æˆä¸¤ç±»ï¼š çˆ¶äº²æœå„¿å­è½¬ç§»ï¼š$update,pushdown$ å„¿å­æœçˆ¶äº²è½¬ç§»ï¼š$query,pushup$ è€Œæˆ‘ä»¬ç»§ç»­å°†è¿™å‡ ä¸ªå‡½æ•°çš„åŠŸèƒ½è¿›è¡Œæ‹†åˆ†å¹¶å–ä¸Šå¹¶é›†ï¼ˆé›¾ï¼Œå‘ç°å®ƒå…¶å®æ˜¯è¿™å‡ ä¸ªä¸œè¥¿çš„ç»„åˆï¼š ä¸¤ä¸ª$Val$ç±»å‹çš„å…ƒç´ çš„åˆå¹¶ ä¸€ä¸ª$Tag$ç±»å‹çš„å…ƒç´ å¯¹ä¸€ä¸ª$Val$ç±»å‹çš„å…ƒç´ çš„æ›´æ–° ä¸€ä¸ª$Tag$ç±»å‹çš„å…ƒç´ å¯¹ä¸€ä¸ª$Tag$ç±»å‹çš„å…ƒç´ çš„æ›´æ–°123456inline Tag operator+(const Tag&amp;a,const Tag&amp;b)&#123;...&#125;inline void operator+=(Tag&amp;a,const Tag&amp;b)&#123;a=a+b;&#125;inline Val operator+(const Val&amp;a,const Tag&amp;b)&#123;...&#125;inline void operator+=(Val&amp;a,const Tag&amp;b)&#123;a=a+b&#125;inline Val operator+(const Val&amp;a,const Val&amp;b)&#123;...&#125;inline void operator+=(Val&amp;a,const Val&amp;b)&#123;a=a+b;&#125; å¦‚æœæˆ‘ä»¬å¯¹è¿™å‡ ä¸ªæ“ä½œé‡è½½è¿ç®—ç¬¦çš„è¯ï¼Œé‚£ä¹ˆä¸Šè¿°å‡½æ•°çš„å®ç°å°±å¾ˆç®€å•äº†ï¼Œä¸ºäº†è®©å®ç°æ›´åŠ ç®€ä¾¿å¯ä»¥è®¾è®¡ä¸€ä¸ª$pushnowå‡½æ•°$ã€‚ $pushup$å‡½æ•°ï¼šæŠŠå„¿å­çš„$Val$åˆå¹¶æˆè‡ªå·±çš„$Val$ã€‚ 123inline void pushup(int p)&#123; T[p].val=T[lc].val+T[rc].val;&#125; $pushnow$å‡½æ•°ï¼š$pushnow(int\\ p,Tag\\ v)$è¡¨ç¤ºç”¨æ ‡è®°$v$æ›´æ–°èŠ‚ç‚¹$p$çš„ä¿¡æ¯å’Œæ ‡è®°ã€‚ä»£ç ï¼š 123inline void pushnow(int p,Tag v)&#123; T[p].val+=v,T[p].tag+=v;&#125; $pushdown$å‡½æ•°ï¼šç”¨è‡ªå·±çš„$Tag$å»æ›´æ–°å„¿å­çš„$Val$å’Œ$Tag$ 12345inline void pushdown(int p)&#123; if(check(T[p].tag))return; pushnow(lc,T[p].tag),pushnow(rc,T[p].tag); T[p].tag=tag_empty;&#125; $query$å‡½æ•°ï¼šæŠŠè¦æŸ¥è¯¢çš„åŒºé—´æ‹†æˆçº¿æ®µæ ‘ä¸Šè‡³å¤š$log$ä¸ªåŒºé—´æŠŠå®ƒä»¬çš„$Val$æŒ‰ä¸€å®šé¡ºåºåˆå¹¶èµ·æ¥ã€‚ 12345678inline Val query(int p,int ql,int qr)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return val_empty; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)return T[p].val; pushdown(p); if(qr&lt;=mid)return query(lc,ql,qr); if(qr&gt;mid)return query(rc,ql,qr); return query(lc,ql,qr)+query(rc,ql,qr);&#125; $update$å‡½æ•°ï¼šæŠŠè¦ä¿®æ”¹çš„åŒºé—´æ‹†æˆçº¿æ®µæ ‘ä¸Šè‡³å¤š$log$ä¸ªåŒºé—´åˆ†åˆ«ç”¨ç»™å‡ºçš„$Tag$æ›´æ–°å®ƒä»¬çš„$Tag$å’Œ$Val$ã€‚ 123456789inline void update(int p,int ql,int qr,Tag v)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)return pushnow(p,v); pushdown(p); if(qr&lt;=mid)update(lc,ql,qr,v); else if(ql&gt;mid)update(rc,ql,qr,v); else update(lc,ql,qr,v),update(rc,ql,qr,v); pushup(p);&#125; æ‰€ä»¥å½“ä½ æ‹¿åˆ°ä¸€é“çº¿æ®µæ ‘é¢˜çš„æ—¶å€™ï¼Œæ€è€ƒä¸Šè¿°ä¸‰ç§è¿ç®—ç¬¦å¦‚ä½•é‡è½½å³å¯$qwq$ã€‚ é‚£ä¹ˆæœ€åæˆ‘ä»¬ç»™ä¸Šä¸€æ³¢ä¸Šè¿°æ‰€æœ‰å†…å®¹åˆèµ·æ¥çš„ä¼ªä»£ç ï¼šæ‰ä¸ä¼šå‘Šè¯‰ä½ è¿™æ˜¯ä¸€ä¸ªé€šç”¨çš„æ¡†æ¶å‘¢ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859namespace SGT&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (T[p].l+T[p].r&gt;&gt;1) struct Tag&#123;...&#125;; struct Val&#123;...&#125;; const Tag tag_empty=(Tag)&#123;...&#125;; const Val val_empty=(Val)&#123;...&#125;; inline Tag operator+(const Tag&amp;a,const Tag&amp;b)&#123;...&#125; inline void operator+=(Tag&amp;a,const Tag&amp;b)&#123;a=a+b;&#125; inline Val operator+(const Val&amp;a,const Tag&amp;b)&#123;...&#125; inline void operator+=(Val&amp;a,const Tag&amp;b)&#123;a=a+b&#125; inline Val operator+(const Val&amp;a,const Val&amp;b)&#123;...&#125; inline void operator+=(Val&amp;a,const Val&amp;b)&#123;a=a+b;&#125; struct Node&#123;Val val;Tag tag;int l,r;&#125;T[N&lt;&lt;2]; inline bool check(const Tag&amp;v)&#123;...&#125; inline void pushdown(int p)&#123; if(check(T[p].tag))return; T[lc].val+=T[p].tag,T[lc].tag+=T[p].tag; T[rc].val+=T[p].tag,T[rc].tag+=T[p].tag; T[p].tag=tag_empty; &#125; inline void pushup(int p)&#123; T[p].val=T[lc].val+T[rc].val; &#125; inline void build(int p,int l,int r)&#123; T[p]=(Node)&#123;val_empty,tag_empty,l,r&#125;; if(l==r)&#123; T[p].val=(Val)&#123;...&#125;; return; &#125; build(lc,l,mid); build(rc,mid+1,r); pushup(p); &#125; inline void update(int p,int ql,int qr,Tag v)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)&#123; T[p].val+=v,T[p].tag+=v; return; &#125; pushdown(p); if(qr&lt;=mid)update(lc,ql,qr,v); else if(ql&gt;mid)update(rc,ql,qr,v); else update(lc,ql,qr,v),update(rc,ql,qr,v); pushup(p); &#125; inline Val query(int p,int ql,int qr)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return val_empty; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)return T[p].val; pushdown(p); if(qr&lt;=mid)return query(lc,ql,qr); if(qr&gt;mid)return query(rc,ql,qr); return query(lc,ql,qr)+query(rc,ql,qr); &#125; #undef lc #undef rc #undef mid&#125; Chapter 2.çº¿æ®µæ ‘çš„ä¸¤ç§å†™æ³•åæ§½ï¼šæˆ‘åæˆ‘è‡ªå·±è¿™é‡Œç®€å•è°ˆä¸€è°ˆçº¿æ®µæ ‘çš„ä¸¤ç§å®ç°æ–¹æ³•ï¼š$dfs$ç‰ˆå’Œ$bfs$ç‰ˆï¼Œå…¶ä¸­åè€…ä¸ºæˆ‘ç$yy$çš„ï¼Œç»è¿‡æµ‹è¯•å®é™…æ•ˆæœè·Ÿ$dfs$ç‰ˆå·®è·ä¸å¤§ã€‚ æˆ‘æ‰ä¸ä¼šå‘Šè¯‰ä½ ä»¬æˆ‘æµ‹å‡ºæ¥å¾ˆå¤šé¢˜ç”¨ç¬¬äºŒç§å†™æ³•è¦æ…¢ä¸€äº›å‘¢ å¥½å§æˆ‘æ‰¿è®¤æˆ‘å‘ç°çš„è¿™ç§$bfs$ç‰ˆå†™æ³•å¾ˆé¸¡è‚‹ã€‚ æ­£é¢˜ä¼—æ‰€å‘¨çŸ¥ï¼Œæœç´¢æœ‰å‡ ç§é¡ºåºï¼Œå…¶ä¸­æœ‰ä¸¤ç§å¾ˆè‘—ååˆ†åˆ«å«åš$dfs$å’Œ$bfs$ã€‚ è€Œæˆ‘ä»¬çš„å¸¸è§„çº¿æ®µæ ‘å°±æ˜¯ä½¿ç”¨çš„$dfs$åºã€‚ ç„¶è€Œåœ¨åšä¸»çš„åŠªåŠ›å°è¯•ä¸‹ï¼Œ$bfs$åºä¹Ÿæ˜¯å¯ä»¥å¤„ç†çš„ã€‚ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ å› ä¸ºåœ¨$Chapter\\ 1$ä¸­æˆ‘ä»¬å·²ç»è°ˆåˆ°è¿‡çº¿æ®µæ ‘çš„$query$å’Œ$update$æ“ä½œçš„æœ¬è´¨äº†ï¼š $query$å‡½æ•°ï¼šæŠŠè¦æŸ¥è¯¢çš„åŒºé—´æ‹†æˆçº¿æ®µæ ‘ä¸Šè‡³å¤š$log$ä¸ªåŒºé—´æŠŠå®ƒä»¬çš„$Val$æŒ‰é¡ºåºåˆå¹¶èµ·æ¥ã€‚ $update$å‡½æ•°ï¼šæŠŠè¦ä¿®æ”¹çš„åŒºé—´æ‹†æˆçº¿æ®µæ ‘ä¸Šè‡³å¤š$log$ä¸ªåŒºé—´åˆ†åˆ«ç”¨ç»™å‡ºçš„$Tag$æ›´æ–°å®ƒä»¬çš„$Tag$å’Œ$Val$ã€‚ è¿™æ ·çš„è¯ï¼Œåªè¦æŒ‰ç…§é¡ºåºæŠŠè¿™$log$æ®µåŒºé—´æ‰¾åˆ°å†åˆèµ·æ¥ä¸€å®šå°±å¯ä»¥ç»´æŠ¤æ‰€æœ‰çš„æ“ä½œã€‚ å› ä¸ºæŒ‰ç…§$bfs$ç‰ˆæœ¬çš„é¡ºåºæ¥åˆå¹¶ä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚ å¦‚ä½•ç»´æŠ¤é¡ºåºï¼Ÿç”¨ä¸€ä¸ªé˜Ÿåˆ—å³å¯ã€‚ äºæ˜¯æˆ‘ä»¬å¯ä»¥ç»™å‡º$bfs$ç‰ˆçš„ä¸€äº›æ¡†æ¶ï¼Œè¿™é‡Œè·Ÿ$dfs$ç‰ˆæœ¬ç›¸åŒçš„å‡½æ•°å°±ä¸æ‹¿ä¸Šæ¥äº†ã€‚ ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152namespace SGT&#123; ... int q[N&lt;&lt;2],hd,tl; inline void build(int n)&#123; q[hd=tl=1]=1,T[1]=(Node)&#123;val_empty,tag_empty,1,n&#125;; while(hd&lt;=tl)&#123; int p=q[hd++]; if(T[p].l==T[p].r)&#123; T[p].val=(Val)&#123;...&#125;; continue; &#125; T[lc]=(Node)&#123;val_empty,tag_empty,T[p].l,mid&#125;; T[rc]=(Node)&#123;val_empty,tag_empty,mid+1,T[p].r&#125;; q[++tl]=lc,q[++tl]=rc; &#125; for(ri i=tl;i^1;--i)T[q[i]&gt;&gt;1].val+=T[q[i]].val; &#125; inline void update(int p,int ql,int qr,Tag v)&#123; q[hd=tl=1]=1; while(hd&lt;=tl)&#123; int p=q[hd++]; if(ql&gt;T[p].r||qr&lt;T[p].l)continue; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)&#123; pushnow(p,v); continue; &#125; pushdown(p); if(qr&lt;=mid)q[++tl]=lc,T[p].val=T[rc].val; else if(ql&gt;mid)q[++tl]=rc,T[p].val=T[lc].val; else q[++tl]=lc,q[++tl]=rc,T[p].val=val_empty; &#125; for(ri i=tl;i^1;--i)T[q[i]&gt;&gt;1].val+=T[q[i]].val; &#125; inline Val update(int p,int ql,int qr,Tag v)&#123; Val ret=val_empty; q[hd=tl=1]=1; while(hd&lt;=tl)&#123; int p=q[hd++]; if(ql&gt;T[p].r||qr&lt;T[p].l)continue; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)&#123; ret+=T[p].val; continue; &#125; pushdown(p); if(qr&lt;=mid)q[++tl]=lc; else if(ql&gt;mid)q[++tl]=rc; else q[++tl]=lc,q[++tl]=rc; &#125; return ret; &#125; ...&#125; ç»è¿‡æˆ‘ä»¬çš„åŠªåŠ›æ”¹åŠ¨ï¼Œä»£ç é‡æˆåŠŸç¿»äº†ä¸€å€ï¼ï¼ï¼(æ»‘ç¨½$Thatâ€™s\\ all$$Thank\\ you$","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]},{"title":"old driver tree","slug":"ODT","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-11T15:33:20.414Z","comments":true,"path":"ODT/","link":"","permalink":"http://ldxcaicai.github.io/ODT/","excerpt":"","text":"ODTç®€ä»‹ODT(old driver tree è€é©±åŠ¨æ ‘)åˆåç‚æœµè‰æ ‘ æ˜¯ç”±$codeforces$ä¸Šä¸€ä½å«åš$ODT$çš„ç”¨æˆ·æå‡ºçš„ä¸€ç§åŸºäºå¹³è¡¡æ ‘çš„æš´åŠ›æ•°æ®ç»“æ„ã€‚ï¼ˆå®é™…ä¸Šå°±æ˜¯ $lxl$ è¿™ä¸ªæ•°æ®ç»“æ„çš„ç„å¦™ä¹‹å¤„åœ¨äºå®ƒå¹¶æ²¡æœ‰ç¨³å®šçš„æ—¶é—´å¤æ‚åº¦ï¼Œå› æ­¤åªæœ‰åœ¨æ•°æ®éšæœº/æ°´çš„æƒ…å†µä¸‹æ‰ä¼šæœ‰è¾ƒå¥½çš„è¡¨ç°ã€‚ å®ç°å‰æ&amp;&amp;å®ç°åŸç†å‰ææ˜¯å¿…é¡»è¦æœ‰åŒºé—´è¦†ç›–æ“ä½œä¸”æ•°æ®è¾ƒéšæœº/æ°´ å®ç°åŸç†ï¼šå°†å…ƒç´ ç›¸åŒçš„åŒºé—´æ¨å¹³ä¸€èµ·å¤„ç†ï¼Œå³å¦‚æœåŒºé—´$[l,r]$ä¸­çš„æ‰€æœ‰æ•°$[a_l,a_{l+1}â€¦a_r]$å…¨éƒ¨ç›¸åŒçš„è¯å°±å°†è¿™ä¸ªåŒºé—´çš„ä¿¡æ¯ç”¨ä¸€ä¸ªèŠ‚ç‚¹è¡¨ç¤ºã€‚ ä»ä¸Šè¿°æè¿°å¯ä»¥çœ‹å‡ºè¿™ä¸ªæ•°æ®ç»“æ„æ˜¯éå¸¸æš´åŠ›ç„å­¦çš„ åˆå§‹åŒ–ç„¶åå¯¹äºæ¯æ®µåŒºé—´æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªä¸‰å…ƒç»„$[l,r,v]$æ¥è¡¨ç¤ºå®ƒçš„å·¦/å³ç«¯ç‚¹å’Œæ•´ä¸ªåŒºé—´çš„å€¼ï¼Œç„¶åå¯¹äºè¿™äº›åŒºé—´çš„ä¿¡æ¯å¯ä»¥ç”¨ä¸€ä¸ª$set$æ¥ç»´æŠ¤ã€‚ ä¸‹é¢è°ˆè°ˆ$ODT$ä¸¤ä¸ªé‡è¦çš„æ“ä½œ$split$å’Œ$assign$ splitæ“ä½œ$ODT$çš„$split$å‡½æ•°$split(pos)$è¡¨ç¤ºæŠŠ$pos$æ‰€åœ¨çš„è¿™ä¸ªåŒºé—´$[l,r,v]$åˆ†æˆ$[l,pos-1,v]$å’Œ$[pos,r,v]$å¹¶ä¸”è¿”å›åè€…çš„è¿­ä»£å™¨ã€‚ å®ç°å¾ˆç®€å•ç›´æ¥äºŒåˆ†æ‰¾å‡º$pos$æ‰€åœ¨çš„åŒºé—´ç„¶ååŠ å‡ ä¸ªå°ç‰¹åˆ¤ã€‚ assignæ“ä½œ$ODT$æœ€æ ¸å¿ƒçš„æ“ä½œ$assign$ï¼Œ$assign(l,r,v)$è¡¨ç¤ºæŠŠåŒºé—´$[l,r]$å…¨éƒ¨èµ‹å€¼ä¸º$v$å¹¶ä¸”ä¼šå°†è¿™$r-l+1$ä¸ªç‚¹åˆå¹¶æˆä¸€ä¸ª$ODT$èŠ‚ç‚¹æ’å…¥åˆ°$ODT$ä¸­ï¼Œç”±äºæ•°æ®éšæœºçš„æ—¶å€™$ODT$ä¸­èŠ‚ç‚¹ä¼šå¿«é€Ÿå‡å°‘ï¼Œå› æ­¤$ODT$å¤æ‚åº¦æ­¤æ—¶ååˆ†æ¥è¿‘$O(n\\log n)$å…·ä½“å®ç°å¯ä»¥é€šè¿‡ä¸Šé¢æåˆ°çš„$split$å‡½æ•°ã€‚ å…¶å®ƒæ“ä½œè‡³æ­¤ï¼Œä¸$ODT$ç›¸å…³çš„æ“ä½œå·²ç»åŸºæœ¬è®²å®Œäº†ã€‚ å‰©ä¸‹çš„æ“ä½œä¸$ODT$æœ¬èº«å…³ç³»å¹¶ä¸å¤§ï¼Œç›¸å½“äºå°±æ˜¯éå†æ¯ä¸€ä¸ª$ODT$èŠ‚ç‚¹æš´åŠ›è¿›è¡Œä¿®æ”¹å’ŒæŸ¥è¯¢ã€‚å®ƒå¯ä»¥æ”¯æŒçš„æ“ä½œï¼ˆæ‡’å¾—æ”¾ä»£ç äº†ï¼‰ï¼š åŒºé—´ç¬¬kå°åŒºé—´åŠ åŒºé—´æ‰€æœ‰æ•°çš„kæ¬¡æ–¹å’ŒåŒºé—´â€¦","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"å­¦ä¹ ç¬”è®°","slug":"å­¦ä¹ ç¬”è®°","permalink":"http://ldxcaicai.github.io/tags/å­¦ä¹ ç¬”è®°/"}]}]}