{"meta":{"title":"自由を渇望する","subtitle":"ひとりぼっち","description":"Konjak_ldx's blog","author":"ldxcaicai","url":"http://ldxcaicai.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-10-11T13:19:45.009Z","updated":"2019-10-11T13:19:45.009Z","comments":false,"path":"categories/index.html","permalink":"http://ldxcaicai.github.io/categories/index.html","excerpt":"","text":"Githubgithub: username: ldxcaicai # github username"},{"title":"友情链接","date":"2019-10-11T13:48:25.405Z","updated":"2019-10-11T13:48:25.405Z","comments":true,"path":"links/index.html","permalink":"http://ldxcaicai.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-11T13:58:52.069Z","updated":"2019-10-11T13:58:52.069Z","comments":false,"path":"tags/index.html","permalink":"http://ldxcaicai.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"杂题乱做 Round12","slug":"sol12","date":"2019-12-26T03:47:36.000Z","updated":"2019-12-26T04:18:08.228Z","comments":true,"path":"sol12/","link":"","permalink":"http://ldxcaicai.github.io/sol12/","excerpt":"","text":"某位歌姬的故事解题思路 将序列离散化后，可以给每一段区间定一个最大值的最小上界，那么每一种上界的值是独立的，考虑把相同上界的块扯出来 DP 对于一种上界，把对应的段和限制提出来，对于每个块维护一个 $maxl$ 表示处理到区间 $i$ 时，最后填入的一个等于上界的值所在的块标号应该不小于 $maxl$ ，对于一个限制对应的块 $[l,...,r]$ ，我们用 $l$ 更新 $maxl[r]$ ，最后直接 DP 设 $f_{i,j}$ 表示当前在第 $i$ 块，最后一个填的等于上界的数在第 $j$ 块的方案数 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;template&lt;typename T&gt; inline void ckmin(T&amp;a,T b) &#123; a&gt;b?a=b:0; &#125;template&lt;typename T&gt; inline void ckmax(T&amp;a,T b) &#123; a&lt;b?a=b:0; &#125;const int N=1005;int n,m,A,seg[N],sz,vl[N],sig,a[N];struct Q &#123; int l,r,v; friend inline bool operator&lt;(Q a,Q b) &#123; return a.v^b.v?a.v&lt;b.v:(a.l^b.l?a.l&lt;b.l:a.r&lt;b.r); &#125;&#125;qry[N];inline int findps(int x) &#123; return lower_bound(seg+1,seg+sig+1,x)-seg; &#125;inline int findvl(int x) &#123; return lower_bound(vl+1,vl+sz+1,x)-vl; &#125;inline int calc(int w) &#123; vector&lt;int&gt;upd,psl,f[2]; int cur=0; upd.pb(0),f[0].pb(0),f[1].pb(0),psl.pb(0); for(ri i=1;i&lt;sig;++i) if(a[i]==w) upd.pb(i),psl.pb(0),f[0].pb(0),f[1].pb(0); for(ri l,r,i=1;i&lt;=m;++i) if(qry[i].v==w) &#123; if(upd.size()==1) return 0; l=lower_bound(upd.begin(),upd.end(),qry[i].l)-upd.begin(); r=lower_bound(upd.begin(),upd.end(),qry[i].r)-upd.begin()-1; ckmax(psl[r],l); &#125; f[cur=0][0]=1; for(ri i=1,s,c1,c2,up=(int)upd.size()-1;i&lt;=up;++i) &#123; cur^=1; for(ri j=0;j&lt;=i;++j) f[cur][j]=0; c1=ksm(vl[w],seg[upd[i]+1]-seg[upd[i]]),c2=ksm(vl[w]-1,seg[upd[i]+1]-seg[upd[i]]); s=0; for(ri j=psl[i];j&lt;i;++j) if(f[cur^1][j]) Add(f[cur][j],mul(f[cur^1][j],c2)); for(ri j=0;j&lt;i;++j) if(f[cur^1][j]) Add(s,f[cur^1][j]); f[cur][i]=mul(dec(c1,c2),s); &#125; int res=0; for(ri i=0,up=(int)upd.size()-1;i&lt;=up;++i) Add(res,f[cur][i]); return res;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt) &#123; n=read(),m=read(),A=read(); sig=sz=0; for(ri i=1;i&lt;=m;++i) &#123; qry[i].l=read(),qry[i].r=read()+1,qry[i].v=read(); seg[++sig]=qry[i].l,seg[++sig]=qry[i].r,vl[++sz]=qry[i].v; &#125; seg[++sig]=1,seg[++sig]=n+1; sort(seg+1,seg+sig+1),sig=unique(seg+1,seg+sig+1)-seg-1; sort(vl+1,vl+sz+1),sz=unique(vl+1,vl+sz+1)-vl-1; for(ri i=1;i&lt;=sig;++i) a[i]=sz+1; sort(qry+1,qry+m+1); for(ri i=1;i&lt;=m;++i) &#123; qry[i].l=findps(qry[i].l); qry[i].r=findps(qry[i].r); qry[i].v=findvl(qry[i].v); for(ri j=qry[i].l;j&lt;qry[i].r;++j) ckmin(a[j],qry[i].v); &#125; int res=1,ss=0; for(ri i=1;i&lt;=sz;++i) &#123; Mul(res,calc(i)); if(!res) break; &#125; if(!res ) &#123; puts(\"0\");continue; &#125; for(ri i=1;i&lt;sig;++i) if(a[i]==sz+1) ss+=seg[i+1]-seg[i]; cout&lt;&lt;mul(res,ksm(A,ss))&lt;&lt;'\\n'; &#125; return 0;&#125; 九个太阳解题思路 ~~单位根反演裸题，不用写题解了~~ 好吧还是水一发题解吧。 $$ \\begin{aligned} Ans=&\\sum\\limits_{i=0}^n(\\sum\\limits_{j=0}^{K-1}\\omega_K^{ij})\\binom ni\\\\ =&\\sum\\limits_{i=0}^{K-1}\\sum\\limits_{j=0}^n\\omega_K^{ij}\\binom nj\\\\ =&\\sum\\limits_{i=0}^{K-1}(\\omega_K^i+1)^n \\end{aligned} $$ CODE 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;ll n;int K,omega;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif cin&gt;&gt;n&gt;&gt;K; n%=mod-1; omega=ksm(3,(mod-1)/K); int res=0; for(ri i=0,mt=1;i&lt;K;++i,Mul(mt,omega)) Add(res,ksm(mt+1,n)); cout&lt;&lt;mul(res,Inv(K)); return 0;&#125; Hard Nim解题思路 考虑到问题转化为求异或值为 $0$ 的方案数，那么对于每堆石子可以选取的集合为不超过 $m$ 的素数集合，发现就是个 $fwt$ 快速幂 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;namespace modular &#123; const int mod=1e9+7; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;const int N=50005;int n,m,pri[N],tot=0,a[N&lt;&lt;1];bool vs[N];inline void init() &#123; int up=50000; for(ri i=2;i&lt;=up;++i) &#123; if(!vs[i]) pri[++tot]=i; for(ri j=1,lm=up/i;j&lt;=tot&amp;&amp;pri[j]&lt;=lm;++j) &#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]) break; &#125; &#125;&#125;int lim;inline void fwt(int*a,int typ) &#123; for(ri i=1,a0,a1,iv=mod+1&gt;&gt;1;i&lt;lim;i&lt;&lt;=1) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) &#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv); &#125;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); while(cin&gt;&gt;n&gt;&gt;m) &#123; lim=1; while(lim&lt;=m) lim&lt;&lt;=1; for(ri i=0;i&lt;lim;++i) a[i]=0; for(ri i=1;i&lt;=tot&amp;&amp;pri[i]&lt;=m;++i) a[pri[i]]=1; fwt(a,1); for(ri i=0;i&lt;lim;++i) a[i]=ksm(a[i],n); fwt(a,-1); cout&lt;&lt;a[0]&lt;&lt;'\\n'; &#125; return 0;&#125; 二元运算解题思路 题目给出了两种基础卷积方式，发现刚好是 $x1,j>1)$ 的系数是 $\\binom{n+n-i-j}{n-i}a^{n-j}b^{n-i}$ ，格子 $(1,i>1)$ 的系数是 $\\binom{n+n-2-i}{n-2}a^{n-i}b^{n-1}$ ，格子 $(i>1,1)$ 的系数是 $\\binom{n+n-2-i}{n-2}a^{n-1}b^{n-i}$ ，那么显然 $$ \\begin{aligned} Ans=&\\sum\\limits_{i=2}^nf_{1,i}\\binom{n+n-2-i}{n-2}a^{n-i}b^{n-1}+\\sum\\limits_{i=2}^nf_{i,1}\\binom{n+n-2-i}{n-2}a^{n-1}b^{n-i}+\\sum\\limits_{i=2}^n\\sum\\limits_{j=2}^nc\\binom{n+n-i-j}{n-i}a^{n-j}b^{n-i} \\end{aligned} $$ 发现前面的可以 $O(n)$ 算后面的可以卷积算，复杂度 $O(n\\log n)$ ~~其实后面的式子可以用组合数推出O(n)的式子但由于我太懒了就不写了，可以参见官方题解~~ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;struct cp &#123; double x,y; cp(double x=0,double y=0):x(x),y(y) &#123;&#125; friend inline cp operator+(cp a,cp b) &#123; return cp(a.x+b.x,a.y+b.y); &#125; friend inline void operator+=(cp&amp;a,cp b) &#123; a=a+b; &#125; friend inline cp operator-(cp a,cp b) &#123; return cp(a.x-b.x,a.y-b.y); &#125; friend inline void operator-=(cp&amp;a,cp b) &#123; a=a-b; &#125; friend inline cp operator*(cp a,cp b) &#123; return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); &#125; friend inline void operator*=(cp&amp;a,cp b) &#123; a=a*b; &#125; friend inline cp operator*(cp a,double b) &#123; return cp(a.x*b,a.y*b); &#125; friend inline void operator*=(cp&amp;a,double b) &#123; a=a*b; &#125; friend inline cp operator/(cp a,double b) &#123; return cp(a.x/b,a.y/b); &#125; friend inline void operator/=(cp&amp;a,double b) &#123; a=a/b; &#125; inline cp operator~() const &#123; return cp(x,-y); &#125;&#125;;typedef vector&lt;cp&gt; poly;const double pi=acos(-1.0);int lim,tim;vector&lt;cp&gt; w[20];vector&lt;int&gt;rev[20];inline void init_fft() &#123; w[19].resize(1&lt;&lt;19); for(ri i=0,lm=1&lt;&lt;19;i&lt;lm;++i) w[19][i]=cp(cos(pi/lm*i),sin(pi/lm*i)); for(ri i=18;~i;--i) &#123; w[i].resize(1&lt;&lt;i); for(ri j=0,up=1&lt;&lt;i;j&lt;up;++j) w[i][j]=w[i+1][j&lt;&lt;1]; &#125;&#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void fft(poly&amp;a,int typ) &#123; for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); cp a0,a1; for(ri i=1,t=0;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; for(ri k=0;k&lt;i;++k) &#123; a0=a[j+k],a1=a[j+k+i]*w[t][k]; a[j+k]=a0+a1,a[j+k+i]=a0-a1; &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) a[i]/=lim;&#125;namespace modular &#123; const int mod=1e6+3; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=4e5+5,blo=1023;inline int poly_mul(int*a,int*b,int n,int m,int*c) &#123; int t=n+m-1; init(t); poly A(lim),B(lim),P(lim),Q(lim); for(ri i=0;i&lt;n;++i) A[i]=cp(a[i]&gt;&gt;10,a[i]&amp;blo); for(ri i=0;i&lt;m;++i) B[i]=cp(b[i]&gt;&gt;10,b[i]&amp;blo); fft(A,1),fft(B,1); cp cur[4]; for(ri i=0,j=0;i&lt;lim;++i,j=j?j-1:lim-1) &#123; cur[0]=(A[i]+(~A[j]))*cp(0.5,0); cur[1]=((~A[j])-A[i])*cp(0,0.5); cur[2]=(B[i]+(~B[j]))*cp(0.5,0); cur[3]=((~B[j])-B[i])*cp(0,0.5); P[i]=cur[0]*cur[2]+cp(0,1)*cur[1]*cur[3]; Q[i]=cur[0]*cur[3]+cp(0,1)*cur[1]*cur[2]; &#125; fft(P,-1),fft(Q,-1); ll cr[4]; for(ri i=0;i&lt;t;++i) &#123; cr[0]=(ll)(P[i].x+0.5)%mod; cr[1]=(ll)(P[i].y+0.5)%mod; cr[2]=(ll)(Q[i].x+0.5)%mod; cr[3]=(ll)(Q[i].y+0.5)%mod; c[i]=((cr[0]&lt;&lt;20)+(cr[2]+cr[3]&lt;&lt;10)+cr[1])%mod; &#125; return t;&#125;int n,c,vl1[N&gt;&gt;1],vl2[N&gt;&gt;1],fac[N],ifac[N],pwa[N&gt;&gt;1],pwb[N&gt;&gt;1];inline void init() &#123; int up=n&lt;&lt;1; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=up;++i) &#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=up;++i) Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m) &#123; return n&lt;m||m&lt;0?0:(ll)fac[n]*ifac[m]*ifac[n-m]%mod; &#125;int F[N&gt;&gt;1],G[N&gt;&gt;1],H[N],len;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init_fft(); pwa[0]=pwb[0]=1; n=read(),pwa[1]=read(),pwb[1]=read(),c=read(); init(); for(ri i=2;i&lt;=n;++i) pwa[i]=mul(pwa[i-1],pwa[1]),pwb[i]=mul(pwb[i-1],pwb[1]); for(ri i=1;i&lt;=n;++i) vl1[i]=read(); for(ri i=1;i&lt;=n;++i) vl2[i]=read(); int res=0; for(ri i=2;i&lt;=n;++i) &#123; Add(res,mul(mul(vl1[i],C((n&lt;&lt;1)-2-i,n-2)),mul(pwa[n-1],pwb[n-i]))); Add(res,mul(mul(vl2[i],C((n&lt;&lt;1)-2-i,n-2)),mul(pwb[n-1],pwa[n-i]))); &#125; for(ri i=0;i&lt;n-1;++i) F[i]=mul(ifac[i],pwa[i]),G[i]=mul(ifac[i],pwb[i]); len=poly_mul(F,G,n-1,n-1,H); for(ri i=0;i&lt;len;++i) Add(res,mul(mul(c,fac[i]),H[i])); cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"追忆","slug":"remembrance","date":"2019-12-26T02:08:32.000Z","updated":"2019-12-26T02:56:37.844Z","comments":true,"path":"remembrance/","link":"","permalink":"http://ldxcaicai.github.io/remembrance/","excerpt":"","text":"About Backseat_Stargazer初识在初三的时候 zgs 请了 rxdoi 到 cdss 讲课，我和 yk 都前往听课，期间在 zgs 的介绍下认识了 zxy 和 cyk ，听说了 cyk 一个下午+晚上从零基础学完简单图论以及成实外三校区文化课 rk 前10 的神仙事迹。但当时由于 cyk 一直在睡觉，于是他两边的我和 zxy 就常常一脸懵逼的望着他睡觉然后继续听课或者讨论题目 后来本人说是生病了，我倒是认为他觉得太简单了索性不听了 就这样，短暂的认识又马上忘记了 cyk 之后，我开始颓废生活准备中考 再会中考之后果然在 cdsszx 又见面了，这次 zgs 干脆直接钦定 cyk 成为未来的金牌选手了 Orz ，让他跟我们几个一起混学习 OI ，然后中考成绩出来之后 yk 和 zyj 就溜了，我因为 cdqz 神仙太多的原因就留下了，发现厉害的就只剩下了 cyk 和 zxy （当然暑假快结束时 lmy 突然变强以至于比较厉害的变成了四个人），之后由于 cyk 前置知识学过的太少于是跟我们分成了两个教室听课，后面大家集中在一起考试感觉 cyk 的考试乘积虽然不怎么稳定但是实力开始指数级上升现在看来可能 cyk 当时在战略性犯一些小错误以隐藏实力，但由于他乘积时高时低我当时觉得这个 cyk 好像没 zgs 吹那么厉害后来我就被吊起来锤了于是就开始 diss 他现在他有能力 diss 我但一直不 diss。暑假末的时候，cyk 来找我说他想入门线段树，我沉思许久之后给他推荐了一道 siano ，结果由于代码能力还没有起来的原因， cyk 翻了三页的车（指提交代码）才过，搞得现在每次我推题都会被他吐槽==，然后开学学了一个月文化课之后就开始停课冲刺 NOIp ，期间我由于初中做过的 sb 多以及手速相对快一点的原因拿了几次 rk1 ，感觉心态稳健， cyk 仍然是波动曲线不过看起来比原来强好多了。感觉停课的时间算是机房群体所有人感情增进最迅速的时间段了废话本来就不是一个班的只有这个时候才有那么多时间拿来交流，让我印象深刻的是我和 cyk 有几次周末都留下来上晚自习讨论问题到 10 点过才走，印象最深刻的还是有一次讨论概率期望 dp 入门题，貌似激动地差点吵起来了，然后就 NOIp 了发现自己菜的一批的同时已经被 cyk 吊起来锤了 然后我就学会了看番 然后去雅礼和绍兴集训感觉我可能相对其他几个更擅长打暴力分貌似还是高一点，有点高兴，那段时间感觉 cyk 和 zxy 实力还是指数级提升，然后就有了排名交换的感觉吧，感觉实力排名从刚进校的 ldx&amp;zxy,lmy&amp;cyk ，变成了 zxy,cyk,ldx&amp;lmy ，然后就 scoi 了，我 day2MLE的事情大家都知道不然排名跟zxy差不多（虽然可能也进不了D） ，得了，现在分数排名也成 zxy,cyk,ldx&amp;lmy 了 之后休息了一段时间上了一段时间文化课之后去ez集训，慢慢感觉实力水平变回了 zxy,ldx,cyk,lmy ，推测原因是因为 cyk 和 lmy 有一些算法没学以及有一些暴力不想打，但是由于本人太颓了以至于后半段集训不怎么改题，慢慢的实力变成了 zxy,cyk,lmy,ldx 大哭，网络赛由于其余三个发挥失误了好像又拿了个四人里的 rk1 ，事后比较心怀侥幸 noi 过后就请人讲课了，然后开学开始停课，发现 zxy 实力比我们仨高了几个档，于是之后的实力评比 zxy 不再参与，用学弟 fsy 的水平拿来替代 cdss 的集训策略大概是考两天休息一天的样子，这导致我这种经常熬夜的第二天考试不清醒，因此往往考出来的乘积排名是 cyk&amp;fsy,lmy,ldx ，但我实际感觉我应该还是跟 lmy 水平差不多吧，结果 CSP-S 2019 前我的状态崩的更厉害了，基本场场考不过联赛组神仙，吓得我 CSP-S 前几天开始莽之前的 NOIp 真题 我 CSP-S 和 NOIp 有个 P 的关系，在 day0 上午终于莽完了，心态好了一点感觉还是有希望上 450 的，NMD,最后还真就没上 450 ，然后就是联赛了，考完感觉考了个大众分估计只能排 30~50 名了， lmy 因为翻车严重可能要退役了， cyk 应该分数跟我差不多， zxy 应该稳了。 直到下午 cyk 告诉我他 d1t2 只有 50 了 然后当时我的心情是难以置信，感觉实力比我强的 cyk 不可能翻在这种 sbt 上面 最后还真就翻了，NMDWSM 感觉生活就像多米诺骨牌一样，打翻了最开始的那一张，就会产生一系列的连锁反应： cyk 没有跟我们一起去ez参加冬令营集训 cyk 考了 pkuwc 一等奖的线但由于是非正式营员不能领奖 cyk 现在回去上了文化课 MD PKU 这个操作真 TMZZ，明明都跟 cyk 约好了 day2 翻盘（并且我俩还真翻了）结果突然来个不能拿奖？？？ 可能这就是命运对强者的惩罚吧 所幸的是 cyk 寒假复役，还能一起战斗，还能问 cyk 沙雕问题，还能有机会和他互相口吐芬芳，在此之前，我还是得提升自己水平以至于到时候不会听不懂 cyk 和 zxy 在讲什么神仙东西 （不过你看看我现在写这篇不知道在写什么的东西的时候 zxy 又做了好几道题了，我还啥都没做，实力差距没法弥补啊）","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://ldxcaicai.github.io/tags/随笔/"}]},{"title":"杂题乱做 Round11","slug":"sol11","date":"2019-12-24T15:12:07.000Z","updated":"2019-12-25T00:05:39.723Z","comments":true,"path":"sol11/","link":"","permalink":"http://ldxcaicai.github.io/sol11/","excerpt":"","text":"Triple解题思路： 还是跟 黎明前的巧克力 差不多，构造集合幂级数，那么答案等于 $\\prod\\limits_{i=1}^n(ax^{X_i}+bx^{Y_i}+cx^{Z_i})$ ，这样每一个式子对答案的贡献一定是 $\\pm a\\pm b\\pm c$ ，但直接 $fwt$ 之后解方程常数实在太大，考虑优化，发现可以把式子改写成 $\\sum\\limits_{i=1}^n(a+b^{Y_i\\oplus X_i}+c^{Z_i\\oplus X_i})$ 最后给结果异或上 $\\oplus_{i=1}^nX_i$ ，显然上述两种方式得到的结果是一样的，那么这次每个式子对答案的贡献就是 $a\\pm b\\pm c$ ，于是就如同前置题目一样分别把 $\\sum\\limits_{i=1}^nx^{Y_i\\oplus X_i},\\sum\\limits_{i=1}^nx^{Z_i\\oplus X_i},\\sum\\limits_{i=1}^nx^{Y_i\\oplus Z_i}$ 给 $dwt$ 掉，算成正确点值之后再 $idwt$ 回去就行了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register inttypedef long long ll;using namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e6+5;int lim,n,X,Y,Z,vl[4],a[N],b[N],c[N];inline void dwt(int*a,int typ) &#123; for(ri i=1,a0,a1,iv=mod+1&gt;&gt;1;i&lt;lim;i&lt;&lt;=1)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) &#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv); &#125;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),lim=1&lt;&lt;read(); X=read(),Y=read(),Z=read(); int ss=0; for(ri i=1,_a,_b,_c;i&lt;=n;++i) &#123; _a=read(),_b=read()^_a,_c=read()^_a; ss^=_a; ++a[_b^_c],++b[_b],++c[_c]; &#125; dwt(a,1),dwt(b,1),dwt(c,1); vl[0]=add(X,add(Y,Z)); vl[1]=add(X,dec(Y,Z)); vl[2]=add(X,dec(Z,Y)); vl[3]=dec(X,add(Y,Z)); for(ri iv=Inv(4),x,y,z,w,i=0;i&lt;lim;++i) &#123; x=mul(iv,add(add(n,a[i]),add(b[i],c[i]))); y=mul(iv,dec(add(n,b[i]),add(c[i],a[i]))); z=mul(iv,dec(add(n,c[i]),add(b[i],a[i]))); w=mul(iv,dec(add(n,a[i]),add(b[i],c[i]))); a[i]=mul(mul(ksm(vl[0],x),ksm(vl[1],y)),mul(ksm(vl[2],z),ksm(vl[3],w))); &#125; dwt(a,-1); for(ri i=0;i&lt;lim;++i) cout&lt;&lt;a[i^ss]&lt;&lt;' '; return 0;&#125; 小 Y 的背包计数问题解题思路： 对于第 $i$ 种物品，如果按照模 $i$ 的余数记录前缀和做背包 $DP$ 的话复杂度是 $O(ni)$ 的，那么考虑对前 $K$ 种物品按照上述做法进行背包，那么后面的物品最多能选 $\\frac nK$ 个，所以考虑如下 $DP$ ，设后面所有物品一共选了 $i$ 个，总和为 $j$ 的方案数，对于转移作如下考虑，我们想象这 $i$ 个物品排好序放在一个序列上，现在有两种操作： 1. 在队首插入一个大小为 $K+1$ 的物品 2. 给当前所有物品权值+1 这样能做到不重不漏，复杂度为 $O(\\frac{n^2}K)$ ，因此 $K$ 取 $\\sqrt n$ 时最优 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=23333333; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e5+5;int f[2][N],cur,g[350][N],n,sum[350],ss[N];int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); f[cur=0][0]=1; int res=0,sig=sqrt(n); for(ri x,id=1;id&lt;=sig;++id) &#123; x=id*id; cur^=1; for(ri i=0;i&lt;id;++i) sum[i]=0; for(ri i=0,t=0;i&lt;=n;++i,t=t==id-1?0:t+1) &#123; Add(sum[t],f[cur^1][i]); f[cur][i]=sum[t]; if(i&gt;=x) Dec(sum[t],f[cur^1][i-x]); &#125; &#125; g[0][0]=1; for(ri i=0;i&lt;=sig;++i) for(ri j=0;j&lt;=n;++j) if(g[i][j]) &#123; if(i&amp;&amp;i+j&lt;=n) Add(g[i][j+i],g[i][j]); if(j+sig+1&lt;=n) Add(g[i+1][j+sig+1],g[i][j]); if(j) Add(ss[j],g[i][j]); &#125; ss[0]=1; for(ri i=0;i&lt;=n;++i) Add(res,mul(ss[i],f[cur][n-i])); cout&lt;&lt;res; return 0;&#125; 最大前缀和解题思路： 暴力枚举每种前缀的集合为最大前缀和的答案那么后面填上的数组成的任意前缀和都必须小于0，把这个方案数设为 $g$ 类似考虑一个集合作为最大前缀和，把这个序列反过来，则一定不存在前缀和小于0，于是同理定义一个 $f$ ，把这两个状压 $dp$ 出来即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch=='-',ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;const int N=25;int n,lim;ll s1[1&lt;&lt;20];int s2[1&lt;&lt;20],f[1&lt;&lt;20],g[1&lt;&lt;20];inline void fmt(ll*a1,int*a2) &#123; for(ri i=1;i&lt;lim;i&lt;&lt;=1) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) s1[j+k+i]+=s1[j+k],Add(s2[j+k+i],s2[j+k]);&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),lim=1&lt;&lt;n; for(ri i=0;i&lt;n;++i) s1[1&lt;&lt;i]=read(),s2[1&lt;&lt;i]=fix(s1[1&lt;&lt;i]),f[1&lt;&lt;i]=1; fmt(s1,s2); g[0]=1; for(ri i=1;i&lt;lim;++i) &#123; if(s1[i]&gt;=0) &#123; for(ri j=0;j&lt;n;++j) if(!(i&gt;&gt;j&amp;1)) Add(f[i|(1&lt;&lt;j)],f[i]); &#125; else for(ri j=0;j&lt;n;++j) if(i&gt;&gt;j&amp;1) Add(g[i],g[i^(1&lt;&lt;j)]); &#125; int res=0; for(ri i=1;i&lt;lim;++i) Add(res,mul(mul(s2[i],f[i]),g[(lim-1)^i])); cout&lt;&lt;res; return 0;&#125; Chef and Horcrux解题思路： 先简单求出 $mex$ 为 $i$ 的子序列个数，然后直接 $K$ 进制 $fwt$ 转点值，然后快速幂一下再转回去统计答案就完了 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl() &#123; ll ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=330301441; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e5+5;int n,K,X,pw[N],inv[11],a[N&lt;&lt;4],cnt[N],mx,lim,w[11][11];inline void init() &#123; pw[0]=1; for(ri i=1;i&lt;=100000;++i) pw[i]=add(pw[i-1],pw[i-1]); inv[1]=1; for(ri i=2;i&lt;11;++i) &#123; inv[i]=mul(inv[mod-mod/i*i],mod-mod/i),w[i][0]=1,w[i][1]=ksm(3,(mod-1)/(i&lt;&lt;1)); for(ri j=2;j&lt;i;++j) w[i][j]=mul(w[i][j-1],w[i][1]); &#125;&#125;inline void fft(int*a,int typ) &#123; static int sum[11]; for(ri j=0;j&lt;K;++j) if(a[j]) for(ri i=0,t=0;i&lt;K;++i,t=t+j&lt;K?t+j:t+j-K) Add(sum[i],mul(a[j],w[K][t])); for(ri i=0;i&lt;K;++i) a[i]=sum[i],sum[i]=0; if(~typ) return; for(ri i=1;i+i&lt;K;++i) swap(a[i],a[K-i]); for(ri i=0;i&lt;K;++i) Mul(a[i],inv[K]);&#125;inline void fwt(int*a,int typ) &#123; static int cur[11]; for(ri i=1;i&lt;lim;i*=K) for(ri j=0,len=i*K;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) &#123; for(ri o=0;o&lt;K;++o) cur[o]=a[o*i+j+k]; fft(cur,typ); for(ri o=0;o&lt;K;++o) a[o*i+j+k]=cur[o]; &#125;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri ps,tt=read();tt;--tt) &#123; n=read(),K=read(),X=readl()%(mod-1); mx=0; for(ri i=1,x;i&lt;=n;++i) x=read(),++cnt[x],mx=max(mx,x); ++mx; for(ri i=0,pre=0,premt=1;i&lt;=mx;++i) &#123; pre+=cnt[i]; a[i]=mul(premt,pw[n-pre]); if(!cnt[i]) &#123; ps=i;break; &#125; Mul(premt,dec(pw[cnt[i]],1)); &#125; for(lim=1;lim&lt;=ps;lim*=K); int res=0,ss=ksm(Inv(pw[n]),X); fwt(a,1); for(ri i=0;i&lt;lim;++i) a[i]=ksm(a[i],X); fwt(a,-1); for(ri i=0;i&lt;lim;++i) if(a[i]) Mul(a[i],ss),Add(res,mul(ksm(i,2*i),ksm(a[i],3*i))),a[i]=0; cout&lt;&lt;res&lt;&lt;'\\n'; for(ri i=0;i&lt;=mx;++i) cnt[i]=0; &#125; return 0;&#125; 生成树求和解题思路： 主要是得观察到可以按位考虑，那么每一位本来应该是做不进位加法但是矩阵树只能做乘法，因此我们将其转为点值，矩阵树之后再转回来即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=1e9+7,iv3=(mod+1)/3; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;struct cp &#123; int a,b; cp(int a=0,int b=0):a(a),b(b) &#123;&#125; friend inline cp operator+(cp a, cp b) &#123; return cp(add(a.a,b.a),add(a.b,b.b)); &#125; friend inline void operator+=(cp&amp;a,cp b) &#123; a=a+b; &#125; friend inline cp operator-(cp a,cp b) &#123; return cp(dec(a.a,b.a),dec(a.b,b.b)); &#125; friend inline void operator-=(cp&amp;a,cp b) &#123; a=a-b; &#125; friend inline cp operator*(cp a,cp b) &#123; return cp(dec(mul(a.a,b.a),mul(a.b,b.b)),dec(add(mul(a.a,b.b),mul(a.b,b.a)),mul(a.b,b.b))); &#125; friend inline void operator*=(cp&amp;a,cp b) &#123; a=a*b; &#125; friend inline cp operator*(cp a,int b) &#123; return cp(mul(a.a,b),mul(a.b,b)); &#125; friend inline void operator*=(cp&amp;a,int b) &#123; a=a*b; &#125; inline cp inv() const &#123; return cp(dec(a,b),mod-b)*Inv(dec(add(mul(a,a),mul(b,b)),mul(a,b))); &#125; friend inline cp operator/(cp a,cp b) &#123; return a*(b.inv()); &#125; friend inline void operator/=(cp&amp;a,cp b) &#123; a=a/b; &#125; friend inline bool operator!=(cp a,cp b) &#123; return a.a^b.a||a.b^b.b; &#125;&#125;w[3];const int N=105;int n,m;cp a[N][N];struct edge&#123; int u,v,w; edge(int u=0,int v=0,int w=0):u(u),v(v),w(w) &#123;&#125;&#125;e[N*N&gt;&gt;1];inline cp Det() &#123; cp res(1,0),iv,t; vector&lt;int&gt;pos; for(ri ps,i=1;i&lt;n;++i) &#123; for(ps=i;ps&lt;n;++ps) if(a[ps][i]!=cp(0,0)) break; if(ps==n) &#123; res=cp(0,0);break; &#125; if(ps&gt;i) &#123; res=cp(mod-res.a,mod-res.b); for(ri j=1;j&lt;n;++j) swap(a[i][j],a[ps][j]); &#125; pos.clear(); for(ri j=i;j&lt;n;++j) if(a[i][j]!=cp(0,0)) pos.pb(j); iv=a[i][i].inv(); for(ri j=i,up=pos.size();j&lt;n;++j) if(a[j][i]!=cp(0,0)&amp;&amp;j!=i) &#123; t=iv*a[j][i]; for(ri k=0;k&lt;up;++k) a[j][pos[k]]-=a[i][pos[k]]*t; &#125; res*=a[i][i]; &#125; for(ri i=1;i&lt;n;++i) for(ri j=1;j&lt;n;++j) a[i][j]=cp(0,0); return res;&#125;cp cur[3];int vl[N*N&gt;&gt;1];inline void idft() &#123; static cp sum[3]; for(ri j=0;j&lt;3;++j) for(ri i=0;i&lt;3;++i) sum[i]+=cur[j]*w[i*j&lt;3?i*j:i*j-3]; for(ri i=0;i&lt;3;++i) cur[i]=sum[i]*iv3,sum[i]=cp(0,0); swap(cur[1],cur[2]);&#125;inline int calc() &#123; return add(cur[1].a,add(cur[2].a,cur[2].a)); &#125;int main() &#123; freopen(\"sum.in\",\"r\",stdin); freopen(\"sum.out\",\"w\",stdout); n=read(),m=read(); w[0]=cp(1,0); w[1]=cp(0,1); w[2]=cp(mod-1,mod-1); int mx=0,res=0; for(ri i=1;i&lt;=m;++i) e[i].u=read(),e[i].v=read(),e[i].w=read(),mx=max(mx,e[i].w); cp t; for(ri i=1;i&lt;=mx;i*=3) &#123; for(ri j=1;j&lt;=m;++j) vl[j]=e[j].w/i%3; for(ri o=0;o&lt;3;++o) &#123; for(ri j=1;j&lt;=m;++j) &#123; t=w[vl[j]*o%3]; a[e[j].u][e[j].u]+=t; a[e[j].v][e[j].v]+=t; a[e[j].u][e[j].v]-=t; a[e[j].v][e[j].u]-=t; &#125; cur[o]=Det(); &#125; idft(),Add(res,mul(i,calc())); &#125; cout&lt;&lt;res; return 0;&#125; Petya and Sequence解题思路： 考虑如何判定，发现把 $B$ 给 $reverse$ 过来就是在做循环卷积，那么相当于是问将 $A$ 在转点值之后有没有零项，于是莽一个 $Bluestein's\\ algorithm$ 就行了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch=='-',ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;namespace modular &#123; int mod; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125;&#125;using namespace modular;const int N=30005;int iv1,iv2;int vl[N],n,G,pri[1000005],tot=0,omega[N&lt;&lt;1];bool vs[10000005];inline int C2(int x) &#123; return (ll)x*(x-1)/2%n; &#125;struct Ntt &#123; int mod,g,lim,tim; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125; inline int fix(int a) &#123; return (a%mod+mod)%mod; &#125; int w[19],invv[19]; vector&lt;int&gt;rev[19]; inline void init_ntt() &#123; invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;19;++i) invv[i]=mul(invv[i-1],iv); w[18]=ksm(g,(mod-1)&gt;&gt;19); for(ri i=17;~i;--i) w[i]=mul(w[i+1],w[i+1]); &#125; inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1)); &#125; inline void ntt(poly&amp;a,int typ) &#123; for(ri i=1;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(mt,a[j+k+i]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]); &#125; inline poly trans(poly a) &#123; poly b; int t=a.size(); init(t); a.resize(lim),ntt(a,1); b.resize(lim); for(ri i=0;i&lt;n;++i) b[i]=omega[((n&lt;&lt;1)-((ll)i*i%(n&lt;&lt;1)))%(n&lt;&lt;1)],i&amp;&amp;(b[lim-i]=b[i]); ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a; &#125;&#125;A,B;inline void init_prime() &#123; for(ri i=2;i&lt;=10000000;++i) &#123; if(!vs[i]) pri[++tot]=i; for(ri j=1,up=10000000/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j) &#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]) break; &#125; &#125;&#125;inline bool check(int x) &#123; for(ri i=1,lm=sqrt(x);i&lt;=tot&amp;&amp;pri[i]&lt;=lm;++i) if(x==x/pri[i]*pri[i]) return 0; return 1;&#125;inline void find_G() &#123; vector&lt;int&gt;divv; int cur=mod-1; for(ri i=2,lm=sqrt(cur);i&lt;=lm;++i) &#123; if(cur!=cur/i*i) continue; divv.pb(i); if(i*i!=cur) divv.pb(cur/i); &#125; for(G=2;;++G) &#123; bool ff=1; for(ri i=(int)divv.size()-1;~i;--i) if(ksm(G,divv[i])==1) &#123; ff=0;break; &#125; if(ff) break; &#125;&#125;inline ll ksc(ll a,ll b,ll mod) &#123; return a*b-(ll)((long double)a/mod*b+1e-8)*mod; &#125;inline void dft() &#123; poly a(n&lt;&lt;1),rsa,rsb; for(ri i=0;i&lt;n;++i) a[i]=mul(fix(vl[i]),omega[(ll)i*i%(n&lt;&lt;1)]); rsa=A.trans(a),rsb=B.trans(a); ll md=(ll)A.mod*B.mod; for(ri i=0;i&lt;n;++i) vl[i]=(ksc((ll)rsa[i]*iv1,B.mod,md)+ksc((ll)rsb[i]*iv2,A.mod,md))%md%mod*omega[C2(i)]%mod;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif A.mod=998244353,A.g=3,A.init_ntt(); B.mod=1005060097,B.g=5,B.init_ntt(); iv1=A.Inv(B.mod),iv2=B.Inv(A.mod); init_prime(); for(ri tt=read();tt;--tt) &#123; n=read(); for(ri i=0;i&lt;n;++i) vl[i]=read(); mod=10000000/(n&lt;&lt;1)*(n&lt;&lt;1)+1; while(!check(mod)) mod+=n&lt;&lt;1; find_G(); omega[0]=1,omega[1]=ksm(G,(mod-1)/(n&lt;&lt;1)); for(ri i=2;i&lt;(n&lt;&lt;1);++i) omega[i]=mul(omega[i-1],omega[1]); dft(); bool ff=0; for(ri i=0;i&lt;n;++i) if(!vl[i]) &#123; ff=1;break; &#125; puts(ff?\"YES\":\"NO\"); &#125; return 0;&#125; Call It What You Want解题思路： 大概考察了分圆多项式和莫比乌斯函数的一些小性质 首先设 $f_n(x)=x^n-1$ ，那么有 $f_n(x)=\\prod\\limits_{d|n}\\Phi_d(x)$ ，进行多项式取对， $\\ln (x^n-1)=\\sum\\limits_{d|n}\\ln(\\Phi_d(x))$ 然后莫比乌斯反演一下： $\\ln(\\Phi_n(x))=\\sum\\limits_{d|n}\\mu(d)\\ln(x^{\\frac nd}-1)$ 然后 $exp$ 回去： $\\Phi_n(x)=\\prod\\limits_{d|n}(x^d-1)^{\\mu(\\frac nd)}$ 考虑到 $\\mu(x)$ 只在 $x$ 没有平方因子的时候有贡献，而 $2\\times3\\times5\\times7\\times11\\times13\\le100000\\le2\\times3\\times5\\times7\\times11\\times13\\times17$ ，因此可以暴力状压每个数的有贡献的约数 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=1e5+5;int phi[N],pri[N&gt;&gt;2],tot=0,n;bool vs[N],vis[N];vector&lt;int&gt;divv[N],Phi[N];inline void init() &#123; phi[1]=1; for(ri i=2;i&lt;=100000;++i) &#123; if(!vs[i]) &#123; pri[++tot]=i,phi[i]=i-1; for(ri j=i;j&lt;=100000;j+=i) divv[j].pb(i); &#125; for(ri j=1,up=100000/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j) &#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j]) &#123; phi[i*pri[j]]=phi[i]*pri[j];break; &#125; phi[i*pri[j]]=phi[i]*(pri[j]-1); &#125; &#125;&#125;inline bool cmp(int a,int b) &#123; if(phi[a]^phi[b]) return phi[a]&lt;phi[b]; for(ri i=phi[a];~i;--i) if(Phi[a][i]^Phi[b][i]) return Phi[a][i]&lt;Phi[b][i]; return 1;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri tt=read();tt;--tt) &#123; n=read(); vector&lt;int&gt;id; for(ri i=1;i&lt;=n;++i) if(n==n/i*i) &#123; id.pb(i); if(vis[i]) continue; vis[i]=1; Phi[i].resize(phi[i]+1); Phi[i][0]=i&gt;1?1:-1; for(ri ct,x,s=0,lm=(int)divv[i].size();s&lt;(1&lt;&lt;lm);++s) &#123; ct=0,x=i; for(ri j=0;j&lt;lm;++j) if(s&gt;&gt;j&amp;1) ct^=1,x/=divv[i][j]; if(!ct) for(ri j=phi[i];j&gt;=x;--j) Phi[i][j]-=Phi[i][j-x]; else for(ri j=x;j&lt;=phi[i];++j) Phi[i][j]+=Phi[i][j-x]; &#125; &#125; sort(id.begin(),id.end(),cmp); for(ri i=0,x;i&lt;(int)id.size();++i) &#123; putchar('('); x=id[i]; for(ri j=phi[x];~j;--j) &#123; if(!Phi[x][j]) continue; if(Phi[x][j]&gt;0&amp;&amp;j!=phi[x]) putchar('+'); if(j&amp;&amp;Phi[x][j]==-1) putchar('-'); if(!j||Phi[x][j]&gt;1||Phi[x][j]&lt;-1) cout&lt;&lt;Phi[x][j]; if(j) putchar('x'); if(j&gt;1) putchar('^'),cout&lt;&lt;j; &#125; putchar(')'); &#125; puts(\"\"); &#125; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"PKUWC2020游记","slug":"pkuwc2020","date":"2019-12-23T23:34:57.000Z","updated":"2019-12-24T00:10:02.650Z","comments":true,"path":"pkuwc2020/","link":"","permalink":"http://ldxcaicai.github.io/pkuwc2020/","excerpt":"","text":"所以这次冬令营到底叫啥啊这不还是19年吗== Day0坐飞机去首都，然后感觉人被冻没了233 这次参加 pkuwc 的有我,cyk,fsy,hwj 中午和教练吃完饭下午跑去报到，结果 zxy 因为没事干跟着我们去报到（其实是准备嘲讽我们） ，结果排队的人太多我,cyk,fsy直接开始欢乐斗地主然后被 zxy 无情吐槽了😭😭😭 回去之后给 cyk 放卢姥爷的斗地主神仙名场面集锦（大雾）然后写了几道题就睡了，感觉啥都没干药丸 Day1上午开营仪式结果请了一个 thu 毕业的 pku 老师来给我们吹水做讲座 开营仪式结束后刘姐和 D Z Yo 带我们在 pku 旅游了一圈讲了一下比赛事项，结果我们和他们那届赛制不一样？？？最后还真成旅游了 中午比较困但一直没睡着，喝了一瓶咖啡就去上机测试了 开题 三道计数，真棒 看题三道都不会。。。。 $A$ 想了半天不会最低档暴力 $B$ 想了半天只会最低档暴力 $C$ 想了半天只会 $100pts$ 那就写吧， $90min$ 之后我发现自己看错题了，心态爆炸，然后发现 $mobius$ 反演能有 $42pts$ ，那就写吧，终于有分了.jpg 然后发现 $B$ 会 $50pts$ , $A$ 可能会最低档暴力了，然后就开始写 $B$ 的 $50pts$ ，写法发现又假掉了，结果想了一会儿又会了一个算法，氪命 rush 了一波还是没调出来，最后交了一个 $10pts$ 没评出来就结束了 然后下来一问大家都比我高😱😱😱😱😱那这不是完蛋了吗，所幸的是所有 正式营员都进了面试，结果 cyk 貌似是因为 CSP-S 考低了一点就没面试资格？然后学弟告诉我他旁边那个考了 $241$ ，我？？？人都傻了，晚上被学弟拖去未名湖走了一圈，回去之后 zgs 说 cyk 只要考得高还是能拿奖，于是我们兴高采烈的回房间开始颓废，我才不会告诉你我因为太丧直接把吞食鱼打通关然后看小说看到两点半的事呢 Day2早上去面试，由于有三场面试而我以为只有一场，于是 $8:55$ 才到文史楼，结果去了才知道我还有一场 $8:35$ 和一场 $9:50$ 的，由于面试比较无聊所以这里就不多讲，唯一让我放不下心的是第三场面试离开的时候面试我的老师说：你还得多多努力才行啊。 人都傻了.jpg，这是在说让我下次再来的意思吧😱😱😱😱😱 比较神仙的是学弟 fsy 第一场面试的时候面试老师问了一句：成都石室中学？没听说过啊，你来简单介绍一下。 回去之后感觉非常郁闷，吃完饭之后和 cyk 说今天一定要翻盘然后就进考场了，还有 5min 开始的时候打完了多项式全家桶的板子，然后慢慢等待考试开始，打开一看，NMD今天怎么一道计数都没有啊！然后确认了 5min 自己没把 $A$ 读错题之后写了一发交上去就过了，然后想了一下 $B$ 发现直接建出笛卡尔树然后加一个广义线段树查询区间信息做法就过了，然后想了一下 $C$ ，嗯？这个无向图怎么求最小割啊？？？我居然连最低档暴力都不会，前两道还是送分的，凉了。 过了 $5min$ 反应过来是个二维数点问题，然后会了 $68$ 分，写了个四分树一交发现被卡了只有 $42$ 分，冷静了一下把第一个四分树改成了二维 $bit$ 结果又 TLE 了，又冷静了一下把第二个四分树改成了树套树准备交一发，仔细想了一想貌似第一棵直接用二维前缀和即可，这次如果过不了就换成二维前缀和吧！结果交上去就过了。。。最后由于冷静了很久不会优化后面一个树套树于是人没了。出来一问好像一坨人阿克，那我没了。。。对了一下分发现 cyk 总分跟我差不多， fsy 和 hwj 要稍微低一点点，晚上和 fsy 和 cyk 在房间里斗地主， cyk 直接输封顶了 Day3发奖日 上午酒店里颓废，下午去领奖感觉慌得一批，希望能苟一个二等奖回家 然后先是敦敦敦来讲题，发现讲了我还是不会，另外那个 d1t3 也得吐槽一下，敦敦敦：这个题我也不是很会，你们想知道可以下来联系一下他（指吉老师）。 MD有毒 然后就发奖了，结果一二等奖发完之后我和 cyk 都没领到， fsy 和 hwj 都有二等奖，感觉自己成最大输家。然后最后发现是一等？？？我拿到之后就开始等 cyk 的，结果到了最后也没发？？？然后去找老师一问说的是非正式营员无法发奖？？？这操作太😁😁😁了吧？？？引起我们极度不适。 zgs 联系了一下感觉也不是很能补一个奖，于是简单安慰了一下 cyk 就准备去 thu 等 zxy 他们发奖了，然后成功给到了 hjk 和 yk ，听见 yk 在那儿一直假感觉有毒，最后发下来 CDQZ 高二三个一等奖， zxy 也一等了。于是马上我们就去机场准备回家感觉zgs又会发个什么神奇的喜报","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://ldxcaicai.github.io/tags/游记/"}]},{"title":"杂题乱做 Round10","slug":"sol10","date":"2019-12-19T02:10:32.000Z","updated":"2019-12-25T00:04:50.082Z","comments":true,"path":"sol10/","link":"","permalink":"http://ldxcaicai.github.io/sol10/","excerpt":"","text":"机器人高尔夫球赛解题思路： 首先暴力 $dp$ 设 $f_{i,j}$ 表示先手在 $(i,j)$ 处出发的结果~~直接转移~~。 然后考虑优化这个做法。打表会发现对于大部分格子，都有 $f_{i,j}=f_{i+1,j+1}$ ，认真思考后会发现如果格子 $(i,j)$ 满足跟它曼哈顿距离不超过 $2$ 的部分都没有标记那么 $f_{i,j}=f_{i+1,j+1}$ 那么暴力 $dp$ 需要特殊处理的格子的值，用 $map$ 记录每条对角线的答案即可快速转移 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;int,pii&gt; ppp;typedef map&lt;int,ppp&gt;::iterator It;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int fix(int a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=1e5+5;map&lt;pii,bool&gt;vs;map&lt;int,ppp&gt;F;map&lt;pii,pii&gt;mn_mx;vector&lt;pii&gt;ps;int n,m,K,res=0;inline void DP(int x,int y)&#123; if(F.count(x-y))Add(res,mul(dec(F[x-y].fi,x),fix(F[x-y].se.fi))); F[x-y]=ppp(x,mn_mx[pii(x,y)]);&#125;inline pii calc(int x,int y)&#123;return F.count(x-y)?F[x-y].se:pii(0,0);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),K=read(); for(ri x,y,v,i=1;i&lt;=K;++i)&#123; x=read(),y=read(),v=read(); vs[pii(x,y)]=1; mn_mx[pii(x,y)]=pii(v,v); for(ri dx=0;dx&lt;=2&amp;&amp;dx&lt;x;++dx)for(ri dy=0;dy&lt;=2-dx&amp;&amp;dy&lt;y;++dy) ps.pb(pii(x-dx,y-dy)); &#125; sort(ps.begin(),ps.end()); ps.erase(unique(ps.begin(),ps.end()),ps.end()); pii rgt,dwn; for(ri x,y,t=(int)ps.size()-1;~t;--t)&#123; x=ps[t].fi,y=ps[t].se; if(!vs[pii(x,y)])&#123; rgt=calc(x,y+1); dwn=calc(x+1,y); mn_mx[pii(x,y)]=pii(min(rgt.se,dwn.se),max(rgt.fi,dwn.fi)); &#125; DP(x,y); &#125; ppp cur; for(It it=F.begin();it!=F.end();++it)&#123; cur=it-&gt;se; Add(res,mul(fix(min(cur.fi,cur.fi-it-&gt;fi)),fix(cur.se.fi))); &#125; cout&lt;&lt;res; return 0;&#125; 有标号的DAG计数 IV解题思路： 可能得先会前三道 $DAG$ 计数，先考虑简单的问题，如果不要求连通怎么做，发现是个常见套路，枚举入度为 $0$ 的点然后容斥即可： $$ \\begin{aligned} f_i=&\\sum\\limits_{j=1}^if_{i-j}2^{j(i-j)}(-1)^{i+1}\\\\ f_i=&\\sum\\limits_{j=0}^{i-1}f_j\\sqrt2^{i^2-j^2-(i-j)^2}(-1)^{i-j+1}\\\\ \\frac{f_i}{\\sqrt2^{i^2}}=&\\sum\\limits_{j=0}^{i-1}\\frac{f_j}{\\sqrt2^{j^2}}\\frac{(-1)^{i-j+1}}{\\sqrt2^{(i-j)^2}}\\\\ 构造F(x)=&\\sum\\limits_{i=0}^{+\\infty}\\frac{f_i}{\\sqrt2^{i^2}}x^i,G(x)=\\sum\\limits_{i=1}^{+\\infty}\\frac{(-1)^{i+1}}{\\sqrt2^{i^2}}\\\\ F=&F\\times G+1\\\\ F=&\\frac{1}{1-G} \\end{aligned} $$ 这样能够在 $O(n\\log n)$ 的时间内求出 $f$ 接下来就有两种思路了，第一种是利用补集转化的思想，设答案等于 $g_i$ ，那么 $g_i=f_i-\\sum\\limits_{j=1}^{i-1}g_jf_{i-j}\\binom{i-1}{j-1}$ 然后一波化简上多项式求逆 第二种也挺容易想到的，设 $G$ 为答案的生成函数，显然有 $e^G=F$ ，那么写个多项式取对即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backnamespace modular &#123; const int mod=998244353,sqr2=116195171; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=500005;int n,invv[23],w[23],lim,tim,inv[N],fac[N],ifac[N];vector&lt;int&gt;rev[23];inline int C(int n,int m) &#123; return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[n-m],ifac[m])); &#125;inline void init() &#123; fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=500000;++i) &#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;inline void init_ntt() &#123; invv[0]=1,w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ) &#123; for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(mt,a[j+k+i]); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b) &#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline poly operator-(poly a,poly b) &#123; if((int)a.size()&lt;(int)b.size()) a.resize((int)b.size()); for(ri i=0,up=(int)b.size();i&lt;up;++i) Dec(a[i],b[i]); return a;&#125;inline poly poly_inv(poly a,int K) &#123; poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) &#123; init(i&lt;&lt;2); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); b.resize(lim),ntt(b,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); &#125; return b.resize(K),b;&#125;inline poly poly_integ(poly a) &#123; a.pb(0); for(ri i=(int)a.size()-1;i;--i)a[i]=mul(a[i-1],inv[i]); return a[0]=0,a;&#125;inline poly poly_direv(poly a) &#123; for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;&#125;inline poly poly_ln(poly a,int K) &#123; poly res=poly_integ(poly_direv(a)*poly_inv(a,K)); return res.resize(K),res;&#125;int main() &#123; freopen(\"dagIV.in\",\"r\",stdin); freopen(\"dagIV.out\",\"w\",stdout); cin&gt;&gt;n; init(); init_ntt(); poly f(n+1); for(ri t,i=0;i&lt;=n;++i) &#123; t=mul(ifac[i],Inv(ksm(sqr2,(ll)i*i%(mod-1)))); f[i]=t?(i&amp;1?mod-t:t):0; &#125; f=poly_inv(f,n+1); for(ri i=0;i&lt;=n;++i) Mul(f[i],ksm(sqr2,(ll)i*i%(mod-1))); f=poly_ln(f,n+1); cout&lt;&lt;mul(f[n],fac[n]); return 0;&#125; arewell解题思路： 容斥的思想跟上面的求 $f$ 的一样，枚举入度为 $0$ 的点，然后发现转移变成了枚举子集，直接用子集卷积优化即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;int n,m,lim,coe,all,pw[25],ppw[405];poly cnt,f[25],g[25],bitcnt;inline void fwt(poly&amp;a,int typ) &#123; for(ri a0,a1,iv=mod+1&gt;&gt;1,i=1;i&lt;lim;i&lt;&lt;=1) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k) &#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(typ==-1) Mul(a[j+k],iv),Mul(a[j+k+i],iv); &#125;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); coe=mod+1&gt;&gt;1; pw[0]=1,ppw[0]=1; for(ri i=1;i&lt;=n;++i) pw[i]=pw[i-1]&lt;&lt;1; for(ri i=1;i&lt;=m;++i) ppw[i]=mul(ppw[i-1],coe); lim=pw[n],all=lim-1; cnt.resize(lim),bitcnt.resize(lim); for(ri i=0;i&lt;=n;++i) f[i].resize(lim),g[i].resize(lim); for(ri u,v,i=1;i&lt;=m;++i) &#123; u=read()-1,v=read()-1; for(ri s=all^pw[u]^pw[v],t=s;~t;t=t?(t-1)&amp;s:-1) ++cnt[t^pw[u]^pw[v]]; &#125; for(ri t,s=0;s&lt;lim;++s) &#123; bitcnt[s]=bitcnt[s&gt;&gt;1]+(s&amp;1); g[bitcnt[s]][s]=bitcnt[s]&amp;1?ppw[cnt[s]]:mod-ppw[cnt[s]]; &#125; for(ri i=0;i&lt;=n;++i) fwt(g[i],1); f[0][0]=1; fwt(f[0],1); for(ri i=0;i&lt;n;++i) for(ri s=0;s&lt;lim;++s) if(f[i][s]) for(ri j=1;i+j&lt;=n;++j) Add(f[i+j][s],mul(f[i][s],g[j][s])); fwt(f[n],-1); cout&lt;&lt;mul(f[n][all],Inv(mul(ppw[m],ksm(3,m)))); return 0;&#125; ffort解题思路： 设总伤害为 $X$ 的方案数为 $f(X)$ 那么最后这个会对答案产生 $\\binom{X-1}{n-1}$ 的贡献，由于 $X$ 非常大因此需要换一个角度思考，观察上述式子发现是要插入 $n-1$ 个板，那么我们对 $m$ 种数据结构分别构造生成函数 $F_i(x)$ ，其中 $F_i(x)[x^j]$ 表示其中放 $j$ 个板的方案数，然后我们对每一种数据结构做一次多项式快速幂最后乘起来即可，注意最后一个要特殊处理 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=500005;int invv[23],w[23],inv[N],lim,tim;vector&lt;int&gt;rev[23];inline void init() &#123; inv[1]=1; for(ri i=2;i&lt;=500000;++i) inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);&#125;inline void init_ntt() &#123; invv[0]=1,w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ) &#123; for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b) &#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline poly operator-(poly a,poly b) &#123; if((int)a.size()&lt;(int)b.size()) a.resize((int)b.size()); for(ri i=0,up=(int)b.size();i&lt;up;++i) Dec(a[i],b[i]); return a;&#125;inline poly poly_inv(poly a,int K) &#123; poly b(1,Inv(a[0])),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) &#123; init(i&lt;&lt;2); c=a,c.resize(i&lt;&lt;1),c.resize(lim),ntt(c,1); b.resize(lim),ntt(b,1); for(ri j=0;j&lt;lim;++j) Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); &#125; return b.resize(K),b;&#125;inline poly poly_deriv(poly a) &#123; for(ri i=1,up=(int)a.size();i&lt;up;++i) a[i-1]=mul(a[i],i); return a.pop_back(),a;&#125;inline poly poly_integ(poly a) &#123; a.pb(0); for(ri i=(int)a.size()-1;i;--i) a[i]=mul(inv[i],a[i-1]); return a[0]=0,a;&#125;inline poly poly_ln(poly a,int K) &#123; return a=poly_integ(poly_deriv(a)*poly_inv(a,K)),a.resize(K),a; &#125;inline poly poly_exp(poly a,int K) &#123; poly b(1,1),c; for(ri i=1;i&lt;K;i&lt;&lt;=1) &#123; c=a,c.resize(i&lt;&lt;1); c=c-poly_ln(b,i&lt;&lt;1); Add(c[0],1); b=b*c,b.resize(i&lt;&lt;1); &#125; return b.resize(K),b;&#125;inline poly poly_ksm(poly a,int pw,int K) &#123; int iv=Inv(a[0]),mt=ksm(a[0],pw); a.resize(K); for(ri i=0;i&lt;K;++i) Mul(a[i],iv); a=poly_ln(a,K); for(ri i=0;i&lt;K;++i) Mul(a[i],pw); a=poly_exp(a,K); for(ri i=0;i&lt;K;++i) Mul(a[i],mt); return a;&#125;int n,m,a[N],b[N];int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); init(),init_ntt(); for(ri i=1;i&lt;=m;++i) a[i]=read(),b[i]=read(); ++m,a[m]=1,b[m]=b[m-1]-1,--a[m-1]; poly res(1,1),f; for(ri t,iv,i=1;i&lt;=m;++i) if(a[i]) &#123; f.resize(n); f[0]=b[i]; for(ri mt=add(b[i],1),j=1;j&lt;n;++j) &#123; Mul(mt,mul(inv[j+1],b[i]+1-j)); f[j]=mt; &#125; if(i==m) Add(f[0],1); f=poly_ksm(f,a[i],n); res=res*f; res.resize(n); &#125; cout&lt;&lt;res[n-1]; return 0;&#125; Temperature Survey解题思路： 考虑把问题看成走网格的方案数，那么不断把 $(mid,a_{mid})$ 当成矩形的右上角，然后递归分治可以递归划分出 $O(n)$ 个矩形，这些矩形边长和是 $O(n\\log n)$ 级别的，然后对于每个矩形用 $ntt$ 计算其上/左边界对其下/右边界的贡献即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125;&#125;using namespace modular;const int N=5e5+5;int lim,tim,invv[23],w[23],fac[N],ifac[N],a[N],n;vector&lt;int&gt;rev[23];inline void init_ntt() &#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=500000;++i) &#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=500000;++i) Mul(ifac[i],ifac[i-1]); w[22]=ksm(3,(mod-1)&gt;&gt;23); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]);&#125;inline int C(int n,int m) &#123; return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); &#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ) &#123; for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri mt,i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=64) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline poly calc1(poly a,int len) &#123; int n=(int)a.size(); poly b(n); for(ri i=0;i&lt;n;++i) b[i]=C(i+len,i); a=a*b; return a.resize(n),a;&#125;inline poly calc2(poly a,int len) &#123; int n=(int)a.size(); poly b(len+n); for(ri i=0;i&lt;n;++i) Mul(a[i],ifac[n-i-1]); for(ri i=0;i&lt;len+n;++i) b[i]=fac[i]; b=a*b; a.resize(len+1); for(ri i=0;i&lt;=len;++i) a[i]=mul(ifac[i],b[i+n-1]); return a;&#125;tr1::unordered_map&lt;int,int&gt; f[N];inline void solve(int l,int r,int ql,int qr) &#123; if(l&gt;r||ql&gt;qr) return; int mid=l+r&gt;&gt;1,ps=mid+1; solve(l,mid-1,ql,a[mid-1]); poly F(a[mid]-ql+1),G; for(ri i=ql;i&lt;=a[mid];++i) F[i-ql]=f[mid-1][i]; G=calc1(F,r-mid); for(ri i=ql;i&lt;=a[mid];++i) Add(f[r][i],G[i-ql]); G=calc2(F,r-mid); for(ri i=mid;i&lt;r;++i) Add(f[i][a[mid]],G[i-mid]); F.clear(); F.resize(r-mid+1); for(ri i=mid;i&lt;=r;++i) F[i-mid]=f[i][ql-1]; G=calc1(F,a[mid]-ql); for(ri i=mid;i&lt;=r;++i) Add(f[i][a[mid]],G[i-mid]); G=calc2(F,a[mid]-ql); for(ri i=ql;i&lt;a[mid];++i) Add(f[r][i],G[i-ql]); while(ps&lt;=r&amp;&amp;a[ps]==a[mid]) ++ps; if(ps&lt;=r) solve(ps,r,a[mid]+1,qr);&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init_ntt(); for(ri tt=read();tt;--tt) &#123; n=read(); for(ri i=0;i&lt;=n;++i) f[i].clear(); for(ri i=1;i&lt;=n;++i) a[i]=read(); f[1][0]=1; solve(1,n,1,a[n]); int res=0; for(ri i=1;i&lt;=a[n];++i) Add(res,f[n][i]); cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125; 算力训练解题思路： 相当于是求 $\\oplus_{i=1}^n(1+x^{a_i})$ ，那么可以先参考一下 黎明前的巧克力 是怎么做的，这题也比较类似，大概是扩域将每个数表示成 $\\sum\\limits_{i=0}^Ka_i\\omega_K^i$ 的形式，然后先把 $\\sum\\limits_{i=1}^n(1+x^{a_i})$ 给 $fwt$ 了，接着对于每一维分别求出它是由 $t$ 个 $\\omega_K^i$ 加起来的，那么这一维的实际值应该是 $(1+\\omega_K^i)^t$ 成功还原点值之后再 $ifwt$ 回去即可 注意到这题有点卡常，因此求 $(1+\\omega_K^i)^t$ 要用 $BSGS$ 卡常 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1l;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)int n,K,tim,lim,iv;inline int read(int B) &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=ans*B+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e6+5;struct cp &#123; int a[6]; cp() &#123; memset(a,0,sizeof(a)); &#125; inline int&amp;operator[](const int&amp;k) &#123; return a[k]; &#125; inline const int&amp;operator[](const int&amp;k) const &#123; return a[k]; &#125; friend inline cp operator+(cp a,cp b) &#123; for(ri i=0;i&lt;K;++i) Add(a[i],b[i]); return a; &#125; friend inline void operator+=(cp&amp;a,cp b) &#123; a=a+b; &#125; friend inline cp operator-(cp a,cp b) &#123; for(ri i=0;i&lt;K;++i) Dec(a[i],b[i]); return a; &#125; friend inline void operator-=(cp&amp;a,cp b) &#123; a=a-b; &#125; friend inline cp operator*(cp a,int b) &#123; for(ri i=0;i&lt;K;++i) Mul(a[i],b); return a; &#125; friend inline void operator*=(cp&amp;a,int b) &#123; a=a*b; &#125; friend inline cp operator*(cp a,cp b) &#123; cp res; for(ri i=0;i&lt;K;++i) if(a[i]) for(ri j=0;j&lt;K;++j) Add(res[i+j&lt;K?i+j:i+j-K],mul(a[i],b[j])); return res; &#125; friend inline void operator*=(cp&amp;a,cp b) &#123; a=a*b; &#125; inline int getval() &#123; return dec(add(a[0],a[1]),add(a[2],a[3])); &#125;&#125;a[N],w[6],cur[6];inline void init() &#123; w[0][0]=w[1][1]=1; for(ri i=2;i&lt;K;++i) w[i]=w[i-1]*w[1]; &#125;inline void dft(cp*a,int typ) &#123; static cp res[6]; for(ri i=0;i&lt;K;++i) &#123; res[i]=cp(); for(ri j=0;j&lt;K;++j) res[i]+=w[i*j%K]*a[j]; &#125; for(ri i=0;i&lt;K;++i) a[i]=res[i]; if(~typ) return; for(ri i=1;i+i&lt;K;++i) swap(a[i],a[K-i]); for(ri i=0;i&lt;K;++i) a[i]*=iv;&#125;inline void dwt(cp*a,int typ) &#123; for(ri i=1;i&lt;lim;i*=K) for(ri j=0,len=i*K;j&lt;lim;j+=len) &#123; for(ri k=0;k&lt;i;++k) &#123; for(ri o=0;o&lt;K;++o) cur[o]=a[j+k+o*i]; dft(cur,typ); for(ri o=0;o&lt;K;++o) a[j+k+o*i]=cur[o]; &#125; &#125;&#125;int sqr;cp tp[N],pws[N],pwb[N];inline cp getpow(int x) &#123; return pws[x%sqr]*pwb[x/sqr]; &#125;inline void trans(cp*a) &#123; for(ri i=0;i&lt;lim;++i) tp[i][0]=1; sqr=sqrt(1.0*n)+10; for(ri t=0;t&lt;K;++t) &#123; cp A; A[0]=pws[0][0]=pwb[0][0]=1,++A[t]; for(ri o=1;o&lt;=sqr;++o) pws[o]=A*pws[o-1]; pwb[1]=pws[sqr]; for(ri o=2;o&lt;=sqr;++o) pwb[o]=pwb[o-1]*pwb[1]; for(ri i=0;i&lt;lim;++i) tp[i]*=getpow(a[i][t]); &#125; for(ri i=0;i&lt;lim;++i) a[i]=tp[i];&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(10),K=read(10),tim=read(10),iv=Inv(K); lim=1; for(ri i=1;i&lt;=tim;++i) lim*=K; for(ri i=1;i&lt;=n;++i) ++a[read(K)][0]; init(); dwt(a,1); trans(a); dwt(a,-1); for(ri i=0;i&lt;lim;++i) cout&lt;&lt;a[i].getval()&lt;&lt;'\\n'; return 0;&#125; 魔力环解题思路： 考虑 $burnside$ 引理，发现只用枚举 $d|\\gcd(n,m)$ ，然后计算 $f(d)$ 表示 $\\frac md$ 个黑球， $\\frac {n-m}d$ 个白球的序列，其中黑球（首尾的黑球要加起来）不连续超过 $K$ 个的方案数 那么我们强制结尾没有黑球，枚举开头黑球有 $t$ 个，方案数乘上 $t+1$ 即可，现在问题变成了在 $\\frac{n-m}d$ 个白球中插入 $\\frac md-t$ 个黑球，每个空隙不能插入超过 $K$ 个，问方案数，那么容斥算即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125; inline int Inv(int a) &#123; return ksm(a,mod-2); &#125;&#125;using namespace modular;const int N=1e5+5;int n,m,K,fac[N],ifac[N],inv[N],g,tot=0,pri[N],phi[N];bool vs[N];inline int gcd(int a,int b) &#123; int t;while(b) t=a,a=b,b=t-t/a*a;return a; &#125;inline void init() &#123; fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=n;++i) &#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;inline int C(int n,int m) &#123; return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m])); &#125;inline int F(int a,int b) &#123; int res=0; for(ri i=0,t,up=min(a/(K+1),b-1);i&lt;=up;++i) &#123; t=mul(C(b-1,i),C(a+b-2-i*(K+1),a-i*(K+1))); i&amp;1?Dec(res,t):Add(res,t); &#125; return res;&#125;inline int calc(int a,int b) &#123; if(b==1) return a&lt;=K?a+1:0; int res=0; for(ri i=0;i&lt;=a&amp;&amp;i&lt;=K;++i) Add(res,mul(i+1,F(a-i,b))); return res;&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif cin&gt;&gt;n&gt;&gt;m&gt;&gt;K; if(n==m) return cout&lt;&lt;(K&gt;=n),0; init(); g=gcd(n,m); int res=0; for(ri tm=1;tm&lt;=g;++tm) &#123; if(tm==1) phi[tm]=1; else &#123; if(!vs[tm]) phi[tm]=tm-1,pri[++tot]=tm; for(ri i=1,lm=g/tm;i&lt;=tot&amp;&amp;pri[i]&lt;=lm;++i) &#123; vs[tm*pri[i]]=1; if(tm==tm/pri[i]*pri[i]) &#123; phi[tm*pri[i]]=phi[tm]*pri[i];break; &#125; phi[tm*pri[i]]=phi[tm]*(pri[i]-1); &#125; &#125; if(g==g/tm*tm) Add(res,mul(phi[tm],calc(m/tm,(n-m)/tm))); &#125; cout&lt;&lt;mul(res,inv[n]); return 0;&#125; 魔法小程序解题思路： > 读完题发现是个任意进制前缀和，那么我们把 $c$ 拿来做 $ifmt$ 即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch=='-',ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl() &#123; ll ans=0; bool f=1; char ch=gc(); while(!isdigit(ch)) f^=ch=='-',ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=1e6+5;int len[N],n,m;ll c[N];int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif m=read(); cout&lt;&lt;m&lt;&lt;'\\n'; for(ri i=1;i&lt;=m;++i) cout&lt;&lt;(len[i]=read())&lt;&lt;' '; puts(\"\"); n=read(); len[++m]=n+1; for(ri i=0;i&lt;n;++i) c[i]=readl(); for(ri i=1,id=1;;i*=len[id++]) &#123; if(len[id]&gt;1) for(ri j=n-1;j&gt;=i;--j) if(j/i%len[id]&gt;0) c[j]-=c[j-i]; if(i&gt;n/len[id]) break; &#125; cout&lt;&lt;n&lt;&lt;'\\n'; for(ri i=0;i&lt;n;++i) cout&lt;&lt;c[i]&lt;&lt;' '; puts(\"\"); return 0;&#125; 如何优雅地求和解题思路： 考虑构造组合数多项式： $$ \\begin{aligned} f_j=&\\sum\\limits_{i=0}^m\\binom jia_i\\\\ a_j=&\\sum\\limits_{i=0}^m\\binom ji(-1)^{j-i}f_i\\\\ \\frac{a_j}{j!}=&\\frac{(-1)^{j-i}}{(j-i)!}\\frac{f_i}{i!}\\\\ ntt&求出a_i\\\\ res=&\\sum\\limits_{i=0}^nf_i\\binom nix^i(1-x)^{n-i}\\\\ =&\\sum\\limits_{i=0}^n(\\sum\\limits_{j=0}^m\\binom ija_j)x^i(1-x)^{n-i}\\binom ni\\\\ =&\\sum\\limits_{j=0}^ma_j\\sum\\limits_{i=0}^n\\binom{n}{i}x^i(1-x)^{n-i}\\binom ij\\\\ =&\\sum\\limits_{j=0}^ma_j\\binom nj\\sum\\limits_{i=0}^nx^i(1-x)^{n-i}\\binom {n-j}{i-j}\\\\ =&\\sum\\limits_{j=0}^ma_j\\binom njx^j\\sum\\limits_{i=0}^{n-j}x^i(1-x)^{n-j-i}\\binom{n-j}i\\\\ =&\\sum\\limits_{j=0}^ma_j\\binom njx^i\\\\ \\end{aligned} $$ 当然利用下降幂多项式同样能够解决问题 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read() &#123; int ans=0; char ch=gc(); while(!isdigit(ch)) ch=gc(); while(isdigit(ch)) ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular &#123; const int mod=998244353; inline int add(int a,int b) &#123; return a+b&lt;mod?a+b:a+b-mod; &#125; inline int dec(int a,int b) &#123; return a&lt;b?a-b+mod:a-b; &#125; inline int mul(int a,int b) &#123; return (ll)a*b%mod; &#125; inline void Add(int&amp;a,int b) &#123; a=a+b&lt;mod?a+b:a+b-mod; &#125; inline void Dec(int&amp;a,int b) &#123; a=a&lt;b?a-b+mod:a-b; &#125; inline void Mul(int&amp;a,int b) &#123; a=(ll)a*b%mod; &#125; inline int ksm(int a,int p) &#123; int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a)) (p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret; &#125;&#125;using namespace modular;const int N=20005;int invv[23],w[23],lim,tim,ifac[N],fac[N],n,m,t;vector&lt;int&gt; rev[23];inline void init_ntt() &#123; invv[0]=1,w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i) w[i]=mul(w[i+1],w[i+1]); for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i) invv[i]=mul(invv[i-1],iv);&#125;inline void init(int up) &#123; lim=1,tim=0; while(lim&lt;up) lim&lt;&lt;=1,++tim; if(rev[tim].size()) return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i) rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ) &#123; for(ri i=0;i&lt;lim;++i) if(i&lt;rev[tim][i]) swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1,mt;i&lt;lim;i&lt;&lt;=1,++t) for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) &#123; mt=1; for(ri k=0;k&lt;i;++k,Mul(mt,w[t])) &#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; &#125; if(~typ) return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i) Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b) &#123; int n=(int)a.size(),m=(int)b.size(),t=n+m-1; if(t&lt;=128) &#123; poly c(t); for(ri i=0;i&lt;n;++i) if(a[i]) for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i) Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline void init() &#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=m;++i) &#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=m;++i) Mul(ifac[i],ifac[i-1]);&#125;int main() &#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),t=read(); init_ntt(); init(); poly f(m+1),g(m+1); for(ri i=0;i&lt;=m;++i) f[i]=mul(ifac[i],read()),g[i]=i&amp;1?mod-ifac[i]:ifac[i]; f=f*g; int res=0; for(ri i=0,mt1=1,mt2=1,tim=n;i&lt;=m;++i,Mul(mt1,t),Mul(mt2,tim),--tim) Add(res,mul(mul(mt1,mt2),f[i])); cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"burnside引理简单证明","slug":"burnside","date":"2019-12-16T13:56:40.000Z","updated":"2019-12-16T14:19:29.268Z","comments":true,"path":"burnside/","link":"","permalink":"http://ldxcaicai.github.io/burnside/","excerpt":"","text":"前言：由于博主时不时会忘记这个定理以及它是咋证明的，所以为了方便就干脆自己写一个放 $blog$ 上面 现在给出集合 $\\text{X}$ ，设 $\\text G$ 是其置换群， $\\text C$ 是其着色集，且 $\\text G$ 作用在 $\\text C$ 下 那么定义 $G(c)=\\{f:f\\in \\text G,f\\times c=c\\},C(f)=\\{c:c\\in \\text C,f\\times c=c\\}$ 然后有一个显然的推论: 设 $c$ 是 $\\text C$ 中的一种着色，那么 $|\\{f\\times c:f\\in \\text G\\}|=\\frac{|\\text G|}{|G(c)|}$ ,证明显然 然后就能证明 $Burnside$ 引理了： \\begin{aligned} \\sum\\limits_{f\\in \\text G}|C(f)|=&\\sum\\limits_{c\\in \\text C}|G(c)|\\\\ \\sum\\limits_{f\\in \\text G}|C(f)|=&\\sum\\limits_{c\\in\\text C}\\frac{|\\text G|}{与c等价的着色数}\\\\ \\sum\\limits_{f\\in\\text G}|C(f)|=&|\\text G|\\sum\\limits_{c\\in\\text C}\\frac{1}{与c等价的着色数}\\\\ 由于在一个等价类中&每种着色的贡献都是\\frac{1}{与c等价的着色数}\\\\ 所以\\sum\\limits_{f\\in \\text G}|C(f)|=&|G|\\times N(\\text G,\\text C)\\\\ N(\\text G,\\text C)=&\\frac{\\sum\\limits_{f\\in \\text G}|C(f)|}{|\\text G|} \\end{aligned}得证","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"Powerful Number 筛学习笔记","slug":"PN","date":"2019-11-30T13:12:34.000Z","updated":"2019-11-30T13:27:30.102Z","comments":true,"path":"PN/","link":"","permalink":"http://ldxcaicai.github.io/PN/","excerpt":"","text":"NMD我怎么现在才会这沙雕玩意儿.jpg 感觉挺简单的，主要是适用范围比较小，大概能筛某些性质比较奇妙的上界在 $10^{13}$ ~ $10^{14}$的积性函数 首先介绍 $\\text{Powerful}$ $\\text{Number}$ 是啥，当一个数满足其所有质因数的指数都大于 $1$ 的时候我们称其为 $\\text{Powerful}$ $\\text{Number}$ ，下面简单说明其重要性质： $n$ 以内的 $\\text{Powerful}$ $\\text{Number}$ 的数量为 $\\sqrt n$ 级别的，首先发现每个 $\\text{Powerful}$ $\\text{Number}$ 都能表示成 $x^2y^3$ 的形式 \\begin{aligned} |\\text{PowerfulNumber}\\le n|=&\\sum\\limits_{x=1}^{\\sqrt n}\\lfloor\\sqrt[3]{\\frac nx}\\rfloor\\\\ =&n^{\\frac13}\\sum\\limits_{x=1}^{\\sqrt n}x^{-\\frac23}\\\\","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"杂题乱做 Round9","slug":"sol9","date":"2019-11-27T14:19:34.000Z","updated":"2019-12-25T00:03:11.920Z","comments":true,"path":"sol9/","link":"","permalink":"http://ldxcaicai.github.io/sol9/","excerpt":"","text":"猎人杀解题思路： 关键点在于对于一个死去的人的处理，根据~~题解~~观察可知这个概率等于在所有人中随机选人开枪，而在选到已经死去的人的时候重新选人，这样跟在未死去的人中随机选人的概率是相同的 在知道这一点之后就可以尝试容斥了，考虑至少 $k$ 个人在第一个人之后死的概率发现这个可以把它们的权值放在生成函数指数上然后利用分治 $ntt$ 快速统计 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline int fix(int a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular;int invv[23],w[23],lim,tim;vector&lt;int&gt;rev[23];inline void init_ntt()&#123; w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv);&#125;inline void init(const int&amp;up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,const int&amp;type)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,a0,a1,t=0;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))&#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;const int N=1e5+5;int n,a[N],m=0,inv[N];inline poly solve(int l,int r)&#123; if(l==r)&#123; poly ret(a[l]+1); ret[0]=1,ret[a[l]]=mod-1; return ret; &#125; int mid=l+r&gt;&gt;1; return solve(l,mid)*solve(mid+1,r);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init_ntt(); n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(),m+=a[i]; inv[1]=1; for(ri i=2;i&lt;=m;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); poly f=solve(2,n); int res=0; for(ri i=0;i&lt;f.size();++i)Add(res,mul(f[i],mul(a[1],inv[i+a[1]]))); cout&lt;&lt;res; return 0;&#125; 有意义的字符串解题思路： 首先有个坑点是**题目中数据范围不全**，有一部分测试数据满足 $b=1,d=5$ ，现在考虑这题咋做 大概看到这个玩意儿会联系到数列里面用特征根方程求通项公式，不妨设 $f_n=(\\frac{b+\\sqrt d}{2})^n+(\\frac{b-\\sqrt d}{2})^n$ ，然后可以利用这个通项公式反解出数列递推式 $f_n=bf_{n-1}+\\frac{b^2-d}4f_{n-2}$ 这样就能搞出来 $f_n$ ，然后由于题目给出的限制条件，这个 $\\frac{b-\\sqrt d}2\\in(-1,0]$ ，所以这个 $(\\frac{b-\\sqrt d}2)^n\\in(-1,1)$ ，也就是说最后需要特判 $f_n$ 是否要减一 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef unsigned long long Ull;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline Ull readul()&#123; Ull ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const Ull mod=7528443412579576937;inline Ull add(Ull a,Ull b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125;inline void Add(Ull&amp;a,Ull b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125;inline Ull mul(Ull a,Ull b)&#123;return (a*b-(Ull)((long double)a/mod*b)*mod+mod)%mod;&#125;Ull d,b,n;struct mat&#123; Ull a[2][2]; mat()&#123;memset(a,0,sizeof(a));&#125; inline Ull*operator[](const int&amp;k)&#123;return a[k];&#125; friend inline mat operator*(mat a,mat b)&#123; mat c; for(ri i=0;i&lt;2;++i)for(ri k=0;k&lt;2;++k)if(a[i][k]) for(ri j=0;j&lt;2;++j)Add(c[i][j],mul(a[i][k],b[k][j])); return c; &#125;&#125;t;int f[105];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif b=readul(),d=readul(),n=readul(); if(n==0)&#123; cout&lt;&lt;1; return 0; &#125; if(n==1)&#123; cout&lt;&lt;b; return 0; &#125; t[0][0]=b,t[0][1]=1; t[1][0]=(d-b*b)&gt;&gt;2,t[1][1]=0; mat res=t; for(Ull p=n-2;p;t=t*t,p&gt;&gt;=1)if(p&amp;1)res=res*t; Ull ans=add(mul(res[0][0],b),mul(res[1][0],2)); ((n%2==0)&amp;&amp;(b*b!=d))&amp;&amp;(--ans); cout&lt;&lt;ans; return 0;&#125; 分拆数解题思路： 貌似是个生成函数基础问题，大概是用多项式 $exp$ 和调和级数的性质来优化背包 大概就是对于每个数构造出其生成函数然后乘起来就可以算出答案，然后对多项式取对就变成加法，再用个求导的变化就能转成 $exp$ ，不理解的可以看看我博客里有一篇 Generating function 的背包优化部分 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef vector&lt;int&gt; poly;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int invv[23],w[23],lim,tim,inv[1&lt;&lt;23];vector&lt;int&gt;rev[23];inline void init_ntt()&#123; inv[1]=1; for(ri i=2,up=1&lt;&lt;23;i&lt;up;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(int up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=0;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int type)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))&#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)if(a[i])for(ri j=0;j&lt;m;++j)if(b[j]) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline poly operator-(poly a,poly b)&#123; a.resize(max(a.size(),b.size())); for(ri i=0;i&lt;b.size();++i)Dec(a[i],b[i]); return a;&#125;inline poly poly_inv(poly a,int k)&#123; poly b(1,ksm(a[0],mod-2)),c; for(ri i=1;i&lt;k;i&lt;&lt;=1)&#123; init(i&lt;&lt;2); c=a,c.resize(i&lt;&lt;1); b.resize(lim),ntt(b,1); c.resize(lim),ntt(c,1); for(ri j=0;j&lt;lim;++j)Mul(b[j],dec(2,mul(b[j],c[j]))); ntt(b,-1),b.resize(i&lt;&lt;1); &#125; return b.resize(k),b;&#125;inline poly poly_deriv(poly a)&#123; for(ri i=0;i&lt;(int)a.size()-1;++i)a[i]=mul(a[i+1],i+1); return a.pop_back(),a;&#125;inline poly poly_integ(poly a)&#123; a.pb(0); for(ri i=a.size()-1;i;--i)a[i]=mul(a[i-1],inv[i]); return a[0]=0,a;&#125;inline poly poly_ln(poly a,int k)&#123; a=poly_integ(poly_deriv(a)*poly_inv(a,k)); return a.resize(k),a;&#125;inline poly poly_exp(poly a,int k)&#123; poly b(1,1),c; a.resize(k&lt;&lt;1); for(ri i=1;i&lt;k;i&lt;&lt;=1)&#123; c=poly_ln(b,i&lt;&lt;1); for(ri j=0;j&lt;c.size();++j)c[j]=dec(a[j],c[j]); Add(c[0],1); b=b*c,b.resize(i&lt;&lt;1); &#125; return b.resize(k),b;&#125;poly f;int n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init_ntt(); f.resize(n+1); for(ri i=1;i&lt;=n;++i)for(ri j=1;i*j&lt;=n;++j)Add(f[i*j],inv[j]); f=poly_exp(f,n+1); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;f[i]&lt;&lt;'\\n'; return 0;&#125; 整数的lqp拆分解题思路： 可以直接 $dp$ 推式子，也可以用生成函数~~貌似都挺快的~~，最后反正是可以用矩乘优化~~然而我太懒了就没写~~ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef unsigned long long Ull;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); if(n&lt;2)&#123; cout&lt;&lt;n; return 0; &#125; int pre1=0,pre2=1; for(ri tmp,i=2;i&lt;=n;++i)&#123; tmp=pre2; pre2=add(pre1,add(pre2,pre2)); pre1=tmp; &#125; cout&lt;&lt;pre2; return 0;&#125; Perpetual Subtraction解题思路： 要用一点线性代数中矩阵对角化的知识，前置知识可以在 Linear algebra 学 这题想办法推一推转移矩阵的桥接矩阵 $\\Phi$ ，发现还蛮有规律的，大概是 $\\Phi_{i,j}=(-1)^{i+j}C_j^i$ ，然后可以比较简单的推出 $\\Phi^{-1}_{i,j}=C_j^i$ ，然后左乘矩阵就是一个沙雕卷积直接做就好~~感觉啥都没讲有问题评论区问吧~~ 下面介绍另外一个方法： 首先设 $f_{0,i}$ 表示当前轮值为 $i$ 的概率，那么下一轮值为 $i$ 的概率 $f_{1,i}$ 可以用 $f_0$ 递推 $$ \\begin{aligned} f_{1,i}=&\\sum\\limits_{j=i}^nf_{0,j}\\frac1{j+1}\\\\ 列出生成&函数F_0(x),F_1(x)\\\\ F_1(x)=&\\sum\\limits_{i=0}^nx^i\\sum\\limits_{j=0}^nf_{0,j}\\frac1{j+1}\\\\ =&\\sum\\limits_{j=0}^n\\frac{f_{0,j}}{j+1}\\sum\\limits_{i=0}^jx^i\\\\ =&\\sum\\limits_{j=0}^nf_{0,j}\\frac{x_j}{j+1}\\frac{x^{j+1}-1}{x-1}\\\\ =&\\frac1{x-1}\\sum\\limits_{j=0}^nf_{0,j}\\int_1^xt^j\\text dt\\\\ =&\\frac{\\int_1^xF_0(t)\\text dt}{x-1}\\\\ 令G_1(x)=&F_1(x+1)=\\frac{\\int_0^xF_0(t)\\text dt}{x-1}\\\\ 那么g_{1,i}=&\\frac{g_{0,i}}{i-1},g_{m,i}=\\frac{g_{0,i}}{(i-1)^m}\\\\ 用二项式&反演推出 f,g 正逆变换即可 \\end{aligned} $$ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly; #define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1e5+5;int n,invv[23],w[23],lim,tim;vector&lt;int&gt;rev[N];inline void init(const int&amp;up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=0;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;ll m;inline void init_ntt()&#123; w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]); invv[0]=1; for(ri i=1,iv=mod+1&gt;&gt;1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv);&#125;inline void ntt(poly&amp;a,int type)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))&#123; a0=a[j+k],a1=mul(a[j+k+i],mt); a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); &#125; if(~type)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;int fac[N],ifac[N],inv[N];inline void init_fac()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=n+1;++i)&#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;poly a,f,g;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); m=readl(); a.resize(n+1),f.resize(n+1),g.resize(n+1); for(ri i=0;i&lt;=n;++i)a[i]=read(); init_ntt(),init_fac(); for(ri i=0;i&lt;=n;++i)f[i]=mul(fac[i],a[i]),g[i]=ifac[i]; reverse(f.begin(),f.end()); a=f*g; a.resize(n+1); reverse(a.begin(),a.end()); for(ri i=0;i&lt;=n;++i)Mul(a[i],ifac[i]); for(ri i=0;i&lt;=n;++i)Mul(a[i],ksm(inv[i+1],m%(mod-1))); for(ri i=0;i&lt;=n;++i)f[i]=mul(fac[i],a[i]),g[i]=i&amp;1?mod-ifac[i]:ifac[i]; reverse(f.begin(),f.end()); a=f*g; a.resize(n+1); reverse(a.begin(),a.end()); for(ri i=0;i&lt;=n;++i)Mul(a[i],ifac[i]); for(ri i=0;i&lt;=n;++i)cout&lt;&lt;a[i]&lt;&lt;' '; return 0;&#125; 黎明前的巧克力解题思路： 对于每个数构造集合幂级数，发现是要求 $\\oplus_{i=1}^n(1+2x^{a_i})[x^0]$ 然后观察异或卷积的性质，假如第 $i$ 位为 $1$ ，那么它会根据 $j\\&i$ 的奇偶性对 $j$ 位置产生 $\\pm1$ 的贡献，因此每个数 $fwt$ 后每一位的结果一定为 $1$ 或者 $-3$ ，这样我们直接把 $\\sum_{i=1}^n(1+2x^{a_i})$ 拿来 $fwt$ ，然后解每一位有多少个 $-1,3$ 然后求出真实的点值表达式的乘积结果，然后再 $ifwt$ 回去即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef vector&lt;int&gt; poly;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=2e6+5;int n,a[N],mx=0,lim,pw[N];inline void fwt(int*f)&#123; for(ri a0,a1,i=1;i&lt;lim;i&lt;&lt;=1)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k)&#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=a0+a1,a[j+k+i]=a0-a1; &#125;&#125;inline void ifwt(int*f)&#123; for(ri iv=mod+1&gt;&gt;1,a0,a1,i=1;i&lt;lim;i&lt;&lt;=1)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k)&#123; a0=a[j+k],a1=a[j+k+i]; a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); Mul(a[j+k],iv),Mul(a[j+k+i],iv); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); pw[0]=1; for(ri i=1,vl;i&lt;=n;++i)&#123; pw[i]=add(pw[i-1],add(pw[i-1],pw[i-1])); ++a[0]; a[vl=read()]+=2; mx=max(mx,vl); &#125; for(lim=1;lim&lt;=mx;lim&lt;&lt;=1); fwt(a); for(ri x,i=0;i&lt;lim;++i)&#123; x=(a[i]+n)/4; a[i]=(n-x)&amp;1?mod-pw[x]:pw[x]; &#125; ifwt(a); cout&lt;&lt;dec(a[0],1); return 0;&#125; Radix sum解题思路： 不考虑模数的话就是 $10$ 进制 $fwt$ 裸题，现在有了模数，那么可以暴力扩域，用一个向量 $(a_0,a_1,...,a_9)^{\\text T}$ 来表示一个数 $\\sum\\limits_{i=0}^9a_i\\omega_{10}^i$，这样就能够正常的 $dft$ 了，然后再考虑怎么求 $10$ 的逆元，发现 $5$ 的逆元可以广义欧拉定理直接搞， $2$ 可以直接除，这样就做完了，不过最后求答案的时候需要爆算一波 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;typedef unsigned long long ull;const ull inv_5=57646075230342349ull;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=1e5+5;int n,a[N],mx=0,lim;ull c[20];struct cp&#123; ull a[10]; inline void clear()&#123;for(ri i=0;i&lt;10;++i)a[i]=0;&#125; inline ull&amp;operator[](const int&amp;k)&#123;return a[k];&#125; inline const ull&amp;operator[](const int&amp;k)const&#123;return a[k];&#125; friend inline cp operator*(cp a,cp b)&#123; for(ri i=0;i&lt;10;++i)for(ri j=0;j&lt;10;++j)c[i+j]+=a[i]*b[j]; for(ri i=0;i&lt;10;++i)a[i]=c[i]+c[i+10],c[i]=c[i+10]=0; return a; &#125; friend inline void operator*=(cp&amp;a,cp b)&#123;a=a*b;&#125; friend inline cp operator^(cp a,int p)&#123; cp res; res.clear(),res[0]=1; for(;p;p&gt;&gt;=1,a=a*a)if(p&amp;1)res=res*a; return res; &#125; inline cp fix()&#123; cp res=*this; for(ri i=0;i&lt;10;++i)res[i]=(res[i]&gt;&gt;1)*inv_5; return res; &#125; inline ull val()&#123;return (a[0]-a[2]+a[7]-a[5])%(1ull&lt;&lt;58);&#125;&#125;f[N&lt;&lt;1];inline void dwt(cp*f)&#123; cp s[10]; for(ri i=1;i&lt;lim;i*=10)for(ri j=0,len=i*10;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k)&#123; for(ri ps,p=0;p&lt;10;++p)&#123; s[p].clear(); for(ri ps,q=0;q&lt;10;++q)&#123; ps=p*q%10; for(ri o=0;o+ps&lt;10;++o)s[p][o+ps]+=f[j+k+q*i][o]; for(ri o=10-ps;o&lt;10;++o)s[p][o+ps-10]+=f[j+k+q*i][o]; &#125; &#125; for(ri p=0;p&lt;10;++p)f[j+k+p*i]=s[p]; &#125;&#125;inline void idwt(cp*f)&#123; static cp s[10]; for(ri i=1;i&lt;lim;i*=10)for(ri j=0,len=i*10;j&lt;lim;j+=len) for(ri k=0;k&lt;i;++k)&#123; for(ri ps,p=0;p&lt;10;++p)&#123; s[p].clear(); for(ri ps,q=0;q&lt;10;++q)&#123; ps=p*q%10; ps=ps?10-ps:0; for(ri o=0;o+ps&lt;10;++o)s[p][o+ps]+=f[j+k+q*i][o]; for(ri o=10-ps;o&lt;10;++o)s[p][o+ps-10]+=f[j+k+q*i][o]; &#125; &#125; for(ri p=0;p&lt;10;++p)f[j+k+p*i]=s[p].fix(); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)++f[a[i]=read()][0],mx=max(mx,a[i]); for(lim=10;lim&lt;mx;lim*=10); dwt(f); for(ri i=0;i&lt;lim;++i)f[i]=f[i]^n; idwt(f); for(ri i=0;i&lt;n;++i)cout&lt;&lt;f[i].val()&lt;&lt;'\\n'; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"Linear algebra","slug":"LA","date":"2019-11-26T14:38:38.000Z","updated":"2019-11-26T14:40:03.123Z","comments":true,"path":"LA/","link":"","permalink":"http://ldxcaicai.github.io/LA/","excerpt":"","text":"相似矩阵 定义：若对于矩阵 $\\text A$ 存在矩阵 $\\text B$ 和可逆矩阵 $\\Phi$ 满足 $\\text B=\\Phi^{-1}\\text A\\Phi$ ，那么我们称 $\\text A$ 相似于 $\\text B$ ，记做 $\\text A\\sim\\text B$相似有如下性质： 反身性： $\\text A\\sim\\text A$ 对称性： 如果 $\\text A\\sim\\text B$ ，那么 $\\text B\\sim\\text A$ 传递性： 如果 $\\text A\\sim\\text B,\\text B\\sim\\text C$ ，那么 $\\text A\\sim\\text C$ 相似矩阵有如下性质： 两者的秩相等 两者的行列式值相等 两者拥有同样的特征值，尽管相应的特征向量一般不同 两者拥有同样的特征多项式 两者可逆性相同，若均可逆，那么两者的逆矩阵同样相似 博主仅对第四点进行证明： \\begin{aligned} 0=|\\lambda\\text E-\\text B|=&|\\Phi^{-1}\\lambda\\Phi-\\Phi^{-1}\\text A\\Phi|\\\\ =&|\\Phi^{-1}(\\lambda\\text E-\\text A)\\Phi|\\\\ =&|\\Phi^{-1}|\\times|\\lambda\\text E-\\text A|\\times|\\Phi|\\\\ =&0\\\\ \\Rightarrow&|\\lambda\\text E-\\text A|=0 \\end{aligned} 用途可以用于解决关于对角化矩阵的问题，假设一个矩阵 $\\text A$ 与对角矩阵 $\\text B$ 相似，那么有 \\begin{aligned} \\text A^m=&(\\Phi^{-1}\\text B\\Phi)^m\\\\ =&\\Phi^{-1}\\text B(\\Phi\\text A\\Phi^{-1})^{m-1}\\Phi\\\\ =&\\Phi^{-1}\\text B^m\\Phi \\end{aligned}问题转化为求桥接矩阵 $\\Phi$ ，这个就各凭本事了 好吧还有一个定理如下：若 $\\text A$ 与对角矩阵 $\\text B$ 相似，那么 $\\text A$ 有 $n$ 个线性无关的特征向量，设为 $v_i$ ，那么 $\\Phi$ 就是将 $v_1\\cdots v_n$ 横向拼接起来得到的矩阵 问题转化为求逆矩阵 $\\Phi^{-1}$ ，这回是真的各凭本事了","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"杂题乱做 Round8","slug":"sol8","date":"2019-11-23T03:29:21.000Z","updated":"2019-12-25T00:01:19.839Z","comments":true,"path":"sol8/","link":"","permalink":"http://ldxcaicai.github.io/sol8/","excerpt":"","text":"青春猪头少年不会梦到兔女郎学姐解题思路： 首先是处理环的问题，~~这貌似是一个常见套路~~，即规定开头一定是第一种算出方案数再扣去开头结尾都是第一种的方案数，最后乘上每种方案被计算的次数即可 现在只需考虑序列上如何做，显然要对每种颜色分开考虑，相当于是将每种颜色分成若干段然后在序列上拼接使得相邻的两段不能是同一种颜色，~~这不又是那道[JSOI2019]神经网络吗~~，显然用容斥+生成函数解决，那么现在只用求把 $n$ 个颜色的球划分成 $m$ 段，所有方案的段乘积之和，这个也可以生成函数推导一下，推导如下： $$ \\begin{aligned} Ans=&[x^n](\\sum\\limits_{i=0}^{+\\infty}ix^i)^m\\\\ =&[x^n]x^m(\\sum\\limits_{i=0}^{+\\infty}x^i)^{2m}\\\\ =&[x^{n-m}](\\sum\\limits_{i=0}^{+\\infty}x^i)^{2m}\\\\ =&C_{n+m-1}^{2m-1} \\end{aligned} $$ 考虑枚举第 $i$ 种颜色分为了 $b_i$ 段，最后在序列上将相邻的段合起来后至少 $c_i$ 段，那么现在可以列出序列上答案的式子： $$ \\begin{aligned} Ans=&\\sum\\limits_{c}\\sum\\limits_{b}(\\prod\\limits C_{a_i+b_i-1}^{2b_i-1}C_{b_i-1}^{c_i-1}(-1)^{b_i-c_i})\\frac{(\\sum\\limits_{i=1}^nc_i)!}{\\prod\\limits_{i=-1}^nc_i!} \\end{aligned} $$ ~~然后把式子拆开对每种球都构造生成函数最后分治 $ntt$ 合并起来即可，注意第一种颜色需要进行特殊处理~~，好吧还是列一个生成函数的式子： $$ \\begin{aligned} f_i(x)=&\\sum\\limits_{i=0}^{a_i}\\frac{x^i}{i!}(\\sum\\limits_{b\\ge i}C_{a_i+b-1}^{2b}C_{b-1}^{i-1}(-1)^{b-c}) \\end{aligned} $$ 显然可以卷积处理 还剩一个问题是每种环被计算的次数，假设循环节的长度为 $len,m=\\sum\\limits_{i=1}^na_i$ ，第一种颜色的球在一个循环节中被分成了 $x$ 段，那么用上述做法实际被计算了 $\\frac{x}{\\frac{m}{len}}$ 次，二十几杀是哪个应该计算 $len$ 次，因此对于第一种颜色的球我们对每一位多除以一个 $x$ ，之后的答案再乘上 $m$ 即可得到正确答案 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int invv[23],w[23],lim,tim;vector&lt;int&gt;rev[23];inline void init_ntt()&#123; invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;23;++i)invv[i]=mul(invv[i-1],iv); w[22]=ksm(3,(mod-1)&gt;&gt;23); for(ri i=21;~i;--i)w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(int up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=0;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,a0,a1,t=0;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))a0=a[j+k],a1=mul(a[j+k+i],mt),a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(~typ)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j)Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;inline void revv(poly&amp;a)&#123;reverse(a.begin(),a.end());&#125;const int N=2e5+5;int a[N],n,m=0,fac[N&lt;&lt;1],inv[N&lt;&lt;1],ifac[N&lt;&lt;1];poly f[N];inline poly fix(poly a)&#123;for(ri i=0;i&lt;a.size();++i)Mul(a[i],ifac[i]);return a;&#125;inline poly solve(int l,int r)&#123; if(l==r)return fix(f[l]); int mid=l+r&gt;&gt;1; return solve(l,mid)*solve(mid+1,r);&#125;inline void init_fac()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=m;++i)&#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;inline void check()&#123; poly f(8); for(ri i=0;i&lt;8;++i)f[i]=i; init(8); f.resize(lim); ntt(f,1); ntt(f,-1);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(),m+=a[i]; if(n==1)&#123; cout&lt;&lt;a[1]; return 0; &#125; init_fac(); init_ntt(); check(); for(ri i=1;i&lt;=n;++i)&#123; poly fa(a[i]+1),fb(a[i]+1); for(ri j=1;j&lt;=a[i];++j)fa[j]=mul(C(a[i]+j-1,a[i]-j),fac[j-1]); if(i==1)for(ri j=1;j&lt;=a[i];++j)Mul(fa[j],inv[j]); for(ri j=0;j&lt;=a[i];++j)fb[a[i]-j]=j&amp;1?mod-ifac[j]:ifac[j]; fa=fa*fb; f[i]=poly(a[i]+1); for(ri j=1;j&lt;=a[i];++j)f[i][j]=mul(fa[a[i]+j],ifac[j-1]); &#125; int res=0; poly g=solve(2,n),h(a[1]); for(ri i=0;i&lt;a[1];++i)h[i]=mul(f[1][i+1],ifac[i]); h=g*h; for(ri i=1;i&lt;h.size();++i)Add(res,mul(h[i],fac[i])); if(a[1]&gt;1)&#123; h=poly(a[1]-1); for(ri i=0;i&lt;a[1]-1;++i)h[i]=mul(f[1][i+2],ifac[i]); h=g*h; for(ri i=1;i&lt;h.size();++i)Dec(res,mul(h[i],fac[i])); &#125; cout&lt;&lt;mul(res,m); return 0;&#125; Endless Spin解题思路： ~~又一道套路题~~，考虑用 $min-max$ 容斥转化问题，变为求一个集合所有元素第一次被覆盖时间的最小值，这个可以用概率转化+一个简单 $dp$ 来求，首先设这个集合某个元素被覆盖的概率为 $P$ ，那么这个集合某个元素被覆盖的期望次数为 $\\sum\\limits_{i=0}^{+\\infty}(\\frac{1-P}{1})^i=\\frac1P$ ，设 $f_{i,j,0/1}$ 表示处理到第 $i$ 个位置，有 $j$ 个区间跟当前集合不相交，当前集合中元素的奇偶性为 $0/1$ 的方案数，然后~~该怎么转移怎么转移~~，注意最后答案要维护一个小数类 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=55;int n;struct Db&#123; ll a[31]; inline ll&amp;operator[](const int&amp;k)&#123;return a[k];&#125; inline const ll&amp;operator[](const int&amp;k)const&#123;return a[k];&#125; inline void trans(ll _a,ll _b)&#123; a[0]=_a/_b; _a%=_b; for(ri i=1;i&lt;=30;++i)_a*=10,a[i]=_a/_b,_a%=_b; &#125; friend inline Db operator+(Db a,Db b)&#123; Db c; ll dt=0; for(ri i=30;~i;--i)&#123; c[i]=a[i]+b[i]+dt; if(i)dt=c[i]/10,c[i]%=10; &#125; return c; &#125; friend inline Db operator-(Db a,Db b)&#123; for(ri i=30;i;--i)&#123; if(a[i]&lt;b[i])--a[i-1],a[i]+=10; a[i]-=b[i]; &#125; return a[0]-=b[0],a; &#125; friend inline Db operator*(Db a,ll b)&#123; ll dt=0; for(ri i=30;~i;--i)&#123; a[i]*=b; a[i]+=dt; if(i)dt=a[i]/10,a[i]%=10; &#125; return a; &#125;&#125;res[N],tmp1,tmp2,tmp;inline void print(Db a)&#123; if(a[16]&gt;4)++a[15]; for(ri i=15;i;--i)&#123; if(a[i]==10)++a[i-1],a[i]=0; else break; &#125; cout&lt;&lt;a[0]&lt;&lt;'.'; for(ri i=1;i&lt;=15;++i)cout&lt;&lt;a[i]; puts(\"\");&#125;inline int calc(int x)&#123;return x*(x+1)&gt;&gt;1;&#125;ll f[N][N*N][2];//double res[N];inline void init()&#123; for(ri all,n=1;n&lt;=50;++n)&#123; memset(f,0,sizeof(f)); f[0][0][0]=1; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;i;++j) for(ri num=calc(i-j-1),up=calc(i);num&lt;=up;++num) for(ri op=0;op&lt;2;++op)f[i][num][op]+=f[j][num-calc(i-j-1)][!op]; all=calc(n); tmp1.trans(0,1); tmp2.trans(0,1); for(ri i=1;i&lt;=n;++i)for(ri num=0,up=calc(i);num&lt;=up;++num)if(f[i][num][1]!=f[i][num][0])&#123; tmp.trans(f[i][num][1],all-num-calc(n-i)); tmp1=tmp1+tmp*all; tmp.trans(f[i][num][0],all-num-calc(n-i)); tmp2=tmp2+tmp*all; &#125; res[n]=tmp1-tmp2; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri tt=read();tt;--tt)print(res[read()]); return 0;&#125; 斐波那契的最小公倍数解题思路： 首先有一个结论 $\\gcd(fib_a,fib_b)=fib_{\\gcd(a,b)}$ ，下面给出证明： 首先有两个引理 1. $\\gcd(fib_i,fib_{i-1})=\\gcd(fib_{i-1},fib_{i-2})=\\cdots=1$ 2. $fib_{n+m}=fib_{n-1}\\times fib_{m}+fib_{n}\\times fib_{m+1}$ ，这个考虑利用数学归纳法， $m=1$ 时显然成立，那么 $$ \\begin{aligned} fib_{n+m}=&fib_{n+m-1}+fib_{n+m-2}\\\\ =&fib_{n-1}fib_{m-1}+fib_{n}fib_{m}+fib_{n-2}fib_{m-1}+fib_{n-1}fib_{m}\\\\ =&fib_{n}fib_{m-1}+fib_{n}fib_{m}+fib_{n-1}fib_{m}\\\\ =&fib_{n-1}fib_{m}+fib_{n}fib_{m+1}\\\\ \\Rightarrow \\gcd(fib_{n+m},fib_n)=&\\gcd(fib_{n-1}fib_{m}+fib_{n}fib_{m+1},fib_n)\\\\ =&\\gcd(fib_{n-1}fib_{m},fib_n)\\\\ =&\\gcd(fib_n,fib_m) \\end{aligned} $$ 发现就是辗转相除的形式，因此原命题得证 现在考虑到最后答案相当于是质因数的指数取 $\\max$ ，因此我们对指数给 $min-max$ 容斥一波变成取 $\\min$ $$ \\begin{aligned} lcm(f_{\\{S\\}})=\\prod\\limits_{T\\subseteq S,T\\not=\\emptyset}f_{\\gcd\\{T\\}}^{(-1)^{|T|+1}} \\end{aligned} $$ 那么问题可以转化为求 $\\gcd=d$ 且集合大小为奇数/偶数的集合有多少个，显然可以用 $Mobius$ 反演搞，复杂度 $O(n\\ln n)$ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p,int md)&#123;int ret=1;for(;p;p&gt;&gt;=1,a=(ll)a*a%md)(p&amp;1)&amp;&amp;(ret=(ll)ret*a%md);return ret;&#125;&#125;using namespace modular;const int N=50005,M=1e6+5;int fib[M],pw[M],cnt[M],a[N],mu[M],pri[M],tot=0,mx=0,n,ct[M];bool vs[M];inline void init()&#123; fib[1]=fib[2]=1; for(ri i=3;i&lt;=mx;++i)fib[i]=add(fib[i-1],fib[i-2]); for(ri i=1;i&lt;=mx;++i)for(ri j=i;j&lt;=mx;j+=i)cnt[i]+=ct[j]; mu[1]=1; for(ri i=2;i&lt;=mx;++i)&#123; if(!vs[i])pri[++tot]=i,mu[i]=mod-2; for(ri j=1,up=mx/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j)&#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j])&#123; mu[i*pri[j]]=0; break; &#125; mu[i*pri[j]]=mod-1-mu[i]; &#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(),mx=max(mx,a[i]); sort(a+1,a+n+1),n=unique(a+1,a+n+1)-a-1; for(ri i=1;i&lt;=n;++i)++ct[a[i]]; init(); for(ri i=1;i&lt;=mx;++i)cnt[i]&amp;&amp;(cnt[i]=ksm(2,cnt[i]-1,mod-1)); for(ri i=1;i&lt;=mx;++i)for(ri j=i;j&lt;=mx;j+=i) pw[i]=(pw[i]+(ll)mu[j/i]*cnt[j]%(mod-1))%(mod-1); for(ri i=1;i&lt;=mx;++i)cnt[i]&amp;&amp;(--cnt[i]); for(ri i=1;i&lt;=mx;++i)for(ri j=i;j&lt;=mx;j+=i) pw[i]=(pw[i]-(ll)mu[j/i]*cnt[j]%(mod-1)+(mod-1))%(mod-1); int res=1; for(ri i=1;i&lt;=mx;++i)Mul(res,ksm(fib[i],pw[i],mod)); cout&lt;&lt;res; return 0;&#125; 最小公倍佩尔数解题思路： 首先可以解出递推式 $f_i=2f_{i-1}+f_{i-2}$ ，跟上一道题一样可以推出 $\\gcd(f_i,f_j)=f_{\\gcd(i,j)}$ ，但发现这题每组数据要求多个答案，因此上道题的方法貌似已经不适用了，我们考虑一种新的转化： $$ \\begin{aligned} lcm(f_{\\{S\\}})=\\prod\\limits_{T\\subseteq S,T\\not=\\emptyset}f_{\\gcd\\{T\\}}^{(-1)^{|T|+1}} \\end{aligned} $$ 考虑构造函数 $g(x)$ 满足 $\\prod\\limits_{d|x}g(d)=f(x)$ ，发现这个 $g(x)$ 居然也能 $O(n\\ln n)$ 的时间预处理出来，且 $$ \\begin{aligned} lcm(f_{\\{S\\}})=&\\prod\\limits_{T\\subseteq S,T\\not=\\emptyset}(\\prod\\limits_{d|\\gcd{\\{T\\}}}g(d))^{(-1)^{|T|+1}}\\\\ =&\\prod\\limits_{d}g_d^{\\sum\\limits_{T\\subseteq S,T\\not=\\emptyset,d|\\gcd{\\{T\\}}}(-1)^T}\\\\ =&\\prod\\limits_{d}g_d \\end{aligned} $$ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125;&#125;using namespace modular;const int N=1e6+5;int f[N],g[N],n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(),mod=read(); f[1]=g[1]=1; for(ri i=2;i&lt;=n;++i)f[i]=g[i]=add(add(f[i-1],f[i-1]),f[i-2]); for(ri t,i=2;i&lt;=n;++i)&#123; t=Inv(g[i]); for(ri j=i+i;j&lt;=n;j+=i)Mul(g[j],t); &#125; int res=0,pre=1; for(ri i=1;i&lt;=n;++i)Mul(pre,g[i]),Add(res,mul(pre,i)); cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125; 生成树计数解题思路： 考虑 $k$ 次幂的组合意义可以用生成函数表示，那么对于每一条边构造生成函数 $f_t(x)=\\sum\\limits_{i=0}^{+\\infty}\\frac{(w_tx)^i}{i!}$ ，然后把这个当成元素求行列式值最后取多项式的第 $K$ 项系数即可，然而直接用多项式求值不是很好做，因此我们带入点值进去算最后用牛顿插值/拉格朗日插值把系数搞出来就行了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline int fix(int x)&#123;return (x%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=55,M=10005;int n,K,m,w[N][N],a[N][N],f[N],fac[M],ifac[M],inv[M];inline void init()&#123; fac[0]=ifac[0]=fac[1]=ifac[1]=inv[1]=1; for(ri i=2;i&lt;=10000;++i)&#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125;&#125;inline int calc()&#123; int res=1; for(ri ps,i=1;i&lt;n;++i)&#123; for(ps=i;ps&lt;=n;++ps)if(a[ps][i])&#123; ps=i; break; &#125; if(ps==n+1)return 0; if(ps^i)&#123; for(ri j=1;j&lt;=n;++j)swap(a[ps][j],a[i][j]); res=res?mod-res:0; &#125; for(ri j=1,t,iv=Inv(a[i][i]);j&lt;=n;++j)if(j!=i&amp;&amp;a[j][i])&#123; t=mul(a[j][i],iv); for(ri k=i;k&lt;=n;++k)Dec(a[j][k],mul(t,a[i][k])); &#125; Mul(res,a[i][i]); &#125; return res;&#125;struct Newton_Inter&#123; int up,px[M],py[M],cur,dt[2][M],f[M],ff[M]; Newton_Inter()&#123;up=cur=0;&#125; inline int&amp;operator[](const int&amp;k)&#123;return f[k];&#125; inline const int&amp;operator[](const int&amp;k)const&#123;return f[k];&#125; inline void insert(int x,int y)&#123; px[++up]=x,py[up]=y; if(up==1)dt[cur][0]=f[0]=y,ff[0]=1; else&#123; cur^=1,dt[cur][0]=y; for(ri i=1;i&lt;up;++i)dt[cur][i]=mul(dec(dt[cur][i-1],dt[!cur][i-1]),inv[px[up]-px[up-i]]); for(ri i=up-1;~i;--i)ff[i]=add(i?ff[i-1]:0,mul(mod-px[up-1],ff[i])); for(ri i=0;i&lt;up;++i)Add(f[i],mul(ff[i],dt[cur][up-1])); &#125; &#125;&#125;F;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); init(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)w[i][j]=read(); m=n*K; for(ri t=0;t&lt;=m;++t)&#123; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)a[i][j]=0; for(ri res,i=1;i&lt;=n;++i)for(ri j=1;j&lt;i;++j)&#123; res=0; for(ri mt=1,_t=mul(t,w[i][j]),_pw=0;_pw&lt;=K;++_pw)&#123; Add(res,mul(mt,ifac[_pw])); Mul(mt,_t); &#125; Add(a[i][i],res); Add(a[j][j],res); Dec(a[i][j],res); Dec(a[j][i],res); &#125; F.insert(t,calc()); &#125; cout&lt;&lt;mul(F[K],fac[K]); return 0;&#125; Mike and Fish解题思路： 考虑将行列扯出来建二分图，然后将限制改为 $black=white$ 且保证合法怎么做，发现只用在二分图上跑欧拉回路即可，那么现在可能有度数为奇数的点，我们在两边各建一个虚点处理即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=4e5+5;int n,idx=0;bool col[N],vs[N];pii a[N];vector&lt;pii&gt;e[N];void dfs(int p)&#123; pii tmp; while((int)e[p].size())&#123; tmp=e[p].back(); e[p].pop_back(); if(vs[tmp.se])continue; vs[tmp.se]=1; col[tmp.se]=p&lt;tmp.fi; dfs(tmp.fi); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; a[i].fi=read(); a[i].se=read()+200000; ++idx; e[a[i].fi].pb(pii(a[i].se,idx)); e[a[i].se].pb(pii(a[i].fi,idx)); &#125; for(ri i=1;i&lt;=400000;++i)&#123; if(((int)e[i].size())&amp;1)&#123; ++idx; e[i].pb(pii(400001,idx)); e[400001].pb(pii(i,idx)); &#125; &#125; for(ri i=1;i&lt;=400001;++i)dfs(i); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;(col[i]?'r':'b'); return 0;&#125; XOR Replace解题思路： 设 $a_{n+1}=\\oplus_{i=1}^na_i$ ，仔细观察发现每次操作相当于 $swap(a_i,a_{n+1})$ ，那么我们将不同的 $(a_i,b_i)$ 连边，最后按照连通块数讨论即可得到答案，大概就是联通块内按照置换的方式一定可以用连通块大小数次换完，两个连通块之间需要用一次来进行转换 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=4e5+5;int n,a[N],b[N],_a[N],_b[N];inline bool check()&#123; for(ri i=1;i&lt;=n+1;++i)_a[i]=a[i],_b[i]=b[i]; sort(_a+1,_a+n+2); sort(_b+1,_b+n+2); for(ri i=1;i&lt;=n+1;++i)if(_a[i]^_b[i])return 0; return 1;&#125;int vl[N&lt;&lt;1],sig=0;inline int Find(int x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;int ft[N&lt;&lt;1];inline int find(int x)&#123;return x^ft[x]?ft[x]=find(ft[x]):x;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[n+1]^=(a[i]=read()); for(ri i=1;i&lt;=n;++i)b[n+1]^=(b[i]=read()); if(!check())&#123; cout&lt;&lt;-1; return 0; &#125; int res=0; vl[++sig]=a[n+1]; vl[++sig]=b[n+1]; for(ri i=1;i&lt;=n;++i)&#123; if(a[i]==b[i])continue; vl[++sig]=a[i]; vl[++sig]=b[i]; ++res; &#125; if(!res)&#123; cout&lt;&lt;0; return 0; &#125; sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=sig;++i)ft[i]=i; for(ri i=1;i&lt;=n+1;++i)&#123; if(a[i]==b[i])continue; a[i]=find(Find(a[i])); b[i]=find(Find(b[i])); if(a[i]^b[i])ft[b[i]]=a[i]; &#125; for(ri i=1;i&lt;=sig;++i)if(ft[i]==i)++res; cout&lt;&lt;res-1; return 0;&#125; Two Trees解题思路： 能否构造只需考虑同一个点在两棵树中儿子数的奇偶性是否相同，下面给出相同时的构造方案 首先一棵树中一定有奇数个值为奇数的点，不妨设为 $2k+1$ 个，考虑让其中 $2k$ 个两两配对一个 $1$ 一个 $-1$ ，剩下一个随意 $1$ 或者 $-1$ 就能保证这个子树的权值和绝对值为 $1$ ，那么考虑怎么限制 $1$ 和 $-1$ 匹配的关系：可以将当前未匹配且儿子数为偶数的点放到一个序列中然后每两个连一条边，这样两棵树都连好后一定搞出来一个二分图，二分图染色即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=1e5+5;int n,ans[N];vector&lt;int&gt;e[N];struct Tree&#123; vector&lt;int&gt;g[N]; int rt,stk[N],top; void dfs(int p)&#123; for(ri i=0,v;i&lt;g[p].size();++i)dfs(v=g[p][i]); if(!(((int)g[p].size())&amp;1))stk[++top]=p; while(top&gt;1)&#123; e[stk[top]].pb(stk[top-1]); e[stk[top-1]].pb(stk[top]); top-=2; &#125; &#125; inline void init()&#123; for(ri ft,i=1;i&lt;=n;++i)&#123; ft=read(); if(ft==-1)rt=i; else g[ft].pb(i); &#125; &#125; inline void solve()&#123; top=0; dfs(rt); &#125;&#125;t[2];bool vs[N],col[N];void dfs(int p,int cl)&#123; if(vs[p])return; vs[p]=1; col[p]=cl; for(ri i=0;i&lt;e[p].size();++i)dfs(e[p][i],cl^1);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=0;i&lt;2;++i)t[i].init(); for(ri i=1;i&lt;=n;++i)if(((int)t[0].g[i].size()+(int)t[1].g[i].size())&amp;1)&#123; puts(\"IMPOSSIBLE\"); return 0; &#125; puts(\"POSSIBLE\"); for(ri i=0;i&lt;2;++i)t[i].solve(); for(ri i=1;i&lt;=n;++i)dfs(i,0); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;((((int)t[0].g[i].size())&amp;1)?0:(col[i]?1:-1))&lt;&lt;' '; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"杂题乱做 Round7","slug":"sol7","date":"2019-11-18T03:35:12.000Z","updated":"2019-12-24T23:59:40.103Z","comments":true,"path":"sol7/","link":"","permalink":"http://ldxcaicai.github.io/sol7/","excerpt":"","text":"Sockpuppets解题思路： 考虑到题目的匹配条件显然需要建一棵 $trie$ 树出来，注意到这棵树深度不超过 $10$ ，考虑设 $f_{i,j,k}$ 表示当前处理到子树 $i$ ，子树中有 $j$ 个点需要进行匹配，自己的祖先已经有 $k$ 个被提前选用匹配的方案数，然后按照当前点的类型分开转移即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;typedef unsigned long long Ull;typedef unsigned int uii;typedef double db;typedef long double ld;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=20005;int f[N][15][25],tmp[15][25],n,m;inline int calc1(int x)&#123;return x&lt;2?1:mod+1&gt;&gt;1;&#125;inline int calc2(int x,int y)&#123; if(!x)return 1; if(x==1)return y; return (ll)y*(y-1)/2%mod;&#125;namespace trie&#123; int tot,son[N][26],cnt1[N],cnt2[N]; inline int newnode()&#123; ++tot; memset(son[tot],0,sizeof(son[tot])); cnt1[tot]=cnt2[tot]=0; return tot; &#125; inline void insert(char*s,int len,int c1,int c2)&#123; int p=0; for(ri x,i=1;i&lt;=len;++i)&#123; x=s[i]-'a'; if(!son[p][x])son[p][x]=newnode(); p=son[p][x]; &#125; cnt1[p]+=c1,cnt2[p]+=c2; &#125; void dfs(int p)&#123; for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)f[p][i][j]=0; f[p][0][0]=1; for(ri v,s=0;s&lt;26;++s)if(son[p][s])&#123; dfs(v=son[p][s]); for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)if(f[p][i][j]) for(ri k=0;k+i&lt;=10;++k)for(ri l=0;j+l&lt;=20;++l)if(f[v][k][l]) Add(tmp[i+k][j+l],mul(f[p][i][j],f[v][k][l])); for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)&#123; f[p][i][j]=tmp[i][j]; tmp[i][j]=0; &#125; &#125; if(!cnt1[p]&amp;&amp;!cnt2[p])return; for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)if(f[p][i][j])&#123; if(cnt1[p])&#123; for(ri k=0;k&lt;=2;++k)for(ri l=0;l&lt;=2;++l) if(k+l&gt;0&amp;&amp;k+l&lt;3&amp;&amp;i+k&lt;=10&amp;&amp;j&gt;=l)Add(tmp[i+k][j-l],mul(f[p][i][j],mul(calc1(k),calc2(l,j)))); &#125; else&#123; if(i)Add(tmp[i-1][j],mul(i,f[p][i][j])); if(j&lt;20)Add(tmp[i][j+1],f[p][i][j]); &#125; &#125; for(ri i=0;i&lt;=10;++i)for(ri j=0;j&lt;=20;++j)&#123; Add(f[p][i][j],tmp[i][j]); tmp[i][j]=0; &#125; &#125;&#125;char s[15];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read(),cas=1;cas&lt;=tt;++cas)&#123; printf(\"Case #%d: \",cas); n=read(),m=read(); trie::tot=0; memset(trie::son[0],0,sizeof(trie::son[0])); for(ri i=1,len;i&lt;=n;++i)&#123; len=Read(s); trie::insert(s,len,1,0); &#125; for(ri i=1,len;i&lt;=m;++i)&#123; len=Read(s); trie::insert(s,len,0,1); &#125; trie::dfs(0); cout&lt;&lt;f[0][0][0]&lt;&lt;'\\n'; &#125; return 0;&#125; Drazil and Morning Exercise解题思路： 我写的是自己想的一个垃圾 $O(Tn\\log n)$ 看了一下 $mayaohua$ 神仙的 $blog$ 貌似能用并查集优化到 $O(Tn\\alpha(n))$ ，首先预处理出每个点到其最远点的距离，然后发现若对于两个点 $(u,v)$ 按照其距离从大的往小的连边会连出来一棵内向树，且对于这棵树每个点的合法范围一定是一个以其为根的连通块，那么用个离散化+ $dfs$ 序+主席树就可以求子树内比某个数小的点数 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef double db;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;typedef unsigned long long Ull;typedef unsigned int uii;typedef double db;typedef long double ld;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;char xxx;const int N=1e5+5;vector&lt;pii&gt;e[N];int n,sig=0,rt[N];ll f[N],_f[N],g[N],vl[N],a[N];inline int find(ll x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;void dfs1(int p,int ft)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==ft)continue; dfs1(v,p); if(f[v]+e[p][i].se&gt;=f[p])&#123; _f[p]=f[p]; f[p]=f[v]+e[p][i].se; &#125; else ckmax(_f[p],f[v]+e[p][i].se); &#125;&#125;void dfs2(int p,int ft)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==ft)continue; g[v]=max(g[p],f[v]+e[p][i].se==f[p]?_f[p]:f[p])+e[p][i].se; dfs2(v,p); &#125;&#125;int in[N],out[N],pred[N],tot=0,ps[N];void dfs(int p,int ft)&#123; pred[in[p]=++tot]=p; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==ft)continue; dfs(v,p); &#125; out[p]=tot;&#125;namespace sgt&#123; #define lc (son[p][0]) #define rc (son[p][1]) #define mid (l+r&gt;&gt;1) int siz[N*100],son[N*100][2],cnt=0; inline void update(int&amp;p,int o,int l,int r,int k)&#123; p=++cnt; siz[p]=siz[o]+1,lc=son[o][0],rc=son[o][1]; if(l==r)return; k&lt;=mid?update(lc,lc,l,mid,k):update(rc,rc,mid+1,r,k); &#125; inline int query(int a,int b,int l,int r,int ql,int qr)&#123; if(siz[a]==siz[b])return 0; if(ql&lt;=l&amp;&amp;r&lt;=qr)return siz[b]-siz[a]; if(qr&lt;=mid)return query(son[a][0],son[b][0],l,mid,ql,qr); if(ql&gt;mid)return query(son[a][1],son[b][1],mid+1,r,ql,qr); return query(son[a][0],son[b][0],l,mid,ql,qr)+query(son[a][1],son[b][1],mid+1,r,ql,qr); &#125; #undef lc #undef rc #undef mid&#125;char yyy;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); cerr&lt;&lt;(&amp;yyy-&amp;xxx)/1024/1024&lt;&lt;\"ldxcaicai\\n\"; #endif n=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); &#125; dfs1(1,0); dfs2(1,0); for(ri i=1;i&lt;=n;++i)vl[i]=a[i]=max(f[i],g[i]); sort(vl+1,vl+n+1),sig=unique(vl+1,vl+n+1)-vl-1; for(ri i=1;i&lt;=n;++i)a[i]=find(a[i]); int _rt=1; for(ri i=2;i&lt;=n;++i)if(a[i]&lt;a[_rt])_rt=i; dfs(_rt,0); for(ri i=1;i&lt;=n;++i)sgt::update(rt[i],rt[i-1],1,sig,a[pred[i]]); for(ri tt=read();tt;--tt)&#123; ll x=readl(); for(ri l=1,r=0;l&lt;=sig;++l)&#123; while(r&lt;sig&amp;&amp;vl[r+1]-vl[l]&lt;=x)++r; ps[l]=r; &#125; int res=0; for(ri L,R,i=1;i&lt;=n;++i)&#123; ckmax(res,sgt::query(rt[in[i]-1],rt[out[i]],1,sig,a[i],ps[a[i]])); &#125; cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125; Numbers on the blackboard解题思路： 这题比较有意思，考虑离线下所有询问将其放在其右端点处，同时用增量法构造一些组，最后从左向右合并每个组，而组内则从右向左合并。 考虑如何分组最优，如果一个组的所有数从右向左的累加和大于 $0$ 就跟前一个组进行合并，否则就不合并，这个可以用并查集随便维护一下然后就做完了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std; //MoBannamespace MoBan&#123;//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi; // Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second //Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back //Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi; //Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del erase const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++) //Inputinline int read()&#123; bool f=1; int ans=0; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125; //Fileinline void file()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); freopen(\"lx.out\",\"w\",stdout); #endif&#125; //Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;&#125;using namespace MoBan; //Modularnamespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(csi&amp;a)&#123;return ksm(a,mod-2);&#125; inline int fix(csi&amp;a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular; //My solconst int N=5e5+5,inf=1e9+7;int n,a[N],ft[N],m,ans[N],sum[N],idx[N],vl[N],pre[N],top=0,pw[N],ipw[N],ss[N];pii stk[N];vector&lt;pii&gt;qry[N];inline int find(int x)&#123;return ft[x]^x?ft[x]=find(ft[x]):x;&#125;inline int calc(int l,int r)&#123;return mul(ipw[l],dec(ss[r],ss[l-1]));&#125; //Mainsigned main()&#123; file(); n=read(),m=read(); pw[0]=ipw[0]=1; for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(),ft[i]=i; pw[i]=add(pw[i-1],pw[i-1]); ipw[i]=mul(ipw[i-1],mod+1&gt;&gt;1); &#125; for(ri i=1,l,r;i&lt;=m;++i)&#123; l=read(),r=read(); qry[r].pb(pii(l,i)); &#125; for(ri i=1;i&lt;=n;++i)&#123; ss[i]=add(ss[i-1],mul(pw[i],fix(a[i]))); idx[i]=++top; stk[top]=pii(i,i); sum[top]=a[i]; vl[top]=fix(a[i]); while(top&gt;1&amp;&amp;sum[top]&gt;0)&#123; int fx=find(stk[top].fi),fy=find(stk[top-1].fi); ft[fx]=fy; if(stk[top-1].se-stk[top-1].fi+1&gt;=30||sum[top]==inf||sum[top-1]==inf)sum[top-1]=inf; else sum[top-1]=min((ll)inf,(((ll)sum[top])&lt;&lt;(stk[top-1].se-stk[top-1].fi+1))+sum[top-1]); vl[top-1]=add(mul(pw[stk[top-1].se-stk[top-1].fi+1],vl[top]),vl[top-1]); stk[top-1].se=stk[top].se; --top; &#125; pre[top]=add(pre[top-1],vl[top]); for(ri res=0,j=0,l,r,L,R,id;j&lt;qry[i].size();++j)&#123; l=qry[i][j].fi,r=i,id=qry[i][j].se; L=idx[find(l)],R=idx[find(r)]; ans[id]=add(calc(l,stk[L].se),mul(2,dec(pre[R],pre[L]))); &#125; &#125; for(ri i=1;i&lt;=m;++i)cout&lt;&lt;ans[i]&lt;&lt;'\\n'; return 0;&#125; 主旋律解题思路： 比较套路的一道题，考虑这种 $DAG$ 计数都是删去入度或者出度为 $0$ 的点，然后枚举子集补集转化转移即可，关于这道题，定义 $f_s$ 表示集合 $s$ 合法方案数， $g_s$ 表示集合 $s$ 由若干强连通分量拼接而成的方案数， $sum_s$ 表示集合 $s$ 中的边数， $coe_{s,t}$ 表示集合 $s$ 中子集 $t$ 的出度为 $0$ 的方案数，对于 $g_s$ ，我们先不把 $f_s$ 算入其中，这样就有 $f_s=2^{sum_s}-\\sum\\limits_{T\\subset S}g_Tcoe_{S,T}$ ，显然 $coe$ 是很好处理的，问题转化为求 $g$ ，对于 $g$ 我们枚举其最小标号所在的连通块然后就可以转移了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;//MoBannamespace MoBan&#123;//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi;// Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second//Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back//Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi;//Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del eraseconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)//Inputinline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;//Fileinline void file()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #else #ifndef ONLINE_JUDGE freopen(\"a.in\",\"r\",stdin); freopen(\"a.out\",\"w\",stdout); #endif #endif&#125;//Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;&#125;using namespace MoBan;//Modularnamespace modular&#123; const int mod=1e9+7; inline int add(csi&amp;a,csi&amp;b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(csi&amp;a,csi&amp;b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(csi&amp;a,csi&amp;b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,csi&amp;b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,csi&amp;b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,csi&amp;b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,1),1);return ret;&#125; inline int Inv(csi&amp;a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;//My solconst int N=16;int n,m,in[1&lt;&lt;15],out[1&lt;&lt;15],pw[N*N],all,cnt[1&lt;&lt;15],f[1&lt;&lt;15],g[1&lt;&lt;15],sum[1&lt;&lt;15],coe[1&lt;&lt;15];inline void dfs(int S,int cur)&#123; if(!cur)return; dfs(S,(cur-1)&amp;S); int t=cur&amp;-cur; coe[cur]=add(dec(coe[cur^t],cnt[out[t]&amp;cur]),cnt[in[t]&amp;(S^cur)]);&#125;//Mainint main()&#123; file(); n=read(),m=read(); pw[0]=1; for(ri i=1;i&lt;=m;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read()-1,v=read()-1; out[pw[u]]|=pw[v]; in[pw[v]]|=pw[u]; &#125; all=pw[n]; for(ri s=1,t;s&lt;all;++s)&#123; t=s&amp;-s; cnt[s]=cnt[s^t]+1; sum[s]=sum[s^t]+cnt[in[t]&amp;s]+cnt[out[t]&amp;s]; dfs(s,s); for(ri ns=t^s,nt=ns;nt;nt=(nt-1)&amp;ns)Dec(g[s],mul(g[nt],f[s^nt])); f[s]=pw[sum[s]]; for(ri nt=s;nt;nt=(nt-1)&amp;s)Dec(f[s],mul(g[nt],pw[sum[s^nt]+coe[nt]])); Add(g[s],f[s]); &#125; cout&lt;&lt;f[all-1]; return 0;&#125; Biconnected解题思路： 跟上一题思路类似，这不过这题缩完点之后变成了一棵树，因此要预处理一个 $f_s$ 表示点集 $s$ 连通的方案数，剩下的跟上题基本一样，这里不一一赘述 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;//MoBannamespace MoBan&#123;//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi;// Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second//Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back//Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi;//Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del eraseconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)//Inputinline int read()&#123; bool f=1; int ans=0; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;//Fileinline void file()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif&#125;//Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;&#125;using namespace MoBan;//Modularnamespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(csi&amp;a)&#123;return ksm(a,mod-2);&#125; inline int fix(csi&amp;a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular;//My solconst int N=15;int n,m,f[1&lt;&lt;11],g[1&lt;&lt;11],cnt[1&lt;&lt;11],tot[1&lt;&lt;11],pw[15*15],res[1&lt;&lt;11],h[1&lt;&lt;11][1&lt;&lt;11];inline void init()&#123; pw[0]=1; for(ri i=1;i&lt;144;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri s=1;s&lt;pw[11];++s)cnt[s]=cnt[s&gt;&gt;1]+(s&amp;1);&#125;inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void init_f()&#123; f[0]=1; for(ri s=1;s&lt;pw[n];++s)&#123; g[s]=0; for(ri ns=s^lowbit(s),nt=ns;nt;nt=(nt-1)&amp;ns)Add(g[s],mul(f[s^nt],pw[tot[nt]])); f[s]=dec(pw[tot[s]],g[s]); &#125;&#125;inline int Connect(int s,int t)&#123;return dec(tot[s|t],add(tot[s],tot[t]));&#125;inline void init_h()&#123; for(ri s=0;s&lt;pw[n];++s)h[0][s]=1; for(ri s=1;s&lt;pw[n];++s)for(ri t=(pw[n]-1)^s,S=t;t;t=(t-1)&amp;S)&#123; h[s][t]=0; for(ri ns=s^lowbit(s),nt=ns;;nt=(nt-1)&amp;ns)&#123; Add(h[s][t],mul(mul(h[nt][t],f[s^nt]),Connect(s^nt,t))); if(!nt)break; &#125; &#125;&#125;//Mainint main()&#123; file(); init(); for(ri tt=read();tt;--tt)&#123; n=read(),m=read(); for(ri i=1;i&lt;pw[n];++i)tot[i]=cnt[i]*(cnt[i]-1)/2; for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read()-1,v=read()-1; for(ri s=(pw[n]-1)^pw[u]^pw[v],t=s;;t=(t-1)&amp;s)&#123; --tot[t^pw[u]^pw[v]]; if(!t)break; &#125; &#125; init_f(); init_h(); for(ri s=0;s&lt;pw[n];++s)&#123; res[s]=f[s]; for(ri ns=s^lowbit(s),nt=ns;nt;nt=(nt-1)&amp;ns) Dec(res[s],mul(h[nt][s^nt],res[s^nt])); &#125; cout&lt;&lt;res[pw[n]-1]&lt;&lt;'\\n'; &#125; return 0;&#125; 集合选数解题思路： 把题目上的限制拎出来建一个图发现是由若干网格图拼接起来的，且对于每个不被 $2,3$ 整除的数一定作为一个网格图的左上角，每个矩阵行数约为 $\\log_2 n$ ，列数约为 $\\log_3 n$ ，这样把列状压起来转移即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std; //MoBannamespace MoBan&#123;//Typetypedef long long ll;typedef double db;typedef long double ld;typedef unsigned long long Ull;typedef unsigned int uii;typedef const int csi; // Pairtypedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;#define fi first#define se second //Vectortypedef vector&lt;int&gt; vi;typedef vector&lt;pii&gt; vii;typedef vector&lt;pll&gt; vll;typedef vector&lt;pli&gt; vli;typedef vector&lt;pil&gt; vil;#define pb push_back //Maptypedef map&lt;int,int&gt; mii;typedef map&lt;ll,int&gt; mli;typedef map&lt;int,bool&gt; mbi; //Settypedef set&lt;int&gt; si;typedef set&lt;pii&gt; sii;typedef set&lt;pli&gt; sli;typedef set&lt;pil&gt; sil;typedef set&lt;pll&gt; sll;#define ins insert#define del erase const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++) //Inputinline int read()&#123; bool f=1; int ans=0; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125; //Fileinline void file()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif&#125; //Functionstemplate&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;&#125;using namespace MoBan; //Modularnamespace modular&#123; const int mod=1e9+1; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(csi&amp;a)&#123;return ksm(a,mod-2);&#125; inline int fix(csi&amp;a)&#123;return (a%mod+mod)%mod;&#125;&#125;using namespace modular; //My solconst int N=1&lt;&lt;12;int f[2][N],n,cur;bool trans[N];inline int calc(int x)&#123; memset(f,0,sizeof(f)); vector&lt;int&gt;cnt; for(ri i=x,_cnt;i&lt;=n;i&lt;&lt;=1)&#123; _cnt=0; for(ri j=i;j&lt;=n;j*=3)++_cnt; cnt.pb(_cnt); &#125; cur=0; for(ri i=0,up=1&lt;&lt;cnt[0];i&lt;up;++i)f[cur][i]=trans[i]; for(ri i=1;i&lt;cnt.size();++i)&#123; cur^=1; for(ri t=0,_up=1&lt;&lt;cnt[i];t&lt;_up;++t)f[cur][t]=0; for(ri s=0,up=1&lt;&lt;cnt[i-1];s&lt;up;++s)if(f[cur^1][s]) for(ri t=0,_up=1&lt;&lt;cnt[i];t&lt;_up;++t)if(trans[t]&amp;&amp;(!(s&amp;t))) Add(f[cur][t],f[cur^1][s]); &#125; int res=0; for(ri i=0,up=1&lt;&lt;(cnt.back());i&lt;up;++i)Add(res,f[cur][i]); return res;&#125; //Mainint main()&#123; file(); n=read(); for(ri i=0;i&lt;(1&lt;&lt;12);++i)trans[i]=(i&lt;&lt;1)&amp;i?0:1; int res=1; for(ri i=1;i&lt;=n;++i)&#123; if(i==i/2*2||i==i/3*3)continue; Mul(res,calc(i)); &#125; cout&lt;&lt;res; return 0;&#125; 进攻！解题思路： ~~容斥是一眼的~~，考虑一个矩形被计算的次数等于其 $2\\times 2$ 的子矩形数+ $1\\times 1$ 的子矩形数- $1\\times 2$ 的子矩形数- $2\\times 1$ 的子矩形数，那么分别统计每个小矩形被计算的次数。 有一个比较显然的方法是枚举每个空白矩形然后差分，然而也可以直接对于每个点处理出其在差分数组中的值然后直接前缀和，这个用单调栈即可搞定，不会的可以看看[这道题](https://www.luogu.org/problem/P3400) CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(bool*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch^48,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=2005;bool s[N][N];int n,m,K,stk[N],top=0,ht[N][N],a[N][N];int cnt1[N][N],cnt2[N][N],cnt3[N][N],cnt4[N][N],ss[N][N];//cnt3:×óÉÏ½Ç//cnt4:×óÏÂ½Ç//cnt1:ÓÒÏÂ½Ç//cnt2:ÓÒÉÏ½Ç void init(int cnt[][N],bool f1,bool f2)&#123; for(ri i=1;i&lt;=n;++i)&#123; top=0; for(ri j=1;j&lt;=m;++j)&#123; ht[i][j]=s[i][j]?ht[i-1][j]+1:0; while(top&amp;&amp;ht[i][stk[top]]&gt;ht[i][j])--top; cnt[i][j]=cnt[i][stk[top]]+ht[i][j]*(j-stk[top]); stk[++top]=j; &#125; &#125; if(f1)for(ri i=1;i+i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)swap(cnt[i][j],cnt[n-i+1][j]); if(f2)for(ri i=1;i&lt;=n;++i)for(ri j=1;j+j&lt;=m;++j)swap(cnt[i][j],cnt[i][m-j+1]);&#125;inline int solve()&#123; int res=0; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; a[i][j]=add(dec(a[i][j],a[i-1][j-1]),add(a[i-1][j],a[i][j-1])); Add(res,ksm(a[i][j],K)); &#125; return res;&#125;inline void clear()&#123;for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=0;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i)Read(s[i]); init(cnt1,0,0); for(ri i=1;i+i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)swap(s[i][j],s[n-i+1][j]); init(cnt2,1,0); for(ri i=1;i&lt;=n;++i)for(ri j=1;j+j&lt;=m;++j)swap(s[i][j],s[i][m-j+1]); init(cnt3,1,1); for(ri i=1;i+i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)swap(s[i][j],s[n-i+1][j]); init(cnt4,0,1); int res=0; clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; Add(a[i][j],cnt3[i][j]); Dec(a[i+1][j],cnt4[i][j]); Add(a[i+1][j+1],cnt1[i][j]); Dec(a[i][j+1],cnt2[i][j]); &#125; Add(res,solve()); clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; Add(a[i][j],cnt3[i][j]); Dec(a[i+1][j],cnt4[i][j]); Add(a[i+1][j],cnt1[i][j]); Dec(a[i][j],cnt2[i][j]); &#125; Dec(res,solve()); clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; Add(a[i][j],cnt3[i][j]); Dec(a[i][j],cnt4[i][j]); Add(a[i][j+1],cnt1[i][j]); Dec(a[i][j+1],cnt2[i][j]); &#125; Dec(res,solve()); clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; Add(a[i][j],cnt3[i][j]); Dec(a[i][j],cnt4[i][j]); Add(a[i][j],cnt1[i][j]); Dec(a[i][j],cnt2[i][j]); &#125; Add(res,solve()); cout&lt;&lt;res; return 0;&#125; Permuted Matrices解题思路： ~~显然容斥即可~~，考虑只有一行的时候咋做，考虑把整个序列分成 $\\lfloor\\frac{n}{k}\\rfloor$ 段，设 $f_i$ 表示前 $i$ 段带容斥系数的答案，然后枚举最后 $j$ 段可以强制合并成一段转移即可，即 $f_{i}=\\sum\\limits_{j=1}^if_{i-j}C_{ik}^{jk}$ ，加上行的限制就是把后面的组合数给行数次方，然后变个形就能上多项式搞，~~不过模数太那啥于是可以暴力~~ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se second#define pb push_backconst int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)namespace modular&#123; const int mod=1000000123; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=50005;int fac[N],ifac[N],f[N],n,pre[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]); for(ri i=1;i&lt;=n;++i)&#123; fac[i]=ksm(fac[i],n); ifac[i]=ksm(ifac[i],n); &#125;&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;vector&lt;int&gt;a;inline int solve()&#123; f[0]=1; for(ri ss,pre=0,i=1;i&lt;a.size();++i)&#123; pre+=a[i]; f[i]=0; ss=0; for(ri j=i-1;~j;--j)&#123; ss+=a[j+1]; if((i-j)&amp;1)Add(f[i],mul(f[j],C(pre,ss))); else Dec(f[i],mul(f[j],C(pre,ss))); &#125; &#125; return f[a.size()-1];&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=50000; init(); int res=0; for(ri i=1;i&lt;=n;++i)&#123; a.resize(1); for(ri j=n;j;j-=a.back())a.pb(min(i,j)); Add(res,solve()); &#125; cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"CSP-S 2019 泪奔记","slug":"csp2019","date":"2019-11-17T06:40:02.000Z","updated":"2019-11-18T08:50:47.013Z","comments":true,"path":"csp2019/","link":"","permalink":"http://ldxcaicai.github.io/csp2019/","excerpt":"","text":"希望这不是博主发出来的最后一篇blog2333 Day 0上午写完了 $NOIP$ 的最后一部分真题，这里是以往的 $NOIP\\ TG$ 的题解链接 然后中午写完题解和 $Dad$ 一起去了酒店，在滴滴上听歌听到一半播放器就没电了， $sad$ 在酒店颓废了一下午之后跟 $Dad$ 出门吃晚饭结果遇见了 $Jun$ ，发现住的是同一家酒店（惊了$\\times 1$），吃了半碗米线，感觉没有食欲，然后去买面包发现 $jmr$ 也在和他爸买面包（惊了 $\\times 2$），然后去买了碗泡面准备晚上吃，回去之后跟 $Jun$ 谈了一个多小时人生，然后又颓废了一会儿冲个澡就睡了 Day 1起床之后套了个耳机和 $Dad$ 一起去考场，然后发现其余选手貌似都已经进场了，赶快去拿了两瓶农夫山泉然后进了考场，发现没人拦着我写板子于是把板子码完了，然后开题，发现前两道都比较菜感觉阿克稳了，结果 $9:00$ 过了大样例之后发现完全不会 $T3$ ，感觉没救了，一直肝到 $11:00$ 都没有想清楚细节果断准备搞暴力，然后发现暴力只会第一档，自闭了，最后一分钟又加上了一个刚过编译的假贪心交了上去说不定原本的暴力分都没了，想题期间把 $T3$ 题意看错两次 出考场之后突然听说 $T1$ 要 $ULL$ ，自闭了，感觉退役稳了，算了一下 $day1$ 貌似最高才 $205$ 被其余人按在地上暴打 然后下午听说 $romiqi$ 爆炸了感觉有点遗憾，简单聊了几句之后跑去睡觉，起来之后跟 $hjk1030$ 聊天结果得知 $zyj$ 也跟我住一个酒店？？？（惊了 $\\times 3$），然后跑去串门聊了很久的天，之后跟 $Jun$ 两个人一起去电子科大打羽毛球，结果两个铁憨憨不认路找了 $30min$ 才找到场子，打的时候旁边还有一对 $cp$ 在花式虐狗，更6p的是我俩在篮球场里看见一堆人在直播电竞比赛，跟 $Jun$ 在电子科大里走路的时候又聊了好久人生 晚上回酒店发现 $Mom$ 来了（惊了 $\\times 4$ ），吃完晚饭之后听说 $CDQZ$ 在一个一个面谈于是下去面基，发现 $buzhibujue,sjkmost,jmr$ 在下面转圈，看起来都好稳的样子，大概聊了一下最后不知道怎么变成 $mod\\ jerome$_ $wei$ 和 $mod\\ zxyoi$ _$dreamer$ 大会了，然后找到 $yangkai$ 和 $hjk1030$ 聊了一小会儿又回房了，结果回去之后 $yangkai$ 突然问我他 $d1t2$ 的正确性，想了一下发现没啥锅跟他说了几句然后小颓一会儿又睡了 Day 2早上爬起来洗个澡，感觉美滋滋，然后去考场的时候遇到了 $yangkai$ ，然后听说司机差点没调出来 $d1t3$ 。进考场打完板子之后一开题就蒙蔽了，居然没送分题？？？不对 $T2$ 好像是送的，然后想了 $20min$ 无果发现看错题了，然后倒回去看 $T1$ ，想了一会儿发现是个补集转化入门题，过完样例就跑去想 $T2$ ，然后感觉越想越不行，准备先写 $T3$ 暴力然后把 $T2$ 鈤出来，但由于写 $T3$ 暴力的时候我 $dev$ 又死掉了于是心态小崩，（这么说来我目前参加过的大赛 $day2$ 都死机了）结果开 $T2$ 的时候已经 $11:00$ 了，想了 $30min$ 无果之后 $rush$ 了一个 $32pts$ 暴力，发现能优化到 $64pt$ 并且在结束前 $5min$ 的时候调出来了，然后考试结束了 出来之后听说 $romiqi$ 翻车二连， $T2$ 切 $88pts$ 是真的强，没调出来就有点可惜，主要是因为今年两天都没有区分度，只要暴力打好即可。这样对我们这种准备很久的 $oier$ 完全没有优势，不过 $CCF$ 也让很多分数相近的选手看到希望从而赚更多钱。 现在博主慌得一批感觉会 $FST$ 一堆，希望运气好点吧，不过 $WC$ 和 $PKUWC$ 是百分百无望了，如果我去莽个 $d1t3$ 的暴力也就不至于成现在这鬼样子了，唉 UPD:19.11.18: 貌似民间数据测出来没有挂分，大概还能苟延残喘一段时间？希望 $CCF$ 的机子对我的代码友好一点","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://ldxcaicai.github.io/tags/游记/"}]},{"title":"杂题乱做 Round6","slug":"sol6","date":"2019-11-07T08:41:52.000Z","updated":"2019-12-24T23:58:45.456Z","comments":true,"path":"sol6/","link":"","permalink":"http://ldxcaicai.github.io/sol6/","excerpt":"","text":"随机数生成器解题思路： 看了一下网上的解法大概是 $O(nX)$ 的？其实有个 $O(n^2)$ 的在这里讲一下吧 考虑用 $min-max$ 容斥转化为求所有子集询问到的位置的最小值的期望，这样答案只跟所有询问覆盖的长度有关，首先考虑 $n$ 个 $[1,x]$ 间随机整数的期望最小值怎么求，考虑枚举最小值是多少以及有哪些位置是最小值然后进行变形即可，下面推一波式子： $$ \\begin{aligned} E_{min}=&\\frac{\\sum\\limits_{i=1}^xi\\sum\\limits_{j=1}^nC_n^j(x-i)^{n-j}}{x^n}\\\\ =&\\frac{\\sum\\limits_{i=1}^xi((x-i+1)^n-(x-i)^n)}{x^n}\\\\ =&\\frac{\\sum\\limits_{i=1}^xi^n}{x^n} \\end{aligned} $$ 上式利用拉格朗日插值可以 $O(n^2)$ 预处理，但由于该题的 $x$ 范围跟 $n$ 同阶因此代码里直接算的 那么现在只用考虑所有询问的子集对长度个数的贡献，因此考虑如下 $dp$ ： 将所有的询问按左端点单增排序，设 $f_{i,j}$ 表示当前覆盖长度为 $i$ ，之前被选中的询问覆盖到的最远点为 $j$ 的带容斥系数方案数 假设当前询问区间为 $[l,r]$ ，长度为 $len$ ，这样对于所有状态有如下三种转移： 1. $f_{i+len,r}\\leftarrow(-1)f_{i,j","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"杂题乱做 Round5","slug":"sol5","date":"2019-11-05T14:40:45.000Z","updated":"2019-12-24T23:56:46.299Z","comments":true,"path":"sol5/","link":"","permalink":"http://ldxcaicai.github.io/sol5/","excerpt":"","text":"染色解题思路： 对于 $k=2$ 的情况特判一下，然后剩下的点发现用状压 $dp$ 会 $TLE$ ，于是按格子转移，写个 $k$ 进制轮廓线即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;int,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=376544743; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;int n,m,K,a1[N],a2[N],cur=0,pw[15],sta=0;tr1::unordered_map&lt;int,int&gt;f[2],tmp;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),K=read(); for(ri i=1;i&lt;=m;++i)a1[i]=read(); for(ri i=1;i&lt;=m;++i)a2[i]=read(); if(K==2)&#123; for(ri i=1;i&lt;=m;++i)&#123; if(i&gt;1&amp;&amp;(a1[i]==a1[i-1]||a2[i]==a2[i-1]))&#123; puts(\"0\"); return 0; &#125; if(!(a1[i]^a2[i]^(n&amp;1)))&#123; puts(\"0\"); return 0; &#125; &#125; puts(\"1\"); return 0; &#125; pw[0]=1; int ss=0; for(ri i=1;i&lt;=m;++i)pw[i]=pw[i-1]*K,ss+=pw[i]*a1[i]; f[cur=0][ss]=1; for(ri ns,sta,trans,i=2;i&lt;n;++i)&#123; for(ri j=1;j&lt;=m;++j)&#123; cur^=1; f[cur].clear(); for(It it=f[cur^1].begin();it!=f[cur^1].end();++it)&#123; sta=it-&gt;fi,trans=it-&gt;se; for(ri k=0;k&lt;K;++k)&#123; if((j!=1&amp;&amp;(k==sta/pw[j-1]%K))||k==sta/pw[j]%K)continue; ns=sta-(sta/pw[j]%K)*pw[j]-(sta/pw[j-1]%K)*pw[j-1]; ns+=k*pw[j]+k*pw[j-1]; Add(f[cur][ns],trans); &#125; &#125; &#125; tmp.clear(); for(It it=f[cur].begin();it!=f[cur].end();++it)tmp[it-&gt;fi%pw[m]*K]=it-&gt;se; f[cur]=tmp; &#125; int res=0,sta,trans; for(It it=f[cur].begin();it!=f[cur].end();++it)&#123; bool ff=1; sta=it-&gt;fi,trans=it-&gt;se; for(ri i=1;i&lt;=m;++i)if(sta/pw[i]%K==a2[i])&#123; ff=0; break; &#125; if(ff)Add(res,trans); &#125; cout&lt;&lt;res; return 0;&#125; 外星人解题思路： 考虑把所有人从小到大排序，然后一个一个插入现在的序列，这样一个人有贡献当且仅当其在队首，然后转移即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef tr1::unordered_map&lt;int,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=5005;int n,x,a[N],cur;struct F&#123; int x,y; F(int x=0,int y=0):x(x*(y!=0)),y(y)&#123;&#125; friend inline F operator+(F a,F b)&#123;return a.x^b.x?(a.x&gt;b.x?a:b):F(a.x,add(a.y,b.y));&#125; friend inline void operator+=(F&amp;a,F b)&#123;a=a+b;&#125; friend inline F operator*(F a,int b)&#123;return F(a.x,mul(a.y,b));&#125;&#125;f[2][N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),x=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+n+1); cur=0; for(ri i=0;i&lt;=x;++i)f[cur][i]=F(i,1); for(ri i=1;i&lt;=n;++i)&#123; cur^=1; for(ri j=0;j&lt;=x;++j)f[cur][j]=f[cur^1][j]*(i-1); for(ri j=0;j&lt;=x;++j)f[cur][j]+=f[cur^1][j%a[i]]; &#125; cout&lt;&lt;f[cur][x].x&lt;&lt;'\\n'&lt;&lt;f[cur][x].y; return 0;&#125; Lesson Timetable解题思路： 比较简单的组合计数 先不考虑标号，设 $f_{i,j}$ 表示前 $i$ 个位置放了 $j$ 个人的方案数，可以轻松转移，最后再计算标号的贡献即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1005;int f[2][N],n,m,cur=0,fac[N],ifac[N],sum[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=m;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=m;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)sum[i]=sum[i-1]+read(); m=sum[n]; init(); f[cur=0][0]=1; for(ri i=1,x;i&lt;=n;++i)&#123; x=read(); cur^=1; for(ri j=0;j&lt;=sum[i];++j)f[cur][j]=0; for(ri j=0;j&lt;=sum[i-1];++j)if(f[cur^1][j])for(ri k=0,up=min(sum[i]-j,x);k&lt;=up;++k) Add(f[cur][j+k],mul(f[cur^1][j],C(sum[i]-j,k))); &#125; int res=f[cur][m]; for(ri i=1;i&lt;=n;++i)Mul(res,C(sum[n]-sum[i-1],sum[i]-sum[i-1])); cout&lt;&lt;res; return 0;&#125; On the Bench解题思路： 考虑到若有 $a\\times b,a\\times c$ 均为完全平方数的话，那么 $b\\times c$ 也为完全平方数，于是可以把整个数列分成若干不相交组，组内元素相乘必定为完全平方数，不同组两个数相乘必定不为完全平方数 那么现在问题转化成了给你 $m$ 个组，这 $m$ 个组一共有 $n$ 个数，让你将这 $n$ 个数进行排列，使得相邻两个数不属于同一个组，问方案数 随便构造个带容斥系数的额生成函数乘起来即可，跟 [JSOI2019]神经网络 类似 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=305;int n,all=0,fac[N],ifac[N];vector&lt;int&gt;vl[N];poly f,g;inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;inline bool check(int a,int b)&#123; int c=sqrt((ll)a*b); return (ll)c*c==(ll)a*b;&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j) Add(c[i+j],mul(a[i],b[j])); return c;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init(); for(ri x,i=1;i&lt;=n;++i)&#123; x=read(); bool ff=1; for(ri j=1;j&lt;=all;++j)if(check(vl[j].back(),x))&#123; ff=0; vl[j].pb(x); break; &#125; if(ff)vl[++all].pb(x); &#125; f=poly(1,1); int mt=1,res=0; for(ri pre=0,i=1;i&lt;=all;++i)&#123; g.resize(vl[i].size()+1); g[0]=0; for(ri j=1,up=vl[i].size();j&lt;=up;++j)g[j]=(up-j)&amp;1?mod-C(up-1,j-1):C(up-1,j-1); for(ri j=0;j&lt;=vl[i].size();++j)Mul(g[j],ifac[j]); f=f*g; pre+=vl[i].size(); Mul(mt,fac[vl[i].size()]); &#125; for(ri i=0;i&lt;f.size();++i)Add(res,mul(f[i],fac[i])); cout&lt;&lt;mul(mt,res); return 0;&#125; 摘苹果解题思路： 首先考虑一个位置 $v$ 在第一轮被走到的概率，发现是 $\\sum\\limits_{u,[(u,v)\\subset e]}\\frac{du_u}{2m}\\times du_u=\\sum\\limits_{du_v}\\frac1{2m}=\\frac{du_v}{2m}$ 这样推下去那么每一轮走到点 $i$ 的概率都是 $\\frac{du_i}{2m}$ ，成 $sb$ 题了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;vector&lt;int&gt;e[N];int n,K,m,a[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),K=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; int res=0; for(ri i=1,iv=Inv(2*m);i&lt;=n;++i)Add(res,mul(mul(e[i].size(),iv),a[i])); cout&lt;&lt;mul(res,K); return 0;&#125; 假面解题思路： 考虑设 $f_{i,j}$ 表示第 $i$ 个人还剩 $j$ 点血的概率，然后对一个人 $1$ 操作直接 $O(a_i)$ 转移 $f_i$ ， $2$ 操作把需要的点提出来补集转化即可 ~~当然如果你像我一样懒的话也可以写一个暴力前后缀优化艹过去，不过复杂度是错的，当然我尝试加上了ntt优化结果本来能卡过去的TLE了。~~ CODE(暴力非正解优化) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef map&lt;int,int&gt;::iterator It;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=205;int n,q,c,a[N],f[N][N],m,g[N],ps[N],inv[N];inline void init()&#123; inv[1]=1; for(ri i=2;i&lt;=n;++i)inv[i]=mul(inv[mod-mod/i*i],mod-mod/i);&#125;inline int query(int id)&#123; int res=0,ad=0; for(ri i=0;i&lt;=a[id];++i)Add(ad,f[id][i]); assert(ad==1); for(ri i=1;i&lt;=a[id];++i)Add(res,mul(i,f[id][i])); return res;&#125;inline void DP()&#123; static int pre[N][N],suf[N][N],ss[N]; m=read(); for(ri i=1;i&lt;=m;++i)ps[i]=read(); for(ri i=1;i&lt;=m;++i)pre[0][i]=suf[m+1][i]=0; pre[0][0]=suf[m+1][0]=1; for(ri i=1,P1,P2;i&lt;=m;++i)&#123; P1=dec(1,f[ps[i]][0]),P2=f[ps[i]][0]; for(ri j=1;j&lt;=m;++j)pre[i][j]=add(mul(pre[i-1][j-1],P1),mul(pre[i-1][j],P2)); pre[i][0]=mul(pre[i-1][0],P2); &#125; for(ri i=m,P1,P2;i;--i)&#123; P1=dec(1,f[ps[i]][0]),P2=f[ps[i]][0]; for(ri j=1;j&lt;=m;++j)suf[i][j]=add(mul(suf[i+1][j-1],P1),mul(suf[i+1][j],P2)); suf[i][0]=mul(suf[i+1][0],P2); &#125; for(ri res=0,i=1,P;i&lt;=m;++i,res=0)&#123; P=dec(1,f[ps[i]][0]); for(ri j=0;j&lt;m;++j)if(pre[i-1][j])for(ri k=0;j+k&lt;m;++k)if(suf[i+1][k]) Add(ss[j+k],mul(pre[i-1][j],suf[i+1][k])); for(ri j=0;j&lt;m;++j)&#123; Add(res,mul(ss[j],inv[j+1])); ss[j]=0; &#125; cout&lt;&lt;mul(res,P)&lt;&lt;' '; &#125; puts(\"\");&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); f[i][a[i]]=1; &#125; init(); for(ri op,p,vl,tt=read();tt;--tt)&#123; op=read(); if(!op)&#123; p=read(),vl=read(); Mul(vl,Inv(read())); for(ri i=0;i&lt;=a[p];++i)f[p][i]=add(mul(f[p][i],i?dec(1,vl):1),mul(f[p][i+1],vl)); &#125; else DP(); &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;query(i)&lt;&lt;' '; return 0;&#125; 记忆的轮廓解题思路： 水题，考虑预处理一下 $w_{i,j}$ 表示当前 $i,j$ 为特殊点， $i+1\\cdots j-1$ 均不为特殊点时从 $i$ 到 $j$ 的期望步数，然后显然 $w_{i,j}$ 满足四边形不等式，于是随便上一个决策单调性优化即可，不过该题用 $O(n^2)$ 的写法的话最好 $inf$ 设到 $1e300$ 左右，另外两种可以不用 $inf$ 因此就不存在什么问题 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef pair&lt;int,int&gt; pii;typedef long long ll;typedef unsigned long long Ull;typedef unsigned int Uint;typedef double db;typedef long double ld;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef pair&lt;ll,ll&gt; pll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch)&amp;&amp;ch!='?')ch=gc(); while(isdigit(ch)||ch=='?')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b-mod:a+b;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T&amp;b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T&amp;b)&#123;a&gt;b?a=b:0;&#125;const int N=1505,M=705;int n,m,K,cur=0;ld dis[M],f[2][M],w[M][M];vector&lt;int&gt;e[N];void dfs(int p,int dep,int ori,ld coe)&#123; if(!e[p].size())&#123; dis[ori]+=coe*dep; return; &#125; int du=e[p].size()+(ori==p); for(ri i=0;i&lt;e[p].size();++i) dfs(e[p][i],dep+1,ori,coe/(ld)du);&#125;inline ld calc(int x,int p)&#123;return f[cur^1][x]+w[x][p];&#125;inline void solve(int l,int r,int L,int R)&#123; if(L==R)&#123; for(ri i=l;i&lt;=r;++i)f[cur][i]=calc(L,i); return; &#125; int mid=l+r&gt;&gt;1,ps=L; ld tmp=calc(ps,mid),t; for(ri i=ps+1;i&lt;=R&amp;&amp;i&lt;mid;++i)if((t=calc(i,mid))&lt;tmp)&#123; tmp=t; ps=i; &#125; f[cur][mid]=tmp; if(l&lt;mid)solve(l,mid-1,L,ps); if(mid&lt;r)solve(mid+1,r,ps,R);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(),m=read(),K=read(); for(ri i=1;i&lt;=m;++i)e[i].clear(); for(ri i=1;i&lt;=n;++i)dis[i]=0; for(ri i=1,u,v;i&lt;=m-n;++i)&#123; u=read(),v=read(); e[u].pb(v); &#125; for(ri i=1;i&lt;=n;++i)if(e[i].size())dfs(i,1,i,1); ld coe,sum=0; for(ri len,i=1;i&lt;=n;++i)&#123; w[i][i]=0; coe=1.0/((ld)e[i].size()+1); len=1,sum=dis[i]; for(ri j=i+1;j&lt;=n;++j)&#123; w[i][j]=len+sum/coe; sum+=coe*dis[j]; sum+=coe*(1.0-1.0/((ld)e[j].size()+1))*len; ++len; coe*=1.0/((ld)e[j].size()+1); &#125; &#125; cur=0; for(ri i=2;i&lt;=n;++i)f[cur][i]=w[1][i]; for(ri i=3;i&lt;=K;++i)cur^=1,solve(i,n,i-1,n); printf(\"%.4Lf\\n\",f[cur][n]); &#125; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"杂题乱做 Round4","slug":"sol4","date":"2019-11-03T14:46:34.000Z","updated":"2019-12-24T23:55:37.820Z","comments":true,"path":"sol4/","link":"","permalink":"http://ldxcaicai.github.io/sol4/","excerpt":"","text":"交与并解题思路： 容易探究出如下性质： 所有合法集合可以由集合中的两个区间代替 那么对于每个区间找一个跟它交并长度乘积最大的区间即可 发现有两种相交和包含，那么先考虑如何处理包含的情况 考虑先左端点递增后右端点递减的顺序进行排序，维护当前最右端点来判断是否包含，并跟当前最右端点对应区间求贡献，但这样不一定能求出所有包含当前区间中最长的那个，这个时候考虑如下一点性质： 假设存在 $A\\subset B,A\\subset C$ ，那么 $B,C$ 产生的贡献优于 $A,B$ 和 $A,C$ 产生的贡献 这样就可以放心搞掉所有被包含的区间了，剩下的区间两两不包含且左右端点均递增，于是区间 $i,j$ 的贡献为 $(r_i-l_j+1)\\times(r_j-l_i+1)$ 拆开看发现有决策单调性，直接分治搞搞即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;inline bool cmp(pii a,pii b)&#123;return a.fi^b.fi?a.fi&lt;b.fi:a.se&gt;b.se;&#125;const int N=1e6+5;pii a[N];int n,sig=0;ll ans=0;inline ll calc(int x,int p)&#123;return (ll)(a[p].se-a[x].fi)*(a[x].se-a[p].fi);&#125;inline void solve(int l,int r,int L,int R)&#123; if(l&gt;r)return; if(L==R)&#123; for(ri i=l;i&lt;=r;++i)if(i&gt;L)ckmax(ans,calc(L,i)); return; &#125; int mid=l+r&gt;&gt;1,ps=L; ll tmp=calc(ps,mid),t; for(ri i=ps+1;i&lt;=R&amp;&amp;i&lt;mid;++i)if((t=calc(i,mid))&gt;tmp)&#123; tmp=t; ps=i; &#125; if(ps&lt;mid)ckmax(ans,tmp); solve(l,mid-1,L,ps); solve(mid+1,r,ps,R); &#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i].fi=read(),a[i].se=read(); sort(a+1,a+n+1,cmp); sig=1; for(ri ps=1,mx=a[1].se,i=2;i&lt;=n;++i)&#123; if(a[i].se&gt;mx)&#123; mx=a[i].se; ps=i; a[++sig]=a[i]; &#125; else ckmax(ans,(ll)(a[i].se-a[i].fi)*(a[ps].se-a[ps].fi)); &#125; solve(1,sig,1,sig); cout&lt;&lt;ans; return 0;&#125; 地图解题思路： 首先考虑一个贪心，将所有数进行排序然后分成不超过 $m$ 块一定是最优的，证明显然 然后就可以 $f_{i,j}$ 表示前 $i$ 个数分为 $j$ 块的最优贡献，预处理所有区间的贡献即可，复杂度 $O(n^2m)$ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=3005,M=22;const ll inf=1e18;ll f[N][M],w[N][N],s[N];int n,m,a[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+n+1); for(ri i=1;i&lt;=n;++i)s[i]=a[i]+s[i-1]; for(ri mid,len=2;len&lt;=n;++len)for(ri l=1,r=len;r&lt;=n;++l,++r)&#123; mid=l+r&gt;&gt;1; w[l][r]=(ll)a[mid]*(mid-l)-(s[mid-1]-s[l-1])+(s[r]-s[mid])-(ll)a[mid]*(r-mid); &#125; for(ri i=0;i&lt;=n;++i)for(ri j=0;j&lt;=m;++j)f[i][j]=inf; f[0][0]=0; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=min(m,i);++j)for(ri k=1;k&lt;=i;++k) if(f[k-1][j-1]!=inf)ckmin(f[i][j],f[k-1][j-1]+w[k][i]); cout&lt;&lt;f[n][m]; return 0;&#125; 魔兽地图DotR解题思路： 设 $f_{i,j,k}$ 表示 $i$ 为根的子树花费至多 $j$ 元，最后拼出来了 $k$ 个 $i$ 的最大贡献，然后由于是森林因此要分组转移，转移的时候利用提前计算贡献的思想加上后缀和优化就好 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int inf=1e9;int g[2005],f[55][2005][105],suf[55][2005][105],cur=0,du[55],a[55],b[55],vl[55],n,m;vector&lt;pii&gt;e[55];void dfs(int p)&#123; if(!e[p].size())&#123; ckmin(b[p],m/a[p]); for(ri i=b[p];~i;--i)&#123; f[p][a[p]*i][i]=vl[p]*i; for(ri j=1;j&lt;=m;++j)&#123; ckmax(f[p][j][i],f[p][j-1][i]); suf[p][j][i]=max(f[p][j][i],suf[p][j][i+1]); &#125; &#125; return; &#125; b[p]=inf,a[p]=0; for(ri v,w,i=0;i&lt;e[p].size();++i)&#123; v=e[p][i].fi,w=e[p][i].se; dfs(v); a[p]+=a[v]*w; ckmin(b[p],b[v]/w); &#125; ckmin(b[p],m/a[p]); for(ri i=b[p];~i;--i)&#123; f[p][i*a[p]][i]=i*vl[p]; for(ri j=0,v,w,sw,svl;j&lt;e[p].size();++j)&#123; v=e[p][j].fi,w=e[p][j].se,sw=w*i*a[v],svl=w*i*vl[v]; for(ri k=m;k&gt;=i*a[p];--k)for(ri l=0,up=m-max(k,sw);l&lt;=up;++l) ckmax(f[p][k+l][i],f[p][k][i]+suf[v][sw+l][w*i]-svl); &#125; for(ri j=1;j&lt;=m;++j)&#123; ckmax(f[p][j][i],f[p][j-1][i]); suf[p][j][i]=max(f[p][j][i],suf[p][j][i+1]); &#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); char ch; for(ri i=1;i&lt;=n;++i)&#123; vl[i]=read(); ch=gc(); while(!isalpha(ch))ch=gc(); if(ch=='B')a[i]=read(),b[i]=read(); else&#123; for(ri tt=read(),v,w;tt;--tt)&#123; v=read(),w=read(); e[i].pb(pii(v,w)); ++du[v]; &#125; &#125; &#125; memset(f,-0x3f,sizeof(f)); memset(suf,-0x3f,sizeof(suf)); for(ri i=1;i&lt;=n;++i)&#123; if(du[i])continue; dfs(i); for(ri j=m;j;--j)for(ri k=0;k&lt;=j;++k)ckmax(g[j],g[j-k]+suf[i][k][0]); &#125; cout&lt;&lt;g[m]; return 0;&#125; 小 Y 和二叉树解题思路： 显然要选一个 $du\\le2$ 的最小编号作为根，剩下的用 $dfs$ 处理出子树中 $du\\le2$ 的最小编号来贪心构造即可 ~~实际上就是分类讨论一波~~ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e6+5,inf=0x3f3f3f3f;vector&lt;int&gt;e[N];int n,du[N],rt,mn[N];void dfs(int p,int ft)&#123; if(du[p]&lt;=2)mn[p]=p; else mn[p]=inf; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; dfs(v,p),ckmin(mn[p],mn[v]); &#125;&#125;inline int get1(int x,int ft)&#123; int res=0x3f3f3f3f; for(ri i=0,v;i&lt;e[x].size();++i)&#123; if((v=e[x][i])==ft)continue; ckmin(res,mn[e[x][i]]); &#125; return res;&#125;inline int get2(int x,int ft)&#123; int res=0x3f3f3f3f,siz=du[x]-(ft!=0); if(!siz)return x; if(siz==1)return min(x,get1(x,ft)); return get1(x,ft);&#125;void print(int p,int ft,bool f)&#123; vector&lt;int&gt;tmp; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; tmp.pb(v); &#125; if(!tmp.size())cout&lt;&lt;p&lt;&lt;' '; else if(tmp.size()==1)&#123; if(f)&#123; cout&lt;&lt;p&lt;&lt;' '; if(get1(tmp[0],p)&lt;tmp[0])print(tmp[0],p,0); else print(tmp[0],p,1); &#125; else&#123; if(p&lt;mn[tmp[0]])&#123; cout&lt;&lt;p&lt;&lt;' '; print(tmp[0],p,0); &#125; else&#123; print(tmp[0],p,0); cout&lt;&lt;p&lt;&lt;' '; &#125; &#125; &#125; else&#123; if(f)&#123; if(get2(tmp[0],p)&gt;get2(tmp[1],p))swap(tmp[0],tmp[1]); cout&lt;&lt;p&lt;&lt;' '; print(tmp[0],p,0); print(tmp[1],p,1); &#125; else&#123; if(mn[tmp[0]]&gt;mn[tmp[1]])swap(tmp[0],tmp[1]); print(tmp[0],p,0); cout&lt;&lt;p&lt;&lt;' '; print(tmp[1],p,0); &#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; du[i]=read(); for(ri j=1;j&lt;=du[i];++j)e[i].pb(read()); &#125; rt=n+1; for(ri i=1;i&lt;=n;++i)if(du[i]&lt;3)ckmin(rt,i); dfs(rt,0); print(rt,0,1); return 0;&#125; Anthem of Berland解题思路： 有一个很显然的暴力思路 $f_{i,j}$ 表示走到 $s$ 前 $i$ 为匹配到 $t$ 的第 $j$ 位的最优值，然后暴力转移（貌似还能过） 现在考虑一个不那么暴力的思路，设 $f_i$ 表示前 $i$ 位的最优值，首先考虑 $s[i-m+1\\cdots i]$ 是否能与 $t$ 匹配，如果可以就能从其 $border$ ， $border$ 的 $border$ 等位置转移过来，因此我们再记录一个 $g_i$ 表示以 $i$ 结尾的位置跟 $t$ 匹配上的最优值，然后就能转移啦 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;char s[N],t[N];int n,m,f[N],g[N],nxt[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif scanf(\"%s%s\",s+1,t+1); n=strlen(s+1),m=strlen(t+1); for(ri i=1,j=0;i&lt;m;++i)&#123; while(j&amp;&amp;t[i+1]!=t[j+1])j=nxt[j]; nxt[i+1]=t[i+1]==t[j+1]?++j:0; &#125; for(ri p,i=m;i&lt;=n;++i)&#123; bool ff=1; for(ri j=i-m+1,k=1;j&lt;=i;++j,++k)if(s[j]!='?'&amp;&amp;s[j]!=t[k])&#123; ff=0; break; &#125; if(ff)&#123; ckmax(g[i],f[i-m]+1); p=nxt[m]; while(p)&#123; ckmax(g[i],g[i-m+p]+1); p=nxt[p]; &#125; &#125; f[i]=max(f[i-1],g[i]); &#125; cout&lt;&lt;f[n]; return 0;&#125; 火鼠的皮衣 -不焦躁的内心-解题思路： 推式子题： $$ \\begin{aligned} =&\\sum\\limits_{i=0}^{\\lfloor\\frac{n}2\\rfloor}(\\sqrt a)^{2i}b^{n-2i}C_{n}^{2i}\\\\ =&\\sum\\limits_{i=0}^n(\\sqrt a)^ib^{n-i}C_{n}^i[2|i] \\end{aligned} $$ 单位根反演一下成 $sb$ 题了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (a*b-(ll)((long double)a/mod*b)*mod+mod)%mod;&#125;&#125;using namespace modular;ll n,A,B;struct F&#123; ll x,y; F(ll x=0,ll y=0):x(x),y(y)&#123;&#125; friend inline F operator*(F &amp;a,F &amp;b)&#123;return F(add(mul(a.x,b.y),mul(a.y,b.x)),add(mul(a.y,b.y),mul(mul(a.x,b.x),A)));&#125; friend inline F operator+(F &amp;a,F &amp;b)&#123;return F(add(a.x,b.x),add(a.y,b.y));&#125;&#125;;inline F ksm(F x,ll b)&#123; F res=F(0,1); for(;b;b&gt;&gt;=1,x=x*x)if(b&amp;1)&#123; res=res*x; &#125; return res;&#125;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=readl(),A=readl(),B=readl(),mod=readl(); F a=F(1,B%mod); a=ksm(a,n); cout&lt;&lt;a.y&lt;&lt;'\\n'; &#125; return 0;&#125; Ternary String Counting解题思路： 设 $f_{i,j,k}$ 表示填了前 $i$ 位，最近不同颜色出现位置为 $j,k$ 的方案数 $(i>j>k)$ ，然后能得到如下转移： 1. $f_{i,j,k}\\rightarrow f_{i+1,i,k}$ 2. $f_{i,j,k}\\rightarrow f_{i+1,j,k}$ 3. $f_{i,j,k}\\rightarrow f_{i+1,i,j}$ 然后把每个 $i$ 对应的 $f$ 矩阵拎出来看发现等价于是每次给你画一个矩形，把外面的值变为 $0$ ，然后将一列/一行的和加给一个格子，并且一个位置被清零后之后那个地方不会再被修改，且对于每一行来说有值的是连续区间，于是对每一行维护有值的左右端点，行和，列和即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;template&lt;class T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;class T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=5005;int n,m;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(),m=read(); vector&lt;int&gt;mn1(n+2),mx1(n+2),mn2(n+2),mx2(n+2),row(n+2),col(n+2),lp(n+2),rp(n+2); vector&lt;vector&lt;int&gt; &gt;f(n+2); for(ri i=0;i&lt;=n+1;++i)&#123; mx1[i]=mx2[i]=i-1; f[i].resize(n+2); &#125; for(ri l,r,v,i=1;i&lt;=m;++i)&#123; l=read(),r=read(),v=read(); if(v==1)&#123; ckmin(mx1[r],l-1); ckmin(mx2[r],l-1); &#125; else if(v==2)&#123; ckmax(mn1[r],l); ckmin(mx2[r],l-1); &#125; else&#123; ckmax(mn1[r],l); ckmax(mn2[r],l); &#125; &#125; bool ff=1; for(ri i=1;i&lt;=n;++i)if(mn1[i]&gt;mx1[i]||mn2[i]&gt;mx2[i])&#123; ff=0; break; &#125; if(!ff)&#123; puts(\"0\"); continue; &#125; row[0]=col[0]=f[0][0]=3,lp[0]=rp[0]=0; for(ri cur=2;cur&lt;=n;++cur)&#123; if(mx1[cur]+1==cur)&#123; for(ri i=mn2[cur];i&lt;=mx2[cur];++i) Add(f[cur-1][i],add(row[i],col[i])); for(ri i=mn2[cur];i&lt;=mx2[cur];++i) Add(col[i],f[cur-1][i]),Add(row[cur-1],f[cur-1][i]); lp[cur-1]=mn2[cur],rp[cur-1]=mx2[cur]; &#125; else lp[cur-1]=1,rp[cur-1]=0; for(ri i=0;i&lt;mn1[cur];++i)&#123; if(lp[i]&gt;rp[i])continue; for(ri j=lp[i];j&lt;=rp[i];++j)Dec(col[j],f[i][j]); row[i]=0; lp[i]=1,rp[i]=0; &#125; for(ri i=mn1[cur];i&lt;=mx1[cur];++i)&#123; if(lp[i]&lt;=rp[i])&#123; if(lp[i]&gt;mx2[cur]||rp[i]&lt;mn2[cur])&#123; for(ri j=lp[i];j&lt;=rp[i];++j)Dec(col[j],f[i][j]); row[i]=0; lp[i]=1,rp[i]=0; &#125; else&#123; for(ri j=lp[i];j&lt;mn2[cur];++j) Dec(col[j],f[i][j]),Dec(row[i],f[i][j]); ckmax(lp[i],mn2[cur]); for(ri j=rp[i];j&gt;mx2[cur];--j) Dec(col[j],f[i][j]),Dec(row[i],f[i][j]); ckmin(rp[i],mx2[cur]); &#125; &#125; &#125; for(ri i=mx1[cur]+1;i&lt;cur-1;++i)&#123; if(lp[i]&gt;rp[i])continue; for(ri j=lp[i];j&lt;=rp[i];++j)Dec(col[j],f[i][j]); row[i]=0; lp[i]=1,rp[i]=0; &#125; &#125; int res=0; for(ri i=0;i&lt;n;++i)Add(res,row[i]); cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"杂题乱做 Round3","slug":"sol3","date":"2019-11-01T14:39:01.000Z","updated":"2019-12-24T23:54:27.104Z","comments":true,"path":"sol3/","link":"","permalink":"http://ldxcaicai.github.io/sol3/","excerpt":"","text":"建设游乐场解题思路： 在 $m$ 很小的时候可以考虑用轮廓线做，但现在 $m$ 较大，因此要对该题的特殊条件进行分析： 考虑到最后会形成若干回路，因此若将整张图进行黑白染色，那么一个白格一定连接两个黑格，由于弯道的权值为 $vl_{i,j}$ ，直道的权值为 $0$ ，因此可以将每个格子按照横纵方向建两个点并进行如下连边： 1. 源点向每个白格对应点连边，费用 $0$ ，流量 $2$ 2. 每个黑格对应点向汇点连边，费用 $0$ ，流量 $2$ 3. 每个格子的横/纵向对应点向格子对应点连两条边，一条费用 $0$ ，流量 $1$ ，一条费用 $vl_{i,j}$ ，流量 $1$ 4. 相邻的合法格子在对应方向连边 然后跑最大费用流即可，若是弯道会被计算 $2vl_{i,j}$ 的费用，直道会被计算 $vl_{i,j}$ 的费用，因此最后减去所有合法格子的权值即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int inf=0x3f3f3f3f,N=155,M=35,L=N*M*3;int n,m,vl[N][M],ct=0;struct edge&#123;int v,next,c,w;&#125;;namespace mcmf&#123; int d[L],cnt,first[L],s,t,id[L],res,fl; bool in[L]; edge e[L&lt;&lt;4]; inline void init()&#123; s=0; t=n*m*3+1; cnt=-1; for(ri i=s;i&lt;=t;++i)first[i]=-1; res=0; fl=0; &#125; inline void addedge(int u,int v,int c,int w)&#123; e[++cnt]=(edge)&#123;v,first[u],c,w&#125;; first[u]=cnt; &#125; inline void add_(int u,int v,int c,int w)&#123; addedge(u,v,c,w); addedge(v,u,0,-w); &#125; inline bool spfa()&#123; static int que[L&lt;&lt;4],hd,tl; for(ri i=s;i&lt;=t;++i)d[i]=-inf; que[hd=tl=1]=s; d[s]=0; while(hd&lt;=tl)&#123; int x=que[hd++]; in[x]=0; for(ri i=first[x],v;~i;i=e[i].next)&#123; v=e[i].v; if(e[i].c&gt;0&amp;&amp;d[v]&lt;d[x]+e[i].w)&#123; d[v]=d[x]+e[i].w; id[v]=i; if(!in[v])&#123; in[v]=1; que[++tl]=v; &#125; &#125; &#125; &#125; if(d[t]==-inf)return 0; res+=d[t]; ++fl; int p=t; while(p!=s)--e[id[p]].c,++e[id[p]^1].c,p=e[id[p]^1].v; return 1; &#125; inline int solve()&#123; while(spfa()); if(fl!=ct)puts(\"-1\"),exit(0); return res; &#125;&#125;bool s[N][M];inline int idx(int a,int b,int c)&#123;return c*n*m+(a-1)*m+b;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)s[i][j]=read(); int res=0; mcmf::init(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; vl[i][j]=read(); if(!s[i][j])res-=vl[i][j],++ct; &#125; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; if(s[i][j])continue; if((i+j)&amp;1)&#123; mcmf::add_(mcmf::s,idx(i,j,2),2,0); mcmf::add_(idx(i,j,2),idx(i,j,0),1,0); mcmf::add_(idx(i,j,2),idx(i,j,0),1,vl[i][j]); mcmf::add_(idx(i,j,2),idx(i,j,1),1,0); mcmf::add_(idx(i,j,2),idx(i,j,1),1,vl[i][j]); if(i!=1&amp;&amp;!s[i-1][j])mcmf::add_(idx(i,j,0),idx(i-1,j,0),1,0); if(i!=n&amp;&amp;!s[i+1][j])mcmf::add_(idx(i,j,0),idx(i+1,j,0),1,0); if(j!=1&amp;&amp;!s[i][j-1])mcmf::add_(idx(i,j,1),idx(i,j-1,1),1,0); if(j!=m&amp;&amp;!s[i][j+1])mcmf::add_(idx(i,j,1),idx(i,j+1,1),1,0); &#125; else&#123; mcmf::add_(idx(i,j,2),mcmf::t,2,0); mcmf::add_(idx(i,j,0),idx(i,j,2),1,0); mcmf::add_(idx(i,j,0),idx(i,j,2),1,vl[i][j]); mcmf::add_(idx(i,j,1),idx(i,j,2),1,0); mcmf::add_(idx(i,j,1),idx(i,j,2),1,vl[i][j]); &#125; &#125; res+=mcmf::solve(); cout&lt;&lt;res; return 0;&#125; Druzyny解题思路： 考虑设 $f_{i}=(a,b)$ 表示当前序列段开头为 $i$ ，之前最多有 $a$ 段序列，方案数为 $b$ 很明显可以考虑枚举该段的结尾位置然后进行转移，复杂度为 $O(n^2)$ 转移式条件如下： $若i能向j转移，则\\max\\{c_{i\\cdots j}\\}\\le j-i+1\\le\\min\\{d_{i\\cdots j}\\}$ 观察转移条件容易发现合法的转移区间被分成了若干连续段，而如果只有一个限制条件我们可以通过预处理每个数延伸的最远位置来进行 $dp$ 优化，因此现在问题变为用巧妙的方法去掉其中一个限制条件 那么利用最值分治的思想即可，每一层分别先更新出最值左边的答案，然后用其更新右侧答案，然后递归分治右边即可 在更新的时候通过手画可以发现要么是区间中间的一段，要么是区间的一个前缀，对于后者直接记录前缀和转移即可，每层复杂度 $O(1)$ ，总复杂度为 $O(n\\log n)$ ，而对于前者在所有层中只会出现 $O(n)$ 次，每次用线段树查询区间和，复杂度 $O(n\\log n)$ 但由于笔者的实现不够好成功被卡了空间，于是线段树变成了 $N\\times 3$ 的上限 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;#define ri int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=1e6+5;struct F&#123; int a,b; F(int a=-1000000,int b=0):a(a),b(b)&#123;&#125; friend inline F operator+(F a,F b)&#123;return a.a^b.a?(a.a&gt;b.a?a:b):F(a.a,add(a.b,b.b));&#125; friend inline void operator+=(F&amp;a,F b)&#123;a=a+b;&#125;&#125;f[N];namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) F vl[N*3],tg[N*3]; void pushnow(int p,F v)&#123; vl[p]+=v; tg[p]+=v; &#125; void pushdown(int p)&#123; if(tg[p].a||tg[p].b)&#123; pushnow(lc,tg[p]); pushnow(rc,tg[p]); tg[p]=F(0,0); &#125; &#125; void pushup(int p)&#123;vl[p]=vl[lc]+vl[rc];&#125; void update(int p,int l,int r,int ql,int qr,F v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return pushnow(p,v); pushdown(p); if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); pushup(p); &#125; F query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; pushdown(p); if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); &#125;&#125;int n,mn[N],mx[N],ps[N];namespace sgtt&#123; int vl[N*3]; void pushup(int p)&#123;vl[p]=mn[vl[lc]]&gt;mn[vl[rc]]?vl[lc]:vl[rc];&#125; void build(int p,int l,int r)&#123; if(l==r)&#123; vl[p]=l; return; &#125; build(lc,l,mid),build(rc,mid+1,r); pushup(p); &#125; int query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); int res1=query(lc,l,mid,ql,qr),res2=query(rc,mid+1,r,ql,qr); return mn[res1]&gt;mn[res2]?res1:res2; &#125; int query(int l,int r)&#123;return query(1,1,n,l,r);&#125; #undef lc #undef rc #undef mid&#125;F pre,upd;void solve(int l,int r)&#123; if(l&gt;r)return; if(l==r)&#123; sgt::update(1,1,n,l,l,f[l]); f[l]=sgt::query(1,1,n,l,l); return; &#125; int mid=sgtt::query(l,r-1); solve(l,mid); int pos=max(mid,l+mn[mid]-1); if(pos-mn[mid]+1&gt;l)&#123; upd=sgt::query(1,1,n,l,pos-mn[mid]); pre=F(upd.a+1,upd.b); &#125; else pre=F(); for(ri L,R,res,ql=l,qr=pos-mn[mid]+1,i=pos;i&lt;r;++i,++qr)&#123; if(ps[i]&gt;mid)break; if(qr&gt;=l)&#123; pre+=F(f[qr].a+1,f[qr].b); if(qr==mid)&#123; L=i,R=r-1,res=i-1; while(L&lt;=R)&#123; int md=L+R&gt;&gt;1; if(ps[md]&lt;=l)L=md+1,res=md; else R=md-1; &#125; if(i&lt;=res)sgt::update(1,1,n,i+1,res+1,pre); for(i=res+1;i&lt;r;++i)&#123; if(ps[i]&gt;mid)break; upd=sgt::query(1,1,n,ps[i],qr); f[i+1]+=F(upd.a+1,upd.b); &#125; break; &#125; if(ps[i]&gt;l)&#123; if(ps[i]&lt;=qr)&#123; upd=sgt::query(1,1,n,ps[i],qr); f[i+1]+=F(upd.a+1,upd.b); &#125; continue; &#125; f[i+1]+=pre; &#125; &#125; solve(mid+1,r);&#125;struct Que&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;a,b; inline void ins(int x)&#123;a.push(x);&#125; inline void del(int x)&#123;b.push(x);&#125; inline int top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125;&#125;vl;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)mn[i]=read(),mx[i]=read(); ++n; mn[n]=mx[n]=1; f[1]=F(0,1); sgtt::build(1,1,n); for(ri l=1,r=1;r&lt;=n;++r)&#123; vl.ins(mx[r]); while(vl.top()&lt;r-l+1)vl.del(mx[l++]); ps[r]=l; &#125; while(vl.a.size())vl.a.pop(); while(vl.b.size())vl.b.pop(); solve(1,n); F res=f[n]; if(!res.b)puts(\"NIE\"); else cout&lt;&lt;res.a&lt;&lt;' '&lt;&lt;res.b; return 0;&#125; MachineWorks解题思路： 考虑把所有机器按照 $d_i$ 排序，然后设 $f_i$ 表示到第 $i$ 个物品手中能有的最多的钱 那么转移式为 $f_i=\\max\\{f_j+(d_i-d_j-1)\\times g_j+r_j\\}$ 貌似可以斜率优化，然后发现 $g_j$ 不是单增的，于是利用 $cdq$ 分治来维护这个偏序即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;int n,C,D,cas=0;const ll inf=1e13;struct F&#123; int d,p,r,g; friend inline bool operator&lt;(F a,F b)&#123;return a.d&lt;b.d;&#125;&#125;a[N];pil b[N],c[N];ll f[N];int q[N],hd,tl,t1,t2;inline double slope(pil a,pil b)&#123;return a.fi==b.fi?inf:(double)(a.se-b.se)/(double)(a.fi-b.fi);&#125;inline void solve(int l,int r)&#123; if(l==r)&#123; f[l]-=a[l].p; if(f[l]&lt;0)f[l]=-inf; return; &#125; int mid=l+r&gt;&gt;1; solve(l,mid); t1=0,t2=0; for(ri i=l;i&lt;=mid;++i)if(f[i]!=-inf)b[++t1]=pil(a[i].g,f[i]+a[i].r-(ll)(a[i].d+1)*a[i].g); for(ri i=mid+1;i&lt;=r;++i)c[++t2]=pil(a[i].d,i); sort(b+1,b+t1+1); sort(c+1,c+t2+1); hd=1,tl=0; for(ri i=1;i&lt;=t1;++i)&#123; while(tl-hd&gt;=1&amp;&amp;slope(b[i],b[q[tl]])&gt;slope(b[q[tl]],b[q[tl-1]]))--tl; q[++tl]=i; &#125; if(hd&lt;=tl)for(ri i=1;i&lt;=t2;++i)&#123; while(tl-hd&gt;=1&amp;&amp;slope(b[q[hd]],b[q[hd+1]])&gt;-c[i].fi)++hd; ckmax(f[c[i].se],b[q[hd]].se+(ll)b[q[hd]].fi*c[i].fi); &#125; solve(mid+1,r);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif while(1)&#123; n=read(),C=read(),D=read(); if(!(n+C+D))break; ++cas; cout&lt;&lt;\"Case \"&lt;&lt;cas&lt;&lt;\": \"; for(ri i=1;i&lt;=n;++i)&#123; a[i].d=read(),a[i].p=read(),a[i].r=read(),a[i].g=read(); f[i+1]=-inf; &#125; a[++n]=(F)&#123;0,0,0,0&#125;; a[++n]=(F)&#123;D+1,0,0,0&#125;; sort(a+1,a+n+1); f[1]=C; f[n]=-inf; solve(1,n); cout&lt;&lt;f[n]&lt;&lt;'\\n'; &#125; return 0;&#125; 珠宝解题思路： 首先考虑按照代价进行分组，然后设 $f_{i,j}$ 表示前 $i$ 个组代价为 $j$ 的最优美观度 这样就有了 $O(300K^2)$ 的暴力搞法（不如 $O(nK)$ 暴力分多 然后每个组满足决策单调性（这个非常易证），于是可以对每个组按照模数分类然后决策单调性优化转移 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int M=50005,K=305;int n,m,cur,blo;ll f[2][M];vector&lt;ll&gt;vl[K];vector&lt;int&gt;ps;inline ll calc(int x,int p)&#123;return f[cur^1][ps[x]]+(x==p?0:vl[blo][p-x-1]);&#125;inline void solve(int l,int r,int L,int R)&#123; if(l&gt;r)return; if(L==R)&#123; for(ri i=l;i&lt;=r;++i)f[cur][ps[i]]=calc(L,i); return; &#125; int mid=l+r&gt;&gt;1,x=max(L,mid-(int)vl[blo].size()); ll tmp=calc(x,mid),t; for(ri i=x+1;i&lt;=R&amp;&amp;i&lt;=mid;++i)if((t=calc(i,mid))&gt;tmp)&#123; x=i; tmp=t; &#125; f[cur][ps[mid]]=tmp; solve(l,mid-1,L,x); solve(mid+1,r,x,R);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri a,b,i=1;i&lt;=n;++i)&#123; a=read(),b=read(); vl[a].pb(b); &#125; cur=0; for(ri i=1;i&lt;=300;++i)&#123; if(!vl[i].size())continue; blo=i; sort(vl[i].begin(),vl[i].end()); reverse(vl[i].begin(),vl[i].end()); for(ri j=1;j&lt;vl[i].size();++j)vl[i][j]+=vl[i][j-1]; cur^=1; for(ri j=0;j&lt;i;++j)&#123; ps.clear(); for(ri k=j;k&lt;=m;k+=i)ps.pb(k); if(ps.size())solve(0,ps.size()-1,0,ps.size()-1); &#125; &#125; for(ri i=1;i&lt;=m;++i)cout&lt;&lt;f[cur][i]&lt;&lt;' '; return 0;&#125; Ember and Storm’s Tree Game解题思路： 考虑到合法的树满足每条路径一定是单调或者单峰的，且每条路径有 $2$ 种调整方法，于是只用求出可行树的方案数，考虑设 $f_{i,j}$ 表示整颗子树满足儿子小于父亲，子树 $siz=i$ ，根的度数为 $j$ 的方案数 然后用个前缀和优化能够非常简单的转移出来 现在在整棵树的根处可以将满足儿子小于父亲和儿子大于父亲的树给拼接起来，统计方案数即可 **注意到同一棵树的可行根由若干个，但它们形成了一条单调路径，我们在端点统计即可** CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define pb push_back#define fi first#define se second#define double long doubleusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=205;int C[N][N],n,K,f[N][N],s[N];inline void init()&#123; for(ri i=0;i&lt;=n;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j-1],C[i-1][j]); &#125;&#125;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(),mod=read(); init(); s[1]=f[1][0]=1; for(ri i=2;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=K;++j)&#123; for(ri k=1;k&lt;i;++k)Add(f[i][j],mul(mul(f[i-k][j-1],s[k]),C[i-2][k-1])); if(j&lt;K)Add(s[i],f[i][j]); &#125; &#125; int res=0; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;=K;++j)for(ri k=0;j+k&lt;=K;k?++k:k+=2)Add(res,mul(f[i][j],f[n-i+1][k])); cout&lt;&lt;mul(mul(res,2),mul(n,n-1)); return 0;&#125; Path Counting解题思路： 笔者想出了一个暴力做法，即考虑利用 $lca$ 枚举路径，然后用 $mtt$ 优化做到 $O(n^2\\log n)$ 下面是正经做法： 考虑对于每条路径从端点处求方案数，设 $f_{i,j}$ 表示从深度 $i$ 的某个点开始向下走 $j$ 步的方案数， $g_{i,j}$ 表示从某个深度为 $i$ 的点开始至少向上走一步总共走 $j$ 步的方案数 显然有： $f_{i,j}=f_{i+1,j-1}\\times a_i+1,g_{i,j}=g_{i-1,j-1}+f_{i,j-2}\\times (a_{i-1}-1)$ 直接开两个数组会 $MLE$ ，因此先求 $f$ 再求 $g$ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef pair&lt;int,ll&gt; pil;typedef unsigned long long Ull;typedef unsigned int uii;typedef set&lt;int&gt;::iterator It;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;const int N=5005;int n,a[N],b[N],f[N][N&lt;&lt;1],cur=0,ans[N&lt;&lt;1];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); b[1]=1; for(ri i=1;i&lt;n;++i)a[i]=read(),b[i+1]=mul(b[i],a[i]); f[n][0]=1; for(ri i=n-1;i;--i)&#123; f[i][0]=1; for(ri j=0,up=n-i;j&lt;up;++j)&#123; f[i][j+1]=mul(f[i+1][j],a[i]); Add(ans[j+1],mul(f[i][j+1],b[i])); &#125; &#125; for(ri i=1;i&lt;=n;++i)&#123; for(ri j=n+i-2;j;--j)&#123; f[i][j]=f[i-1][j-1]; if(j&gt;1&amp;&amp;i!=1)Add(f[i][j],mul(a[i-1]-1,f[i][j-2])); Add(ans[j],mul(f[i][j],b[i])); &#125; &#125; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;=n*2-2;++i)cout&lt;&lt;mul(ans[i],iv)&lt;&lt;' '; return 0;&#125; How many trees?解题思路： 该题可以将数据加强到 $n=400$ 考虑设 $f_{i,j}$ 表示 $i$ 个点深度为 $j$ 的树的方案数，显然可以枚举左右儿子的 $siz$ 转移，利用前缀和优化能够做到 $O(n^3)$ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ri int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a&lt;b?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=a+b&lt;mod?a+b:a+b-mod;&#125; inline void Dec(int&amp;a,int b)&#123;a=a&lt;b?a-b+mod:a-b;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;const int N=40;int n,m;ll f[N][N],g[N][N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); g[0][0]=g[1][1]=f[0][0]=f[1][1]=g[1][0]=1; for(ri i=2;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=i;++j)for(ri k=0;k&lt;i;++k) f[i][j]+=f[k][j-1]*(g[i-k-1][0]-g[i-k-1][j])*2-f[k][j-1]*f[i-k-1][j-1]; g[i][i]=f[i][i]; for(ri j=i-1;~j;--j)g[i][j]=g[i][j+1]+f[i][j]; &#125; cout&lt;&lt;g[n][m]; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"杂题乱做 Round2","slug":"sol2","date":"2019-10-28T14:56:09.000Z","updated":"2019-12-24T23:53:02.041Z","comments":true,"path":"sol2/","link":"","permalink":"http://ldxcaicai.github.io/sol2/","excerpt":"","text":"吉夫特解题思路： 显然用 $lucas$ 定理转化一下条件，可以转化成相邻两项的关系，然后有了无脑的 $70pts$ 暴力：设 $f_i$ 表示以第 $i$ 个数结尾的方案数，直接暴力 $check$ 即可： CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=3e5+5;int f[N],a[N],n;inline bool check(int a,int b)&#123; for(ri i=30;~i;--i)if((a&gt;&gt;i&amp;1)&lt;(b&gt;&gt;i&amp;1))return 0; return 1;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int res=0; for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); f[i]=1; for(ri j=1;j&lt;i;++j)if(check(a[j],a[i]))Add(f[i],f[j]); Add(res,dec(f[i],1)); &#125; cout&lt;&lt;res; return 0;&#125; 然后考虑优化 然后考虑优化，发现可以设 $f_i$ 表示当前选择序列的结尾的数为 $i$ 的合法方案数，然后枚举子集转移更新即可 这样做是询问 $O(1)$ ，修改 $O(2^{18})$ 的，不过已经能够通过了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=3e5+5;int f[N],n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int res=0; for(ri x,t,i=1;i&lt;=n;++i)&#123; x=read(); t=add(f[x],1); for(ri s=x;s;s=(s-1)&amp;x)Add(f[s],t); Add(res,dec(t,1)); &#125; cout&lt;&lt;res; return 0;&#125; 考虑继续优化 发现可以通过分块摊下复杂度，即设 $f_{i,j}$ 表示当前选择序列的结尾的前 $2^9$ 位等于 $i$ ，后 $2^9$ 为 $j$ 的子集的方案数，这样复杂度是 $O(n*2^9)$ 的 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=3e5+5;int f[1&lt;&lt;9|5][1&lt;&lt;9|5],n;inline int query(int x)&#123; int a=x&gt;&gt;9,b=x&amp;511,c=511^b; int res=0; for(ri s=c;;s=(s-1)&amp;c)&#123; Add(res,f[a][s^b]); if(!s)break; &#125; return res;&#125;inline void update(int x,int t)&#123; int a=x&gt;&gt;9,b=x&amp;511; for(ri s=a;;s=(s-1)&amp;a)&#123; Add(f[s][b],t); if(!s)break; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int res=0; for(ri x,t,i=1;i&lt;=n;++i)&#123; x=read(); t=add(query(x),1); update(x,t); Add(res,dec(t,1)); &#125; cout&lt;&lt;res; return 0;&#125; 游览计划解题思路： 使用斯坦纳树的思想，不过这道题给出的是点权，因此转移如下： 1. $f_{p,s}=\\min\\{f_{p,t}+f_{p,s\\oplus t}-value_p\\}$ 2. $f_{p,s}=\\min\\{f_{v,s}+dist(p,v)\\}$ 然后顺便要记录并输出方案 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;//using namespace modular;int dx[]=&#123;0,0,1,-1&#125;;int dy[]=&#123;1,-1,0,0&#125;;const int N=15,S=1&lt;&lt;10|5;int d[N][N][S],n,m,K,ct=0,vl[N][N],tr[N][N],all;struct Node&#123;int x,y,s;&#125;pre[N][N][S];set&lt;pair&lt;pii,int&gt; &gt;q;inline void dijkstra(int s)&#123; while(q.size())&#123; pii v,x=q.begin()-&gt;fi; q.erase(q.begin()); for(ri i=0;i&lt;4;++i)&#123; v=pii(x.fi+dx[i],x.se+dy[i]); if(d[v.fi][v.se][s]&gt;d[x.fi][x.se][s]+vl[v.fi][v.se])&#123; if(d[v.fi][v.se][s]!=d[0][0][0])q.erase(make_pair(v,d[v.fi][v.se][s])); d[v.fi][v.se][s]=d[x.fi][x.se][s]+vl[v.fi][v.se]; pre[v.fi][v.se][s]=(Node)&#123;x.fi,x.se,s&#125;; q.insert(make_pair(v,d[v.fi][v.se][s])); &#125; &#125; &#125;&#125;bool vs[N][N];inline void getprint(int x,int y,int s)&#123; if(!x)return; vs[x][y]=1; getprint(pre[x][y][s].x,pre[x][y][s].y,pre[x][y][s].s); if(pre[x][y][s].x==x&amp;&amp;pre[x][y][s].y==y)getprint(x,y,(pre[x][y][s].s^s)|tr[x][y]);&#125;inline void print()&#123; for(ri i=1;i&lt;=n;++i,puts(\"\"))for(ri j=1;j&lt;=m;++j)&#123; if(tr[i][j])cout&lt;&lt;'x'; else if(vs[i][j])cout&lt;&lt;'o'; else cout&lt;&lt;'_'; &#125; exit(0);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=m;++j)&#123; vl[i][j]=read(); if(!vl[i][j])&#123; ++ct; tr[i][j]=1&lt;&lt;(ct-1); &#125; &#125; &#125; all=(1&lt;&lt;ct)-1; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)memset(d[i][j],0x3f,sizeof(int)*(all+3)); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)if(tr[i][j])d[i][j][tr[i][j]]=0; d[0][0][0]=d[1][1][0]; for(ri s=0;s&lt;=all;++s)&#123; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; if(tr[i][j]&amp;&amp;!(tr[i][j]&amp;s))continue; for(ri t=(s-1)&amp;s,upd;t;t=(t-1)&amp;s)&#123; upd=d[i][j][t|tr[i][j]]+d[i][j][(s^t)|tr[i][j]]-vl[i][j]; if(d[i][j][s]&gt;upd)&#123; d[i][j][s]=upd; pre[i][j][s]=(Node)&#123;i,j,t|tr[i][j]&#125;; &#125; &#125; if(d[i][j][s]!=d[0][0][0])q.insert(make_pair(pii(i,j),d[i][j][s])); &#125; dijkstra(s); &#125; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)if(tr[i][j])&#123; cout&lt;&lt;d[i][j][all]&lt;&lt;'\\n'; getprint(i,j,all); print(); &#125; return 0;&#125; Umnozak解题思路： 首先一打开题就有一个暴力的思路，枚举这个数由多少个 $1,2,...,9$ 组成然后对于每种情况做数位 $dp$，但方案数较大，约在 $10^6\\cdots10^7$ 的级别，无法通过此题 因此考虑到上述做法中较多方案的所有数位的乘积相同，进而想到只需要枚举乘积由多少个 $2,3,5,7$ 组成即可，然后对每种方案进行数位 $dp$ 就能够通过此题 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;//using namespace modular;ll L,R;int ct[10][4]=&#123; &#123;0,0,0,0&#125;, &#123;0,0,0,0&#125;, &#123;1,0,0,0&#125;, &#123;0,1,0,0&#125;, &#123;2,0,0,0&#125;, &#123;0,0,1,0&#125;, &#123;1,1,0,0&#125;, &#123;0,0,0,1&#125;, &#123;3,0,0,0&#125;, &#123;0,2,0,0&#125;&#125;;int vl[20],ctt[4],len;ll f[20][30][19][13][11];inline ll dfs(int ps,int*a,bool lim,bool zero)&#123; if(ps==0)return !zero&amp;&amp;!(a[0]+a[1]+a[2]+a[3]); if(!lim&amp;&amp;!zero&amp;&amp;~f[ps][a[0]][a[1]][a[2]][a[3]])return f[ps][a[0]][a[1]][a[2]][a[3]]; ll res=0; if(zero)res+=dfs(ps-1,a,0,1); for(ri ff,i=1,up=lim?vl[ps]:9;i&lt;=up;++i)&#123; ff=1; for(ri j=0;j&lt;4;++j)if(ct[i][j]&gt;a[j])&#123; ff=0; break; &#125; if(!ff)continue; for(ri j=0;j&lt;4;++j)a[j]-=ct[i][j]; res+=dfs(ps-1,a,lim&amp;&amp;i==up,0); for(ri j=0;j&lt;4;++j)a[j]+=ct[i][j]; &#125; if(!lim&amp;&amp;!zero)f[ps][a[0]][a[1]][a[2]][a[3]]=res; return res;&#125;inline void init(ll tp)&#123; len=0; while(tp)vl[++len]=tp%10,tp/=10;&#125;inline ll solve(ll x)&#123; if(!x)return 0; if(x==1)return 1; ll up=min(x,1000000000ll); ctt[0]=0; ll res=0; memset(f,-1,sizeof(f)); for(ll mt1=1;;mt1*=2,++ctt[0])&#123; ctt[1]=0; for(ll mt2=mt1;;mt2*=3,++ctt[1])&#123; ctt[2]=0; for(ll mt3=mt2;;mt3*=5,++ctt[2])&#123; ctt[3]=0; for(ll mt4=mt3;;mt4*=7,++ctt[3])&#123; init(x/mt4); res+=dfs(len,ctt,1,1); if(up/7&lt;mt4)break; &#125; if(up/5&lt;mt3)break; &#125; if(up/3&lt;mt2)break; &#125; if(up/2&lt;mt1)break; &#125; return res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif cin&gt;&gt;L&gt;&gt;R; cout&lt;&lt;solve(R)-solve(L-1); return 0;&#125; Ksenia and Combinatorics解题思路： 首先通过归纳可以证明出如下结论： 对于树的匹配，设 $f_{i,0/1}$ 表示对于 $i$ 的子树用/不用根能得到的最大匹配数，那么有 $f_{i,0}\\le f_{i,1}\\le f_{i,0}+1$ 因此可以定义如下状态: $f_{i,j,0/1}$ 表示 $i$ 个点的树，最大匹配数为 $j$ ，用根进行匹配的最大匹配数减去不用根进行匹配的最大匹配数的值为 $0/1$ 时的方案数，转移比较自然，因此不一一赘述 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7,inv2=5e8+4; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=55;int n,K,f[N][N][2],C[N][N];inline void init()&#123; for(ri i=0;i&lt;=n;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j],C[i-1][j-1]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); f[0][0][1]=f[1][0][0]=1; init(); for(ri i=2,t;i&lt;=n;++i)for(ri j=0;j&lt;=K&amp;&amp;j+j&lt;=i;++j)&#123; for(ri k=0;k+k+1&lt;=i;++k)&#123; t=mul(mul(k+k+1==i?inv2:1,C[i-1][k]),mul(max(k,1),i-k-1)); for(ri p=0;p&lt;=j&amp;&amp;p+p&lt;=k;++p)&#123; Add(f[i][j][0],mul(t,mul(f[k][p][1],f[i-k-1][j-p][1]))); if(j==p)continue; Add(f[i][j][1],mul(t,mul(f[k][p][0],f[i-k-1][j-p-1][0]))); Add(f[i][j][1],mul(t,mul(f[k][p][1],f[i-k-1][j-p-1][0]))); Add(f[i][j][1],mul(t,mul(f[k][p][0],f[i-k-1][j-p-1][1]))); &#125; &#125; &#125; cout&lt;&lt;add(f[n][K][0],f[n][K][1]); return 0;&#125; isn解题思路： 首先用 $bit$ 辅助求出 $f_{i,j}$ 表示以 $i$ 结尾的长度为 $j$ 的不降序列方案数，进而统计出 $g_i$ 表示长度为 $i$ 的不降序列的方案数 然后进行简单容斥来求答案 假设对于 $g_i$ 中每个方案添上任意一个数都会不满足不降，那么 $Ans=\\sum\\limits_{i=1}^ng_i\\times(n-i)!$ ，但现在会算入添上一个数之后仍然不降的方案数，于是扣掉 $\\sum\\limits_{i=1}^ng_{i+1}\\times(n-i+1)!\\times(i+1)$ 即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=2005;int a[N],n,cur,f[2][N],g[N],vl[N],sig;inline int find(int x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;int bit[N];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void update(int x,int v)&#123;for(;x&lt;=n;x+=lowbit(x))Add(bit[x],v);&#125;inline int query(int x)&#123;int res=0;for(;x;x^=lowbit(x))Add(res,bit[x]);return res;&#125;int fac[N];inline void init()&#123; fac[0]=fac[1]=1; for(ri i=2;i&lt;=n;++i)fac[i]=mul(fac[i-1],i);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init(); for(ri i=1;i&lt;=n;++i)a[i]=vl[++sig]=read(); sort(vl+1,vl+sig+1),sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i)a[i]=find(a[i]); cur=0; update(1,1); for(ri len=1;len&lt;=n;++len)&#123; cur^=1; for(ri i=1;i&lt;=n;++i)&#123; f[cur][i]=query(a[i]); update(a[i],f[cur^1][i]); Add(g[len],f[cur][i]); &#125; for(ri i=1;i&lt;=n;++i)bit[i]=0; &#125; int res=0; for(ri i=1;i&lt;=n;++i)Mul(g[i],fac[n-i]); for(ri i=1;i&lt;=n;++i)&#123; Dec(g[i],mul(g[i+1],i+1)); Add(res,g[i]); &#125; cout&lt;&lt;res; return 0;&#125; 神经网络解题思路： 首先转化题意，相当于是把每棵树拆成若干条链然后把链缩成点求若干排点之间的哈密顿回路数（同一排点之间不能连边），这样对每棵树树形 $dp$ 出 $f_{i}$ 表示把整棵树拆成 $i$ 条链的方案数，然后考虑如何求答案，发现可以利用连通块容斥，即强制某一排中的某些链一定连通来容斥，如果将哈密顿回路的遍历映射到序列上，则相当于是一个连续段都属于同一排这样的不合法方案数，直接枚举段与段之间的空隙来进行容斥即可。 然后现在要将所有树给合起来，用 $EGF$ 搞即可，注意第一棵树有限制条件：第一个和最后一个不能是同一排的 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353,inv2=499122177; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=5005;int m,n,f[N][N][3],fac[N],ifac[N],siz[N],tmp[N][3];poly res(1,1);vector&lt;int&gt;e[N];int *tv,*tp;void dfs(int p,int ft)&#123; f[p][1][0]=1,siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; dfs(v,p); for(ri j=0;j&lt;=siz[v]+siz[p];++j)tmp[j][0]=tmp[j][1]=tmp[j][2]=0; for(ri j=0;j&lt;=siz[v];++j)if(f[v][j][0]||f[v][j][1]||f[v][j][2])&#123; tv=f[v][j]; for(ri k=0;k&lt;=siz[p];++k)if(f[p][k][0]||f[p][k][1]||f[p][k][2])&#123; tp=f[p][k]; for(ri a=0;a&lt;3;++a)for(ri b=0;b&lt;3;++b)Add(tmp[j+k][a],mul(tp[a],tv[b])); Add(tmp[j+k-1][1],mul(tp[0],tv[1])); Add(tmp[j+k-1][2],mul(mul(inv2,tp[1]),tv[1])); Add(tmp[j+k-1][1],mul(mul(2,tp[0]),tv[0])); Add(tmp[j+k-1][2],mul(tp[1],tv[0])); &#125; &#125; for(ri j=0;j&lt;=siz[v]+siz[p];++j)&#123; f[p][j][0]=tmp[j][0]; f[p][j][1]=tmp[j][1]; f[p][j][2]=tmp[j][2]; &#125; siz[p]+=siz[v]; &#125;&#125;inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=5000;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=5000;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; poly c(t); for(ri i=0;i&lt;n;++i)if(a[i]) for(ri j=0;j&lt;m;++j)if(b[j]) Add(c[i+j],mul(a[i],b[j])); return c;&#125;inline void update(int dt)&#123; poly ad(n+1); for(ri t,s,sz=1;sz&lt;=n;++sz)&#123; s=mul(fac[sz-dt],add(add(f[1][sz][0],f[1][sz][1]),f[1][sz][2])); for(ri i=1;i&lt;=sz;++i)&#123; t=mul(C(sz-1,i-1),s); t=(sz-i)&amp;1?mod-t:t; Add(ad[i-dt],t); if(dt&amp;&amp;i&gt;1)Dec(ad[i-2],t); &#125; &#125; for(ri i=0;i&lt;ad.size();++i)Mul(ad[i],ifac[i]); res=res*ad;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif m=read(); init(); for(ri tt=1;tt&lt;=m;++tt)&#123; n=read(); for(ri i=1;i&lt;=n;++i)&#123; e[i].clear(); for(ri j=1;j&lt;=n;++j)&#123; f[i][j][0]=0; f[i][j][1]=0; f[i][j][2]=0; &#125; &#125; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; dfs(1,0); update(tt==1); &#125; int ans=0; for(ri i=0;i&lt;res.size();++i)Add(ans,mul(res[i],fac[i])); cout&lt;&lt;ans; return 0;&#125; 侦查守卫解题思路： 考虑 $f_{i,j}$ 表示将 $i$ 子树中关键点覆盖完且能向 $i$ 子树外覆盖 $j$ 单位距离的最小代价， $g_{i,j}$ 表示 $i$ 子树中只剩下跟 $i$ 距离小于 $j$ 的关键点未覆盖的最小权值，然后有显然的转移，这里不一一赘述，要提到的则是可能在儿子对父亲进行更新之后出现 $f_{i,j}>f_{i,j+1}$ 或者 $g_{i,j}>g_{i,j-1}$ 的情况，因此要把两个状态的定义加上最少和至多的限制，然后前后缀进行更新 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() getchar()typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=5e5+5,inf=0x3f3f3f3f,D=22;vector&lt;int&gt;e[N];bool is[N];int n,m,d,a[N],f[N][D],g[N][D];void dfs(int p,int ft)&#123; if(is[p])f[p][0]=g[p][0]=a[p]; for(ri i=1;i&lt;=d;++i)f[p][i]=a[p]; f[p][d+1]=inf; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; dfs(v,p); for(ri j=d;~j;--j)f[p][j]=min(f[p][j]+g[v][j],g[p][j+1]+f[v][j+1]); for(ri j=d;~j;--j)ckmin(f[p][j],f[p][j+1]); g[p][0]=f[p][0]; for(ri j=1;j&lt;=d;++j)g[p][j]+=g[v][j-1]; for(ri j=1;j&lt;=d;++j)ckmin(g[p][j],g[p][j-1]); &#125; ckmin(g[p][d+1],g[p][d]);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),d=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); m=read(); for(ri i=1;i&lt;=m;++i)is[read()]=1; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; dfs(1,0); cout&lt;&lt;f[1][0]; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"杂题乱做 Round1","slug":"sol1","date":"2019-10-17T03:28:59.000Z","updated":"2019-12-24T23:52:06.330Z","comments":true,"path":"sol1/","link":"","permalink":"http://ldxcaicai.github.io/sol1/","excerpt":"","text":"线段树解题思路： 考虑到如果统计统计 $f_{i,j}$ 表示第 $i$ 个位置的数最终等于 $j$ 的概率，然后对于一个位置 $i$ 答案就是 $\\sum\\limits_{j}f_{i,j}vl_j$ ，然后就能够进行转化，变为求每个位置最终 $\\ge j$ 的概率，然后就能够枚举每个排名然后对笛卡尔树的一些子树进行如下 $dp$ : 对于一个树根，设其能够管辖的范围为 $[l,r]$ ，那么最后区间 $[i\\ge l,j\\le r]$ 中的数的大小不超过树根大小的概率可以 $dp$ 出来，设 $f_{T,i,j}$ 表示在上界 $x$ 确定后，在经过 $T$ 轮操作后区间 $[i,j]$ 的答案不超过 $x$ 的概率，这个直接前缀和优化转移即可，由于数据随机，笛卡尔树高可以视为 $log$ 的，这样复杂度就是对的 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='*'&amp;&amp;ch!='.')ch=gc(); while(ch=='*'||ch=='.')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=405;int n,m,L[N],R[N],cur=0,trans[N][N],vl[N],sig,ori[N],mx[N][N];int f[2][N][N],res[N][N];inline int calc(int x)&#123;return x*(x+1)/2;&#125;inline int find(int x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;inline void init()&#123; for(ri i=1;i&lt;=n;++i)ori[i]=find(ori[i]); ori[0]=ori[n+1]=sig+1; for(ri a=1;a&lt;=n;++a)for(ri b=a;b&lt;=n;++b)&#123; mx[a][b]=max(mx[a][b-1],ori[b]); trans[a][b]=calc(a-1)+calc(b-a+1)+calc(n-b); &#125;&#125;inline void clear(int l,int r)&#123; cur^=1; for(ri i=l;i&lt;=r;++i)for(ri j=i;j&lt;=r;++j) f[cur][i][j]=0;&#125;inline void solve(int l,int r,int t)&#123; int transum; clear(l,r); f[cur][l][r]=1; for(ri T=1;T&lt;=m;++T)&#123; cur^=1; for(ri a=l;a&lt;=r;++a)for(ri b=a;b&lt;=r;++b) f[cur][a][b]=mul(f[cur^1][a][b],trans[a][b]); for(ri b=l;b&lt;=r;++b)&#123; transum=0; for(ri a=l;a&lt;=b;++a)&#123; Add(f[cur][a][b],transum); Add(transum,mul(f[cur^1][a][b],a-1)); &#125; &#125; for(ri a=r;a&gt;=l;--a)&#123; transum=0; for(ri b=r;b&gt;=a;--b)&#123; Add(f[cur][a][b],transum); Add(transum,mul(f[cur^1][a][b],n-b)); &#125; &#125; &#125; for(ri b=l;b&lt;=r;++b)&#123; transum=0; for(ri a=l;a&lt;=b;++a)&#123; Add(transum,f[cur][a][b]); Add(res[a][t],transum); &#125; &#125;&#125;int stk[N],tp;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); freopen(\"own.out\",\"w\",stdout); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)ori[i]=vl[i]=read(); sort(vl+1,vl+n+1),sig=unique(vl+1,vl+n+1)-vl-1; init(); for(ri rk=1;rk&lt;=sig;++rk)&#123; tp=0; for(ri i=0;i&lt;=n+1;++i)if(ori[i]&gt;rk)stk[++tp]=i; for(ri i=1;i&lt;tp;++i)&#123; if(mx[stk[i]+1][stk[i+1]-1]&lt;rk)&#123; for(ri ps=stk[i]+1;ps&lt;=stk[i+1]-1;++ps) Add(res[ps][rk],res[ps][rk-1]); &#125; else solve(stk[i]+1,stk[i+1]-1,rk); &#125; &#125; for(ri p=1,sum;p&lt;=n;++p,sum=0)&#123; for(ri rk=1;rk&lt;=sig;++rk) Add(sum,mul(vl[rk],dec(res[p][rk],res[p][rk-1]))); cout&lt;&lt;sum&lt;&lt;' '; &#125; return 0;&#125; 愤怒的元首解题思路： $DAG$ 计数一般考虑入度为 $0$ 或者出度为 $0$ 的点来进行容斥，因为删掉这些点和它们涉及到的边之后还是个 $DAG$ 设 $f_{i}$ 表示 $i$ 个点的 $DAG$ 方案数， $g_i$ 为至少有 $i$ 个出度为 $0$ 的点的方案数，显然有转移 $g_j=f_{i-j}\\binom{i}{j}2^{j\\times(i-j)}$ 和 $f_i=\\sum\\limits_{j=1}^ig_j(-1)^{j-1}$ 这样可以 $O(n^2)$ 搞定了 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='*'&amp;&amp;ch!='.')ch=gc(); while(ch=='*'||ch=='.')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=3005;int n,f[N],fac[N],ifac[N],pw[N*N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; pw[0]=1; for(ri i=1;i&lt;=n*n;++i)pw[i]=add(pw[i-1],pw[i-1]); for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init(); f[0]=1; for(ri i=1;i&lt;=n;++i)for(ri t,j=1;j&lt;=i;++j)&#123; t=mul(f[i-j],mul(C(i,j),pw[j*(i-j)])); j&amp;1?Add(f[i],t):Dec(f[i],t); &#125; cout&lt;&lt;f[n]; return 0;&#125; numbers解题思路： 考虑直接转化为求合法括号序列的方案数，这样对于现在的区间 $[l,r]$ ，可以枚举 $l$ 的右括号放的位置然后转移成子区间求解，现在只用考虑合法性如何快速判断，发现是两个不相交的连续区间的信息叠加起来的，于是用二维前缀和来记录限制即可判断合法性 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=305;int n,sum[N][N],m,f[N][N],tim[N][N],tot=0;inline int getsum(int x1,int x2,int y1,int y2)&#123; return sum[x2][y2]+sum[x1-1][y1-1]-sum[x2][y1-1]-sum[x1-1][y2];&#125;inline int dfs(int l,int r)&#123; if(l==r)return 1; if(tim[l][r]==tot)return f[l][r]; tim[l][r]=tot; f[l][r]=0; if(!getsum(l,l,l,r))Add(f[l][r],dfs(l+1,r)); for(ri i=l+1;i&lt;=r;++i)if(!getsum(i,r,l,i-1)&amp;&amp;!getsum(l,l,l,i-1)) Add(f[l][r],mul(i==l+1?1:dfs(l+1,i-1),dfs(i,r))); return f[l][r];&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; ++tot; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)sum[i][j]=0; for(ri a,b,i=1;i&lt;=m;++i)&#123; a=read(),b=read(); sum[a][b]=1; &#125; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j) sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]; bool ff=1; for(ri i=1;i&lt;=n;++i)if(getsum(i,i,i,i))&#123; ff=0; break; &#125; if(!ff)puts(\"0\"); else cout&lt;&lt;dfs(1,n)&lt;&lt;'\\n'; &#125; return 0;&#125; Dark Horse解题思路： 把比赛的表倒着画出来，发现是一棵二叉树，这样看来不妨把 $1$ 放在第一个叶子结点最后方案数再乘上 $2^n$ ，然后现在要求的是从第一个叶子到根的路径上不能有非法点，不难想到从大到小枚举非法点在路径上出现的状态，则 $f_{i,j}$ 表示当前走到第 $i$ 个点，从叶子到根的必输位置集合为 $j$ 的方案数，最后容斥一下即可（也可以像我一样在转移的时候就带入容斥系数） CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='*'&amp;&amp;ch!='.')ch=gc(); while(ch=='*'||ch=='.')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=1&lt;&lt;20|5;int n,m,all;int fac[N],ifac[N],pw[N],a[25],f[2][N],cur;inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=all;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=all;++i)Mul(ifac[i],ifac[i-1]); pw[0]=1; for(ri i=1;i&lt;=n;++i)pw[i]=pw[i-1]&lt;&lt;1;&#125;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),all=1&lt;&lt;n; init(); for(ri i=1;i&lt;=m;++i)a[i]=read(); sort(a+1,a+m+1); f[cur=0][0]=1; for(ri ps=m;ps;--ps)&#123; cur^=1; for(ri s=0;s&lt;all;++s)f[cur][s]=f[cur^1][s]; for(ri s=0,trans;s&lt;all;++s)if(f[cur^1][s])&#123; trans=all-s-a[ps]; if(trans&gt;=0)for(ri i=0;i&lt;n;++i)if(!(s&amp;pw[i])) Dec(f[cur][s|pw[i]],mul(f[cur^1][s],mul(C(trans,pw[i]-1),fac[pw[i]]))); &#125; &#125; int res=0; for(ri s=0,t;s&lt;all;++s)Add(res,mul(f[cur][s],fac[all-s-1])); cout&lt;&lt;mul(res,all); return 0;&#125; Popping Balls解题思路： 由于可以选 $1$ ，因为 $s,t$ 只需要用于选出蓝球，这样可以考虑在 $t,s$ 有用的时候才放置它俩上去（因为其余合法方案方案可以用这种方案选出），这样最后的序列一定长这样： 先有 $x$ 个红球被选，然后在第一个蓝球位置处放下 $t$ ，并选出这个蓝球 ，然后接下来选出的 是 $a$ 个红球和 $b-1$ 个蓝球随意排列（此时应满足 $a+b=m$ 即使得 $t$ 在之后的操作中失效），接着是 $y$ 个红球被选出，然后在第一个蓝球位置处放下 $s$ ，并选出这个蓝球，然后接下来选出的是 $c$ 个红球和 $d-1$ 个蓝球随意排列（此时应满足 $c+d=a$ 理由同 $t$ 那部分），最后的 $z$ 个球直接按照原序列放即可 然后可以考虑枚举 $x,a,y,c$ 来计算贡献~~然后多半就TLE了~~ 列出式子之后会发现这个四维的玩意儿后面两维的组合数和可以预处理二维前缀和优化，这样复杂度降为了 $O(n^2)$ ，可以通过 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='*'&amp;&amp;ch!='.')ch=gc(); while(ch=='*'||ch=='.')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=2005;int n,m,C[N][N],g[N][N],f[N][N];inline void init(int up)&#123; for(ri i=0;i&lt;=up;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j) C[i][j]=add(C[i-1][j],C[i-1][j-1]); &#125; for(ri i=0;i&lt;=up;++i)&#123; g[i][0]=C[i][0]; for(ri j=1;j&lt;=up;++j)g[i][j]=add(g[i][j-1],C[i][j]); &#125; for(ri i=0;i&lt;=up;++i)&#123; f[0][i]=g[i][0]; for(ri j=1;j&lt;=up;++j)f[j][i]=add(f[j-1][i],g[i][j]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); init(max(n,m)); int res=0; for(ri t1,t2,x=0;x&lt;=n;++x)for(ri a=0;a+x&lt;=n;++a)&#123; t1=C[m-1][a]; t2=a?f[n-a-x][a-1]:1; Add(res,mul(t1,t2)); &#125; cout&lt;&lt;res&lt;&lt;'\\n'; return 0;&#125; Placing Squares解题思路： 首先转化模型，看成有一个 $n$ 个点的序列，你要在空隙中插入挡板，把序列分成若干段，每段要放一个红球和一个蓝球，现在还有 $m$ 个坐标 $\\{x_m\\}$ ，限制你不能在 $x_i,x_i+1$ 之间放挡板，问方案数 那么可以设计 $f_{i,0/1/2/3}$ 表示当前扫到了第 $i$ 个点，它在的段内没放球/放了红球/放了蓝球/放了两种球的方案数，这个可以在有无限制的情况下轻松设置转移，由于第一维较大，用矩阵快速幂优化即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;struct Mat&#123; int a[4][4]; Mat(int v=0)&#123;for(ri i=0;i&lt;=3;++i)for(ri j=0;j&lt;=3;++j)a[i][j]=i==j?v:0;&#125; inline int*operator[](const int&amp;k)&#123;return a[k];&#125; inline const int*operator[](const int&amp;k)const&#123;return a[k];&#125; friend inline Mat operator*(Mat a,Mat b)&#123; Mat c; for(ri i=0;i&lt;=3;++i)for(ri k=0;k&lt;=3;++k)if(a[i][k]) for(ri j=0;j&lt;=3;++j)if(b[k][j])Add(c[i][j],mul(a[i][k],b[k][j])); return c; &#125; friend inline Mat operator^(Mat a,int p)&#123; Mat ret(1); for(;p;p&gt;&gt;=1,a=a*a)if(p&amp;1)ret=ret*a; return ret; &#125;&#125;trans1,trans2,res(1);int n,m;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif trans1[0][0]=2,trans1[0][1]=1,trans1[0][2]=1,trans1[0][3]=1; trans1[1][0]=1,trans1[1][1]=1,trans1[1][2]=0,trans1[1][3]=1; trans1[2][0]=1,trans1[2][1]=0,trans1[2][2]=1,trans1[2][3]=1; trans1[3][0]=1,trans1[3][1]=0,trans1[3][2]=0,trans1[3][3]=1; trans2[0][0]=1,trans2[0][1]=1,trans2[0][2]=1,trans2[0][3]=1; trans2[1][0]=0,trans2[1][1]=1,trans2[1][2]=0,trans2[1][3]=1; trans2[2][0]=0,trans2[2][1]=0,trans2[2][2]=1,trans2[2][3]=1; trans2[3][0]=0,trans2[3][1]=0,trans2[3][2]=0,trans2[3][3]=1; n=read(),m=read(); int las=1; for(ri i=1,x;i&lt;=m;++i)&#123; x=read(); if(i&gt;1)&#123; res=(trans1^(x-las-1))*trans2*res; &#125; else res=(trans1^(x-las))*res; las=x; &#125; if(m)res=(trans1^(n-las-1))*trans2*res; else res=trans1^(n-1); cout&lt;&lt;add(add(res[0][0],res[0][1]),add(res[0][2],res[0][3])); return 0;&#125; 随机二分图解题思路： 容易想到去求每种匹配出现的概率，那么答案即为概率之和，现在考虑每类边出现在完美匹配的一个方案中的概率： 第一类边： $50\\%$ 第二类边： 每条边单独出现在一个方案中的概率为 $50\\%$ ，但这样的话两条边一起出现的概率降为了 $25\\%$ ，于是加入一个能连接四个点的边，其出现概率为 $25\\%$ 第三类边： 每条边单独出现在一个方案中的概率为 $50\\%$ ，但这样的话两条边一起出现的概率升为了 $25\\%$ ，于是加入一个能连接四个点的边，其出现概率为 $-25\\%$ 然后考虑把左右图的匹配情况压成一个状态进行转移，由于图没有顺序，每次强制匹配 $lowbit$ 来转移即可，从终态倒着记忆化搜索会访问到很少的有用状态，可以通过此题 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int inv2=5e8+4,inv4=inv2&gt;&gt;1;const int mogic=1e7+7;int first[mogic+5];struct edge&#123;int next,ori,vl;&#125;;vector&lt;edge&gt;E;int cnt=0;inline void add_(int u,int v)&#123; int t=u%mogic+1; ++cnt; E.pb((edge)&#123;first[t],u,v&#125;); first[t]=cnt;&#125;inline int query(int x)&#123; int t=x%mogic+1; for(ri i=first[t];i;i=E[i].next)&#123; if(E[i].ori==x)return E[i].vl; &#125; return -1;&#125;int n,m,pw[31];vector&lt;pii&gt;e[1&lt;&lt;15|5];inline int dfs(int sta)&#123; if(!sta)return 1; int t=query(sta); if(~t)return t; int res=0; int st=sta&amp;-sta; for(ri i=0,s;i&lt;e[st].size();++i)&#123; s=e[st][i].fi; if((sta&amp;s)!=s)continue; Add(res,mul(dfs(sta^s),e[st][i].se)); &#125; return add_(sta,res),res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); E.pb((edge)&#123;0,0,0&#125;); for(ri i=0;i&lt;=2*n;++i)pw[i]=1&lt;&lt;i; for(ri op,x1,y1,x2,y2,i=1;i&lt;=m;++i)&#123; op=read(); x1=read()-1,y1=read()+n-1; switch(op)&#123; case 0:&#123; e[pw[x1]].pb(pii(pw[x1]^pw[y1],inv2)); break; &#125; case 1:&#123; e[pw[x1]].pb(pii(pw[x1]^pw[y1],inv2)); x2=read()-1,y2=read()+n-1; e[pw[x2]].pb(pii(pw[x2]^pw[y2],inv2)); if(x1!=x2&amp;&amp;y1!=y2)&#123; if(x1&gt;x2)swap(x1,x2),swap(y1,y2); e[pw[x1]].pb(pii(pw[x1]^pw[x2]^pw[y1]^pw[y2],inv4)); &#125; break; &#125; case 2:&#123; e[pw[x1]].pb(pii(pw[x1]^pw[y1],inv2)); x2=read()-1,y2=read()+n-1; e[pw[x2]].pb(pii(pw[x2]^pw[y2],inv2)); if(x1!=x2&amp;&amp;y1!=y2)&#123; if(x1&gt;x2)swap(x1,x2),swap(y1,y2); e[pw[x1]].pb(pii(pw[x1]^pw[x2]^pw[y1]^pw[y2],mod-inv4)); &#125; break; &#125; &#125; &#125; cout&lt;&lt;mul(dfs(pw[n+n]-1),pw[n]); return 0;&#125; Mod Mod Mod解题思路： 一个数对一个比它小的数取模，最多取log次就会变成0。我们思考如何利用这个性质。 如果我们设 $f[x][i]$ 表示题目中的 $f(x,i)$ ，那么每次 $i$ 加一的时候我们都要更新所有的 $f$ 值。 但简单思考后可以发现答案容易表示成 $i*x+b$ 的形式，那么可以设 $F_{i,num}$ 就代表当 $x\\le num$ 时，最大的 $b$ 值。 下面考虑转移，对于 $num\\le a_i-1$显然不用管，对于 $num\\ge a_i$ ，有两种转移： 1. $F_{i,num}\\rightarrow F_{i+1,num\\%a_i}$ 2. $F_{i,num}\\rightarrow F_{i+1,a_i-1}$ 用 $map$ 维护转移即可，复杂度是 $O(n\\log a_1\\log n)$ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define ri register int#define csi const int&amp;#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=2e5+5;map&lt;ll,ll&gt;f;int n;ll x,num,vl;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); f[readl()-1]=0; for(ri i=2;i&lt;=n;++i)&#123; x=readl(); while(f.size())&#123; num=f.rbegin()-&gt;fi; vl=f.rbegin()-&gt;se; if(num&lt;x)break; f.erase(num); ckmax(f[x-1],vl+(num-num%x-x)*(i-1)); ckmax(f[num%x],vl+(num-num%x)*(i-1)); &#125; &#125; ll res=0; for(map&lt;ll,ll&gt;::iterator it=f.begin();it!=f.end();++it) res=max(res,it-&gt;fi*n+it-&gt;se); cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://ldxcaicai.github.io/tags/题解/"}]},{"title":"CodeForces gym 102059 简要题解","slug":"gym102059","date":"2019-10-16T23:47:42.000Z","updated":"2019-11-07T10:53:43.276Z","comments":true,"path":"gym102059/","link":"","permalink":"http://ldxcaicai.github.io/gym102059/","excerpt":"","text":"Coloring Roads题意简述： 给一棵树，树边一开始都是无色的，每次操作可以把一个点到根的路径上所有边染成某个颜色，每次询问当前树上出现过某个次数的颜色种数 数据范围： 点数，操作数 $\\le2\\times10^5$ 解题思路： 这题做法还蛮多的，在这里简单记录一下： 树链剖分+单调栈：对于每条重链维护一个关于 $dfs$ 序的单调递减栈从而维护答案，每次暴力修改，均摊分析复杂度是对的 树链剖分+ $ODT$ ，由于有路径覆盖操作，因此可以用 $ODT$ 简单维护答案，复杂度分析跟序列上是差不多的 $LCT$ ，考虑到路径覆盖就是 $LCT$ 在 $access$ 的时候顺带修改一下信息，因此每次改的时候 $access$ 即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=4e5+5;set&lt;int&gt;S[N];int cnt[N];namespace lct&#123; #define lc (son[p][0]) #define rc (son[p][1]) int siz[N],fa[N],son[N][2],vl[N],col[N]; bool rev[N]; inline bool which(int x)&#123;return x==son[fa[x]][1];&#125; inline bool isroot(int x)&#123;return !fa[x]||(son[fa[x]][0]!=x&amp;&amp;son[fa[x]][1]!=x);&#125; inline void pushup(int p)&#123;siz[p]=siz[lc]+siz[rc]+vl[p];&#125; inline void pushnow(int p,int c)&#123;col[p]=c;&#125; inline void pushdown(int p)&#123;(lc&amp;&amp;(col[lc]=col[p])),(rc&amp;&amp;(col[rc]=col[p]));&#125; inline void rotate(int x)&#123; int y=fa[x],z=fa[y],t=which(x); if(!isroot(y))son[z][which(y)]=x; fa[x]=z,fa[y]=x,son[y][t]=son[x][t^1],son[x][t^1]=y; if(son[y][t])fa[son[y][t]]=y; pushup(y),pushup(x); &#125; inline void splay(int x)&#123; static int stk[N],top; stk[top=1]=x; for(ri i=x;!isroot(i);i=fa[i])stk[++top]=fa[i]; while(top)pushdown(stk[top--]); while(!isroot(x))&#123; if(!isroot(fa[x]))rotate(which(x)^which(fa[x])?x:fa[x]); rotate(x); &#125; &#125; inline void access(int x,int c)&#123; int p=x; for(ri y=0;x;x=fa[y=x])&#123; splay(x); son[x][1]=0; pushup(x); S[cnt[col[x]]].erase(col[x]); cnt[col[x]]-=siz[x]; S[cnt[col[x]]].insert(col[x]); son[x][1]=y; pushup(x); p=x; &#125; pushnow(p,c); S[cnt[col[p]]].erase(col[p]); cnt[col[p]]+=siz[p]; S[cnt[col[p]]].insert(col[p]); &#125; #undef lc #undef rc&#125;int n,C,m;vector&lt;int&gt;e[N];void dfs(int p,int fa)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==fa)continue; dfs(v,p); lct::fa[lct::fa[v]=v+n]=p; lct::siz[v+n]=lct::vl[v+n]=1; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),C=read(),m=read(); for(ri i=1;i&lt;=C;++i)S[0].insert(i); S[n-1].insert(0); cnt[0]=n-1; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; dfs(1,0); for(ri x,c,k;m;--m)&#123; x=read(),c=read(),k=read(); lct::access(x,c); cout&lt;&lt;S[k].size()-(S[k].count(0)?1:0)&lt;&lt;'\\n'; &#125; return 0;&#125; Dev, Please Add This!题意简述： 给一个 $n*m$ 的网格图，一个格子是空地或墙，空地上可能有道具。你从一个位置出发，选一个方向然后一直按那个方向走直到碰到墙或边界。沿途的所有道具都会被收集，问能否收集所有道具。 数据范围： $n,m\\le50$ 解题思路： 根据题意，每行每列都被边界和墙分成了很多小段，我们把这些段进行标号，那么对于一个道具，它被收集当且仅当它所在的行列分量至少有一个被选，于是想到用 $2-sat$ 来进行这类限制，然后考虑剩下的限制，若从起点出发不能到达某个分量，那么最后它必须为 $false$ ，如果两个分量没有一个能到达另一个，那么就不能同时为 $true$ ，建完图之后用 $2-sat$ 跑即可 合法性证明：考虑将建出来的图缩点，那么就变成了一张有向完全图，从一个入度为 $0$ 的点出发找哈密顿回路，这个一定能构造出一组解 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='O'&amp;&amp;ch!='#'&amp;&amp;ch!='.'&amp;&amp;ch!='*')ch=gc(); while(ch=='O'||ch=='#'||ch=='.'||ch=='*')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353,inv2=499122177; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=55,M=N*N*4;char s[N][N];int n,m,sig=0,col[M],stk[M],top=0;bool vs[M];vector&lt;int&gt;e[M];int tot=0,low[M],dfn[M];bool trans[M][M];void dfs(int p)&#123; dfn[p]=low[p]=++tot; stk[++top]=p; vs[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if(dfn[v=e[p][i]])&#123; if(vs[v])low[p]=min(low[p],low[v]); continue; &#125; dfs(v),low[p]=min(low[p],low[v]); &#125; if(low[p]==dfn[p])&#123; ++sig; while(1)&#123; int x=stk[top--]; vs[x]=0; col[x]=sig; if(x==p)break; &#125; &#125;&#125;int idx1[N][N],idx2[N][N],cnt=0;inline void gettrans(int p,int rt)&#123; trans[rt][p]=1; for(ri i=0;i&lt;e[p].size();++i) if(!trans[rt][e[p][i]])gettrans(e[p][i],rt);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)Read(s[i]); for(ri i=0;i&lt;=n+1;++i)s[i][0]=s[i][m+1]='#'; for(ri i=0;i&lt;=m+1;++i)s[0][i]=s[n+1][i]='#'; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; if(s[i][j-1]=='#'&amp;&amp;s[i][j]!='#')++cnt; idx1[i][j]=cnt; &#125; for(ri i=1;i&lt;=m;++i)for(ri j=1;j&lt;=n;++j)&#123; if(s[j-1][i]=='#'&amp;&amp;s[j][i]!='#')++cnt; idx2[j][i]=cnt; &#125; ++cnt; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)&#123; if(s[i][j]=='#')continue; if(s[i][j-1]=='#'||s[i][j+1]=='#')e[idx1[i][j]].pb(idx2[i][j]); if(s[i-1][j]=='#'||s[i+1][j]=='#')e[idx2[i][j]].pb(idx1[i][j]); if(s[i][j]=='O')e[cnt].pb(idx1[i][j]),e[cnt].pb(idx2[i][j]); &#125; for(ri i=1;i&lt;=cnt;++i)gettrans(i,i); for(ri i=1;i&lt;=cnt;++i)e[i].clear(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)if(s[i][j]=='*')&#123; e[idx1[i][j]].pb(idx2[i][j]+cnt); e[idx2[i][j]].pb(idx1[i][j]+cnt); &#125; for(ri i=1;i&lt;cnt;++i)if(!trans[cnt][i])e[i+cnt].pb(i); for(ri i=1;i&lt;cnt;++i)for(ri j=i+1;j&lt;cnt;++j)if(!trans[i][j]&amp;&amp;!trans[j][i])&#123; e[i+cnt].pb(j); e[j+cnt].pb(i); &#125; for(ri i=1;i&lt;cnt*2;++i)if(!dfn[i])dfs(i); for(ri i=1;i&lt;cnt;++i)if(col[i]==col[i+cnt])&#123; puts(\"NO\"); return 0; &#125; puts(\"YES\"); return 0;&#125; Dstorv题意简述： 数轴上排列着 $n$ 个左/右箭头，每个箭头都会以相同速度朝着各自方向移动。当一个左箭头和一个右箭头相遇时有概率 $p$ 使得其中左箭头消失， $1-p$ 概率使右箭头消失，问最后剩下 $a$ 个右箭头和 $b$ 个左箭头的概率。 数据范围： $n\\le5000$ 解题思路： 对于每一种合法方案，对应着在最右的左箭头和最左的右箭头之间划一道分界线，然后分界线左侧的右箭头全部 $gg$ ，分界线右侧的左箭头全部 $gg$ ，这样如果统计出分界线左右部分合法的概率就可以枚举分界线统计答案 现在考虑如何求概率，设 $f_{i,j}$ 表示从左到右处理到第 $i$ 个箭头，最后会从右边来 $j$ 个左箭头进行支援，最后剩下 $b$ 个左箭头的概率，然后转移即可，右侧的转移同理 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=5005;int f[N][N],g[N][N],pa,pb,p,n,A,B;char s[N];signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),pa=read(),pb=read(); Mul(pa,Inv(pa+pb)); pb=dec(1,pa); Read(s); A=read(),B=read(); f[0][B]=1; for(ri i=1;i&lt;=n;++i)&#123; if(s[i]=='H')for(ri j=0;j&lt;n;++j)f[i][j]=f[i-1][j+1]; else for(ri j=1;j&lt;=n;++j)f[i][j]=add(mul(f[i][j-1],pb),mul(f[i-1][j],pa)); &#125; g[n+1][A]=1; for(ri i=n;i;--i)&#123; if(s[i]=='R')for(ri j=0;j&lt;n;++j)g[i][j]=g[i+1][j+1]; else for(ri j=1;j&lt;=n;++j)g[i][j]=add(mul(g[i][j-1],pa),mul(g[i+1][j],pb)); &#125; int res=0; for(ri i=0;i&lt;=n;++i)Add(res,mul(f[i][0],g[i+1][0])); cout&lt;&lt;res; return 0;&#125; Dumae建拓扑图+贪心即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int mod=1e9+7;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=3e5+5;int n,m,L[N],R[N],du[N],q[N],hd,tl,Du[N];vector&lt;int&gt;e[N];vector&lt;pii&gt;a[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)L[i]=read(),R[i]=read(); for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].pb(v),++du[v],++Du[v]; &#125; int cnt=n; hd=1,tl=0; for(ri i=1;i&lt;=n;++i)if(!du[i])q[++tl]=i; while(hd&lt;=tl)&#123; int x=q[hd++]; --cnt; for(ri i=0,v;i&lt;e[x].size();++i)&#123; --du[v=e[x][i]]; if(!du[v])q[++tl]=v; &#125; &#125; if(cnt)return puts(\"-1\"),0; for(ri p,i=n;i;--i)&#123; p=q[i]; for(ri j=0,v;j&lt;e[p].size();++j)R[p]=min(R[p],R[v=e[p][j]]-1); &#125; set&lt;pii&gt;S,qu; vector&lt;int&gt;ans; for(ri i=1;i&lt;=n;++i)if(!Du[i])&#123; if(L[i]==1)qu.insert(pii(R[i],i)); else S.insert(pii(L[i],i)); &#125; while(qu.size())&#123; int x=qu.begin()-&gt;se; qu.erase(qu.begin()); ++cnt; if(R[x]&lt;cnt)return puts(\"-1\"),0; ans.pb(x); while(S.size()&amp;&amp;S.begin()-&gt;fi&lt;=cnt+1)qu.insert(pii(R[S.begin()-&gt;se],S.begin()-&gt;se)),S.erase(S.begin()); for(ri i=0,v;i&lt;e[x].size();++i)&#123; --Du[v=e[x][i]]; if(!Du[v])&#123; if(L[v]&lt;=cnt+1)qu.insert(pii(R[v],v)); else S.insert(pii(L[v],v)); &#125; &#125; &#125; if(ans.size()!=n)return puts(\"-1\"),0; for(ri i=0;i&lt;ans.size();++i)cout&lt;&lt;ans[i]&lt;&lt;'\\n'; return 0;&#125; Electronic Circuit逆向考虑然后按照题意模拟 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int mod=1e9+7;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=1e5+5;set&lt;int&gt;e[N];bool ban[N];int n,m,cnt;inline void modify(int p)&#123; if(ban[p])return; if(e[p].size()^2)return; --cnt; ban[p]=1; int pre=*e[p].begin(),suf=*e[p].rbegin(); e[pre].erase(p); e[pre].insert(suf); e[suf].erase(p); e[suf].insert(pre); modify(pre),modify(suf);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); cnt=n; for(ri i=1,u,v;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].insert(v); e[v].insert(u); &#125; for(ri i=1;i&lt;=n;++i)modify(i); puts(cnt==2?\"Yes\":\"No\"); return 0;&#125; Fake Plastic Trees每次均分叶子给子树，记忆化一下就行了 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int mod=1e9+7;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;vector&lt;ll&gt;vl;map&lt;ll,int&gt;idx;map&lt;ll,bool&gt;vs;inline void dfs(ll x)&#123; if(vs[x])return; vs[x]=1; vl.pb(x); if(x==1)return; dfs(x-(x&gt;&gt;1)),dfs(x&gt;&gt;1);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif ll x; int tot; for(ri tt=read();tt;--tt)&#123; x=readl(); vl.clear(); vs.clear(); dfs(x); sort(vl.begin(),vl.end()); idx.clear(); tot=-1; for(ri i=0;i&lt;vl.size();++i)idx[vl[i]]=++tot; cout&lt;&lt;tot+1&lt;&lt;'\\n'; cout&lt;&lt;-1&lt;&lt;' '&lt;&lt;-1&lt;&lt;'\\n'; for(ri i=1;i&lt;vl.size();++i)cout&lt;&lt;idx[vl[i]-(vl[i]&gt;&gt;1)]&lt;&lt;' '&lt;&lt;idx[vl[i]&gt;&gt;1]&lt;&lt;'\\n'; cout&lt;&lt;idx[vl.back()]&lt;&lt;'\\n'; &#125; return 0;&#125; Fascination Street题意简述： 街道上有一排灯，一开始全灭，点亮每盏灯有一定代价，要求最后对于每个位置距离自己不超过 $1$ 的灯至少点亮一盏。除此之外，有 $k$ 次机会交换两盏，问最小代价。 数据范围： $n\\le250000,k\\le9$ 解题思路： 一道比较有意思的亏欠型 $dp$ ，考虑到交换的一定是一盏亮的和一盏灭的，可以定义状态 $f_{i,0/1,0/1,x,y}$ 表示考虑到第 $i$ 盏灯，最后两盏灯的亮灭状态，现在已经换了 $x$ 盏亮的灯， $y$ 盏灭的灯，然后枚举当前灯亮不亮，换不换即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getchartypedef long long ll;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=250005;int n,K,vl[N],cur=0;ll f[2][2][2][10][10],inf;inline void ckmin(ll&amp;x,ll y)&#123;x=x&lt;y?x:y;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); for(ri i=1;i&lt;=n;++i)vl[i]=read(); memset(f[cur=0],0x3f,sizeof(f[0])); inf=f[cur][1][0][0][0],f[cur][1][0][0][0]=0; ll t; for(ri i=0;i&lt;n;++i)&#123; memset(f[cur^1],0x3f,sizeof(f[cur^1])); for(ri j=0;j&lt;2;++j)for(ri k=0;k&lt;2;++k)for(ri a=0;a&lt;=K;++a)for(ri b=0;b&lt;=K;++b)&#123; if(f[cur][j][k][a][b]==inf)continue; t=f[cur][j][k][a][b]; ckmin(f[cur^1][k][1][a][b],t+vl[i+1]); if(j|k)ckmin(f[cur^1][k][0][a][b],t); if(a&lt;K)ckmin(f[cur^1][k][1][a+1][b],t); if(b&lt;K&amp;&amp;(j|k))ckmin(f[cur^1][k][0][a][b+1],t+vl[i+1]); &#125; cur^=1; &#125; ll ans=inf; for(ri i=0;i&lt;2;++i)for(ri j=0;j&lt;2;++j)for(ri k=0;k&lt;=K;++k)if(i|j)ckmin(ans,f[cur][i][j][k][k]); cout&lt;&lt;ans; return 0;&#125; Fractions暴力枚举即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getcharinline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=1e5+5;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif ll a,b,c,d,xl,xr,yl,yr,ans=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; for(ri j,i=1;i&lt;=1000;++i)&#123; j=1; for(;;++j)&#123; if(__gcd(i,j)!=1)continue; if(i+j&gt;=1000)break; xl=a%i?a/i+1:a/i,xr=b/i; yl=c%j?c/j+1:c/j,yr=d/j; if(max(xl,yl)&lt;=min(xr,yr))ans+=min(xr,yr)-max(xl,yl)+1; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; Game on Plane按照题意枚举断边，发现剩下两个成了子问题，于是用 $SG$ 函数即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getcharinline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=5005;int n,a[N],sg[N];bool vis[N];inline void init()&#123; sg[2]=sg[3]=1; for(ri i=4;i&lt;=5000;++i)&#123; memset(vis,0,sizeof(vis)); for(ri j=0;j&lt;=i-2;++j)vis[sg[j]^sg[i-2-j]]=1; for(ri j=0;;++j)if(!vis[j])&#123;sg[i]=j;break;&#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init(); for(ri tt=read();tt;--tt)puts(sg[read()]?\"First\":\"Second\"); return 0;&#125; Histogram Sequence二分+单调栈+堆即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='O'&amp;&amp;ch!='#'&amp;&amp;ch!='.'&amp;&amp;ch!='*')ch=gc(); while(ch=='O'||ch=='#'||ch=='.'||ch=='*')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353,inv2=499122177; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=300005;int n,a[N],pl[N],pr[N],stk[N],tp;ll L,R;inline void init()&#123; stk[tp=1]=pl[1]=1; for(ri i=2;i&lt;=n;++i)&#123; while(tp&amp;&amp;a[stk[tp]]&gt;=a[i])--tp; pl[i]=stk[tp]+1; stk[++tp]=i; &#125; stk[0]=n+1; stk[tp=1]=pr[n]=n; for(ri i=n-1;i;--i)&#123; while(tp&amp;&amp;a[stk[tp]]&gt;a[i])--tp; pr[i]=stk[tp]-1; stk[++tp]=i; &#125;&#125;inline ll calc(ll lm,ll len)&#123; ll s=max(1ll,len-lm+1); return (len+s)*(len-s+1)/2;&#125;inline ll calc(ll lm)&#123; ll res=0; for(ri i=1;i&lt;=n;++i)&#123; if(a[i]&gt;lm)continue; res+=calc(lm/a[i],pr[i]-pl[i]+1)-calc(lm/a[i],pr[i]-i)-calc(lm/a[i],i-pl[i]); &#125; return res;&#125;inline int calc(int p,int l,int r,int len)&#123; return max((r-l+1)-len+1,0ll)-max((r-p)-len+1,0ll)-max((p-l)-len+1,0ll);&#125;struct Node&#123; ll h,w; int id; Node(ll h=0,ll w=0,int id=0):h(h),w(w),id(id)&#123;&#125; friend inline bool operator&lt;(Node a,Node b)&#123;return a.h*a.w&gt;b.h*b.w;&#125;&#125;tmp;signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); L=readl(),R=readl(); init(); ll l=0,r=1e18,res=1e18; while(l&lt;=r)&#123; ll mid=l+r&gt;&gt;1; if(calc(mid)&gt;=L)r=mid-1,res=mid; else l=mid+1; &#125; ll lm=calc(res); while(L&lt;=R&amp;&amp;L&lt;=lm)&#123; ++L; cout&lt;&lt;res&lt;&lt;' '; &#125; priority_queue&lt;Node&gt;q; for(ri i=1;i&lt;=n;++i)q.push(Node(a[i],res/a[i]+1,i)); while(L&lt;=R)&#123; tmp=q.top(); q.pop(); int num=calc(tmp.id,pl[tmp.id],pr[tmp.id],tmp.w); if(!num)continue; while(num&amp;&amp;L&lt;=R)&#123; cout&lt;&lt;tmp.h*tmp.w&lt;&lt;' '; ++L; --num; &#125; ++tmp.w; q.push(tmp); &#125; return 0;&#125; Interesting Drug题意简述： 一条路上按顺序有 $n$ 瓶毒药，对于 $i∈[1,n]$ ，求出如下的值：从 $i$ 出发，每个时刻吃掉当前位置的毒药，然后选择下一步吃左或右的毒药，将每次选择的位置搞成一个排列 $p$ ，其伤害定义为 $\\sum\\limits_{j=1}^nd_j[p_{c_j}=j]$ ，求可能的排列中最大的伤害值。 数据范围： $n\\le3\\times10^5$ 解题思路： 容易看出一个 $dp$ 即 $f_{i,j}$ 表示已经吃掉区间 $[i,j]$ 的毒药到吃完的最大值，这样放到二维平面上每次转移对应向下或者向右走，而由于最多有 $2n$ 条转移边，因此枚举纵坐标，用树状数组修改后缀取 $max$ 和查询前缀 $max$ 即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#define int long long#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,ll&gt; pll;typedef pair&lt;ll,int&gt; pli;typedef unsigned int uii;typedef unsigned long long Ull;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='O'&amp;&amp;ch!='#'&amp;&amp;ch!='.'&amp;&amp;ch!='*')ch=gc(); while(ch=='O'||ch=='#'||ch=='.'||ch=='*')s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353,inv2=499122177; inline int add(int a,int b)&#123;return a+b&lt;mod?a+b:a+b-mod;&#125; inline int dec(int a,int b)&#123;return a-b&lt;0?a-b+mod:a-b;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int a)&#123;return ksm(a,mod-2);&#125; inline void fix(int&amp;a)&#123;a=(a%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmax(T&amp;a,T b)&#123;a&lt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,T b)&#123;a&gt;b?a=b:0;&#125;const int N=3e5+5;int n,c[N],d[N];ll bit[N];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void update(int x,ll v)&#123;for(;x;x^=lowbit(x))ckmax(bit[x],v);&#125;inline ll query(int x)&#123;ll res=0;for(;x&lt;=n;x+=lowbit(x))ckmax(res,bit[x]);return res;&#125;vector&lt;int&gt;ps[N];signed main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; c[i]=read(); if(c[i]!=1&amp;&amp;c[i]&lt;=i)ps[i-c[i]+1].pb(i); &#125; for(ri i=1;i&lt;=n;++i)d[i]=read(); for(ri i=1;i&lt;=n;++i)&#123; for(ri j=(int)ps[i].size()-1;~j;--j) update(ps[i][j]-1,query(ps[i][j])+d[ps[i][j]]); cout&lt;&lt;query(i)+(c[i]==1?d[i]:0)&lt;&lt;' '; if(i+c[i]-1&lt;=n)update(i+c[i]-1,query(i+c[i]-1)+d[i]); &#125; return 0;&#125; $$ --- ## [Timsort](https://codeforces.com/gym/102059/problem/L) 直接暴力即可，复杂度是调和级数 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;#define gc getcharinline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=1e5+5;int n,a[N],f[N][2];pii ans[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); f[n][0]=f[n][1]=1; for(ri i=n-1;i;--i)&#123; f[i][0]=a[i]&lt;=a[i+1]?f[i+1][0]+1:1; f[i][1]=a[i]&gt;a[i+1]?f[i+1][1]+1:1; &#125; for(ri tt=read(),len;tt;--tt)&#123; len=read(); if(ans[len].fi)cout&lt;&lt;ans[len].fi&lt;&lt;' '&lt;&lt;ans[len].se&lt;&lt;'\\n'; else&#123; for(ri t,i=1;i&lt;=n;++i)&#123; ++ans[len].fi; if(f[i][0]&gt;=len)&#123; i+=f[i][0]-1; continue; &#125; if(f[i][1]&gt;=len)&#123; i+=f[i][1]-1; continue; &#125; t=max(f[i][0],f[i][1]); ans[len].se+=min(n-i+1-t,len-t); i+=min(n-i+1,len)-1; &#125; cout&lt;&lt;ans[len].fi&lt;&lt;' '&lt;&lt;ans[len].se&lt;&lt;'\\n'; &#125; &#125; return 0;&#125; Utilitarianism直接用 $wqs$ 二分+简单树形 $dp$ 即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef pair&lt;int,int&gt; pii;typedef long long ll;const int N=250005;int n,k;vector&lt;pii&gt;e[N];struct dat&#123; ll a; int b; dat(ll a=0,int b=0):a(a),b(b)&#123;&#125; friend inline dat operator+(const dat&amp;a,const dat&amp;b)&#123;return dat(a.a+b.a,a.b+b.b);&#125; friend inline dat operator-(const dat&amp;a,const dat&amp;b)&#123;return dat(a.a-b.a,a.b-b.b);&#125; friend inline bool operator&gt;(const dat&amp;a,const dat&amp;b)&#123;return a.a==b.a?a.b&gt;b.b:a.a&gt;b.a;&#125;&#125;f[N][2];inline dat max(const dat&amp;a,const dat&amp;b)&#123;return a&gt;b?a:b;&#125;void dfs(int p,int fa,ll tmp)&#123; f[p][0]=f[p][1]=dat(0,0); for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; dfs(v,p,tmp),f[p][0]=f[p][0]+max(f[v][0],f[v][1]); &#125; ll w; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; w=e[p][i].se+tmp; f[p][1]=max(f[p][1],f[p][0]-max(f[v][0],f[v][1])+f[v][0]+dat(w,1)); &#125;&#125;inline bool check(const double tmp)&#123; dfs(1,0,tmp); dat t=max(f[1][0],f[1][1]); return t.b&gt;=k;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),k=read(); for(ri i=1;i&lt;=n;++i)e[i].clear(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].push_back(pii(v,w)); e[v].push_back(pii(u,w)); &#125; ll L=-1e14,R=1e14,ans=1e14; while(L&lt;R)&#123; ll mid=(L+R+1)/2; if(check(mid))ans=mid,R=mid-1; else L=mid+1; &#125; dfs(1,0,ans); dat t=max(f[1][0],f[1][1]); if(t.b&lt;k)puts(\"Impossible\"); else cout&lt;&lt;(t.a-ans*k)&lt;&lt;'\\n'; return 0;&#125; 总结： 我 $dp$ 不过关 我$图论$不过关 我$英语$不过关","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"2019.10.15 模拟测试题解","slug":"191015test","date":"2019-10-15T13:13:46.000Z","updated":"2019-10-16T00:46:52.914Z","comments":true,"path":"191015test/","link":"","permalink":"http://ldxcaicai.github.io/191015test/","excerpt":"","text":"题目来源： $A: CF643D$ $B:TCO\\ BearDestroy$ A题意简述： 给你一个有向基环森林，每个点有一个后继，然后对于一个点会给出一个 $ vl_i $ ，定义 $ E_i=\\frac{vl_i}{i入度+i出度+1},res_i=vl_i\\%E_i+\\sum\\limits_{dist(i,v)\\le 1}E_v $ 要求支持如下操作： 修改一个点的后继 问一个点的 $res$ 查询全局 $res$ 的最值 数据范围: $n\\le100000$ $m\\le100000$ 解题思路： 考虑用可删堆维护全局询问，然后对每个点记一个 $delta$ 表示它对前驱的影响，然后就变成了模拟题 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;bits/stdc++.h&gt;#define ri register int#define csi const int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;&#125;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=1e5+5;int du[N],n,m,a[N];ll det[N],vl[N],E[N],res[N];struct Set1&#123; priority_queue&lt;ll&gt;a,b; inline void ins(ll x)&#123;a.push(x);&#125; inline void del(ll x)&#123;b.push(x);&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline ll top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125; inline int size()const&#123;return a.size()-b.size();&#125;&#125;Mx[N],Ansmx;struct Set2&#123; priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt;a,b; inline void ins(ll x)&#123;a.push(x);&#125; inline void del(ll x)&#123;b.push(x);&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline ll top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125; inline int size()const&#123;return a.size()-b.size();&#125;&#125;Mn[N],Ansmn;int main()&#123; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)vl[i]=readl(); for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); ++du[i],++du[a[i]]; &#125; for(ri i=1;i&lt;=n;++i)E[i]=vl[i]/(du[i]+1); for(ri i=1;i&lt;=n;++i)&#123; res[a[i]]+=E[i]-E[a[i]]; res[i]+=E[a[i]]-E[i]; res[i]+=vl[i]; &#125; for(ri i=1;i&lt;=n;++i)&#123; Mn[a[i]].ins(res[i]); Mx[a[i]].ins(res[i]); &#125; for(ri i=1;i&lt;=n;++i)&#123; if(Mx[i].size())Ansmx.ins(Mx[i].top()); if(Mn[i].size())Ansmn.ins(Mn[i].top()); &#125; ll dt; for(ri p,fp,ffp,x,y,op;m;--m)&#123; op=read(); if(op==1)&#123; x=read(),y=read(); p=a[x],fp=a[p],ffp=a[fp]; Ansmx.del(Mx[p].top()+det[p]); Ansmn.del(Mn[p].top()+det[p]); dt=vl[p]/du[p]-vl[p]/(du[p]+1); Mx[p].del(res[x]); Mn[p].del(res[x]); res[x]+=det[p]-E[p]; det[p]+=dt; if(Mx[p].size())Ansmx.ins(Mx[p].top()+det[p]); if(Mn[p].size())Ansmn.ins(Mn[p].top()+det[p]); Ansmx.del(Mx[fp].top()+det[fp]); Ansmn.del(Mn[fp].top()+det[fp]); Mx[fp].del(res[p]); Mn[fp].del(res[p]); res[p]-=dt*(du[p]-1); res[p]-=E[x]-E[p]; E[p]+=dt; Mx[fp].ins(res[p]); Mn[fp].ins(res[p]); Ansmx.ins(Mx[fp].top()+det[fp]); Ansmn.ins(Mn[fp].top()+det[fp]); Ansmx.del(Mx[ffp].top()+det[ffp]); Ansmn.del(Mn[ffp].top()+det[ffp]); Mx[ffp].del(res[fp]); Mn[ffp].del(res[fp]); res[fp]+=dt; Mx[ffp].ins(res[fp]); Mn[ffp].ins(res[fp]); Ansmx.ins(Mx[ffp].top()+det[ffp]); Ansmn.ins(Mn[ffp].top()+det[ffp]); --du[p]; a[x]=y; p=a[x],fp=a[p],ffp=a[fp]; if(Mx[p].size())Ansmx.del(Mx[p].top()+det[p]); if(Mn[p].size())Ansmn.del(Mn[p].top()+det[p]); dt=vl[p]/(du[p]+2)-vl[p]/(du[p]+1); det[p]+=dt; E[p]+=dt; res[x]-=det[p]-E[p]; Mx[p].ins(res[x]); Mn[p].ins(res[x]); Ansmx.ins(Mx[p].top()+det[p]); Ansmn.ins(Mn[p].top()+det[p]); Ansmx.del(Mx[fp].top()+det[fp]); Ansmn.del(Mn[fp].top()+det[fp]); Mx[fp].del(res[p]); Mn[fp].del(res[p]); res[p]-=dt*du[p]; res[p]+=E[x]-E[p]; Mx[fp].ins(res[p]); Mn[fp].ins(res[p]); Ansmx.ins(Mx[fp].top()+det[fp]); Ansmn.ins(Mn[fp].top()+det[fp]); Ansmx.del(Mx[ffp].top()+det[ffp]); Ansmn.del(Mn[ffp].top()+det[ffp]); Mx[ffp].del(res[fp]); Mn[ffp].del(res[fp]); res[fp]+=dt; Mx[ffp].ins(res[fp]); Mn[ffp].ins(res[fp]); Ansmx.ins(Mx[ffp].top()+det[ffp]); Ansmn.ins(Mn[ffp].top()+det[ffp]); ++du[p]; &#125; else if(op==2)&#123; x=read(); cout&lt;&lt;(res[x]+det[a[x]])&lt;&lt;'\\n'; &#125; else cout&lt;&lt;Ansmn.top()&lt;&lt;' '&lt;&lt;Ansmx.top()&lt;&lt;'\\n'; &#125; return 0;&#125; B题意简述： 给一个 $n×m$ 的方格图,每个格子填上E或者S，一个人从 $(0,0)$ 开始按行优先行动，每次到一个格子 $(i,j)$ 就执行以下操作： 如果该格子已经放置了骨牌,那么不操作 若该格子没有放置骨牌且该格子写的是E，那么优先放一块 $1×2$ 的骨牌，不行就放一块 $2×1$ 的骨牌，再不行就不操作 若该格子没有放置骨牌且该格子写的是S，那么优先放一块 $2×1$ 的骨牌，不行就放一块 $1×2$ 的骨牌，再不行就不操作 一个图的得分为放置的骨牌数量,求 $2^{n×m}$ 种图的得分的和对MOD取余 数据范围： $n\\le12$ $m\\le30$ 解题思路： 考虑每个骨牌要么覆盖 $(i,j),(i,j+1)$ ，要么覆盖 $(i,j),(i+1,j)$ ，那么如果按照对角线分层的话这显然是一个分层图 $dp$ ，这样就可以设 $f_{i,j}$ 表示第 $i$ 层状态为 $j$ 的答案，然后就可以用状压 $dp$ 的思想转移了（实质上这个地方利用的是插头 $dp$ 的想法 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:0;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;int n,m,lm;#define getsta(x,y) ((x)&gt;&gt;((y)-1)&amp;1)#define sub(x) (1&lt;&lt;((x)-1))#define trans0 cf,cg,f,g#define trans1 add(cf,cf),add(cg,cg),f,g#define trans2 add(cf,cf),add(add(cf,cf),add(cg,cg)),f,g#define trans3 cf,add(cf,cg),f,ginline void update(int ps,int s1,int s2,int cf,int cg,vi&amp;f,vi&amp;g)&#123; if(ps==n+1)&#123; Add(f[s2],cf); Add(g[s2],cg); return; &#125; if(lm-ps&lt;0||lm-ps+1&gt;m)return update(ps+1,s1,s2,trans0); if(getsta(s1,ps))return update(ps+1,s1,s2,trans1); if(lm-ps+1==m||getsta(s2,ps))&#123; if(ps==n)update(ps+1,s1,s2,trans1); else update(ps+1,s1|sub(ps),s2|sub(ps+1),trans2); &#125; else&#123; if(ps==n)update(ps+1,s1|sub(ps),s2|sub(ps),trans2); else&#123; update(ps+1,s1|sub(ps),s2|sub(ps),trans3); update(ps+1,s1|sub(ps),s2|sub(ps+1),trans3); &#125; &#125;&#125;#undef sub#undef trans0#undef trans1#undef trans2#undef getstainline int solve()&#123; vii f(n+m+1),g(n+m+1); int all=1&lt;&lt;n; f[1].resize(all),g[1].resize(all); f[1][0]=1,g[1][0]=0; for(ri dep=1;dep&lt;n+m;++dep)&#123; lm=dep; f[dep+1].resize(all); g[dep+1].resize(all); for(ri sta=0;sta&lt;all;++sta) update(1,sta,0,f[dep][sta],g[dep][sta],f[dep+1],g[dep+1]); &#125; return g[n+m][0];&#125;class BearDestroys&#123; public: inline int sumUp(int n_,int m_,int mod_)&#123; mod=mod_,n=n_,m=m_; return solve(); &#125;&#125;; C题意简述： 有 $n$ 种不同的果汁，第 $i$ 种有 $c_i$ 升。现在要将所有果汁放进 $m$ 个瓶子里，满足每个瓶子里不超过两种果汁且所有瓶子装的果汁量一样，问 $m$ 最小值，(果汁量允许为分数 数据范围： $n\\le20$ $c_i\\le10^9$ 解题思路： 先考虑答案的上界，容易发现是 $n-1$ ，（可以通过归纳法证明一定存在 $n-1$ 个瓶子的合法方案)，然后假设现在一个瓶子中有两种果汁 $a,b$ ，我们在 $a,b$ 中连上一条边，假设答案为 $m$ ，那么一定会将 $n$ 个点分成至少 $n-m$ 个连通块，这样相当于可以枚举 $m$ 然后递归成子问题，对于一个 $n’$ 个点的点集如果其可以被分到 $n’-1$ 个瓶子里那么就是合法的，于是就能够枚举子集转移，复杂度$O(3^n*n)$ ，当然可以用子集卷积继续优化但是由于数据不强因此懒得写了~ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; vi;typedef vector&lt;vector&lt;int&gt; &gt; vii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:0;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int Inv(int x)&#123;return ksm(x,mod-2);&#125; inline void fix(int&amp;x)&#123;x=(x%mod+mod)%mod;&#125;&#125;using namespace modular;template&lt;typename T&gt;inline void ckmin(T&amp;a,const T&amp;b)&#123;a&gt;b?a=b:0;&#125;template&lt;typename T&gt;inline void ckmax(T&amp;a,const T&amp;b)&#123;a&lt;b?a=b:0;&#125;const int N=25;int n,vl[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int all=1&lt;&lt;n; vi ct(all),id(all); vector&lt;ll&gt;ss(all); if(n&lt;=2)return puts(\"1\"),0; for(ri i=1;i&lt;=n;++i)id[1&lt;&lt;(i-1)]=i,vl[i]=read(); for(ri i=1;i&lt;all;++i)&#123; ct[i]=ct[i^(i&amp;-i)]+1; ss[i]=ss[i^(i&amp;-i)]+vl[id[i&amp;-i]]; &#125; for(ri i=n+1&gt;&gt;1;i&lt;n-1;++i)&#123; bool ff=0,tg; int s=all-1; while(1)&#123; tg=0; if((ll)ss[all-1]*(ct[s]-1)==(ll)ss[s]*i)&#123; ff=1; break; &#125; for(ri t=s;t;t=(t-1)&amp;s) if((ll)ss[all-1]*(ct[t]-1)==(ll)ss[t]*i)&#123; tg=1; s^=t; break; &#125; if(!tg)break; &#125; if(ff)&#123; cout&lt;&lt;i; return 0; &#125; &#125; cout&lt;&lt;n-1; return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://ldxcaicai.github.io/tags/考试题解/"}]},{"title":"CodeForces 1244 简要题解","slug":"CF1244","date":"2019-10-14T08:59:39.000Z","updated":"2019-10-22T23:48:31.189Z","comments":true,"path":"CF1244/","link":"","permalink":"http://ldxcaicai.github.io/CF1244/","excerpt":"","text":"A模拟 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; int a=read(),b=read(),c=read(),d=read(),k=read(); int res=a%c?a/c+1:a/c,ress=b%d?b/d+1:b/d; if(res+ress&gt;k)puts(\"-1\"); else cout&lt;&lt;res&lt;&lt;' '&lt;&lt;ress&lt;&lt;'\\n'; &#125; return 0;&#125; B简单贪心 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1005;char s[N];int n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(); Read(s); int ans=n,sum=n; for(ri i=1;i&lt;=n;++i)&#123; if(s[i]=='1')&#123; ++sum; ans=max(ans,i*2); ans=max(ans,(n-i+1)*2); &#125; &#125; ans=max(ans,sum); cout&lt;&lt;ans&lt;&lt;'\\n'; &#125; return 0;&#125; C$exgcd$ 板题 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1005;ll n,p,d,w;inline void exgcd(ll a,ll b,ll&amp;x,ll&amp;y)&#123; if(!b)&#123; x=1; y=0; return; &#125; exgcd(b,a%b,x,y); ll t=x; x=y,y=t-a/b*y;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=1;tt;--tt)&#123; n=readl(),p=readl(),w=readl(),d=readl(); ll g=__gcd(d,w); if(p%g)&#123; puts(\"-1\"); continue; &#125; p/=g,d/=g,w/=g; ll x,y; exgcd(w,d,x,y); y=(y%w+w)%w; y=y*(p%w)%w; x=(p-d*y)/w; if(x&lt;0)&#123; puts(\"-1\"); continue; &#125; if(n-x-y&lt;0)&#123; puts(\"-1\"); continue; &#125; cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;' '&lt;&lt;n-x-y&lt;&lt;'\\n'; &#125; return 0;&#125; D合法情况一定是条链 貌似直接枚举左端的颜色其余颜色就固定了 但也可以强行 $dp$ 好好的确是我比赛的时候被降智了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=100005;int n,vl[N][4],q[N],hd,tl,vs[N],col[N];ll f[N][4][4];pii pre[N][4][4];vector&lt;int&gt;e[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=3;++i)for(ri j=1;j&lt;=n;++j)vl[j][i]=read(); for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; for(ri i=1;i&lt;=n;++i)if(e[i].size()&gt;2)return puts(\"-1\"),0; for(ri i=1;i&lt;=n;++i)&#123; if(e[i].size()==1)&#123; q[hd=tl=1]=i; break; &#125; &#125; while(hd&lt;=tl)&#123; int x=q[hd++]; vs[x]=1; for(ri i=0,v;i&lt;e[x].size();++i)&#123; if(vs[v=e[x][i]])continue; q[++tl]=v; &#125; &#125; memset(f,0x3f,sizeof(f)); for(ri i=1;i&lt;=3;++i)for(ri j=1;j&lt;=3;++j)if(i!=j)f[1][i][j]=vl[q[1]][j]; for(ri i=2;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=3;++j)&#123; for(ri k=1;k&lt;=3;++k)&#123; for(ri l=1;l&lt;=3;++l)&#123; if(j!=k&amp;&amp;k!=l&amp;&amp;j!=l)&#123; if(f[i-1][l][j]+vl[q[i]][k]&lt;f[i][j][k])&#123; f[i][j][k]=f[i-1][l][j]+vl[q[i]][k]; pre[i][j][k]=pii(l,j); &#125; &#125; &#125; &#125; &#125; &#125; ll res=1e18; pii las; for(ri i=1;i&lt;=3;++i)for(ri j=1;j&lt;=3;++j)&#123; if(i!=j)if(f[n][i][j]&lt;res)&#123; res=f[n][i][j]; las=pii(i,j); &#125; &#125; int ps=n; while(ps)&#123; col[q[ps]]=las.se; las=pre[ps][las.fi][las.se]; --ps; &#125; cout&lt;&lt;res&lt;&lt;'\\n'; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;col[i]&lt;&lt;' '; return 0;&#125; E先把数组排序，然后处理一下前后缀就能上双指针了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=100005;int n,a[N],b[N],sig,pre[N],suf[N];ll Pre[N],Suf[N],pvl[N],svl[N];ll K;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); K=readl(); for(ri i=1;i&lt;=n;++i)a[i]=read(); sort(a+1,a+n+1); sig=0; for(ri i=1;i&lt;=n;++i)&#123; if(a[i]!=a[i-1])a[++sig]=a[i],b[sig]=1; else ++b[sig]; &#125; for(ri i=1;i&lt;=sig;++i)pre[i]=pre[i-1]+b[i],Pre[i]=Pre[i-1]+(ll)b[i]*a[i],pvl[i]=(ll)pre[i]*a[i]-Pre[i]; for(ri i=sig;i;--i)suf[i]=suf[i+1]+b[i],Suf[i]=Suf[i+1]+(ll)b[i]*a[i],svl[i]=(ll)Suf[i]-(ll)suf[i]*a[i]; ll res=a[sig]-a[1]; for(ri ps1=1,ps2=1;ps1&lt;=sig;++ps1)&#123; while(ps2&lt;=sig&amp;&amp;pvl[ps1]+svl[ps2]&gt;K)++ps2; if(ps2&gt;sig)break; if(ps1&gt;=ps2)return puts(\"0\"),0; res=min(res,a[ps2]-a[ps1]-(K-pvl[ps1]-svl[ps2])/suf[ps2]); &#125; for(ri ps1=sig,ps2=sig;ps2;--ps2)&#123; while(ps1&amp;&amp;pvl[ps1]+svl[ps2]&gt;K)--ps1; if(!ps1)break; if(ps1&gt;=ps2)return puts(\"0\"),0; res=min(res,a[ps2]-a[ps1]-(K-pvl[ps1]-svl[ps2])/pre[ps1]); &#125; cout&lt;&lt;res; return 0;&#125; F随便找个规律就行了，然后分奇偶讨论一下 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=6e5+5;int n,k;char s[N];inline void check1()&#123; if(n&amp;1)return; for(ri i=2;i&lt;=n;++i)if(s[i]==s[i-1])return; k&amp;=1; for(ri i=1;i&lt;=n;++i)&#123; if(k==1)&#123; if(s[i]=='W')cout&lt;&lt;'B'; else cout&lt;&lt;'W'; &#125; else cout&lt;&lt;s[i]; &#125; exit(0);&#125;inline void check2()&#123; for(ri i=2;i&lt;=n;++i)if(s[i]!=s[i-1])return; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;s[i]; exit(0);&#125;bool ban[N];char res[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),k=read(); Read(s); check1(); check2(); for(ri i=1;i&lt;=n;++i)s[i+n]=s[i+n*2]=s[i]; int st; for(ri i=1;i&lt;=n;++i)&#123; if(s[i]==s[i+1])&#123; st=i; break; &#125; &#125; int mid,L=st,R=st+n-1,l,r; for(l=L;l&lt;=R;l=r+1)&#123; r=l; while(r&lt;R&amp;&amp;s[r+1]==s[r])++r; if(r==R)break; mid=r; while(r&lt;=R&amp;&amp;s[r+1]!=s[r])++r; --r; if(mid==r)continue; if(r-mid&lt;=k*2)for(ri p1=mid+1,p2=r;p1&lt;=p2;++p1,--p2)&#123; s[p1]=s[l],s[p2]=s[r+1]; &#125; else&#123; int p1,p2,i; for(p1=mid+1,p2=r,i=1;i&lt;=k;++i,++p1,--p2)&#123; s[p1]=s[l],s[p2]=s[r+1]; &#125; if(k&amp;1)for(ri i=p1;i&lt;=p2;++i)s[i]=s[i]=='B'?'W':'B'; &#125; &#125; for(ri i=L;i&lt;=R;++i)&#123; if(i&gt;n)s[i-n]=s[i]; &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;s[i]; return 0;&#125; G随便贪个心就过了，证明很简单（虽然我直接瞎贪的但后来 $cyktxdy$ 跟我说了一个证明方法感觉还挺 $naiive$ 的 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1e6+5;int n;ll K;#define lc (p&lt;&lt;1)#define rc (p&lt;&lt;1|1)#define mid (l+r&gt;&gt;1)int siz[N&lt;&lt;2];inline void build(int p,int l,int r)&#123; siz[p]=r-l+1; if(l==r)return; build(lc,l,mid),build(rc,mid+1,r);&#125;inline int query(int p,int l,int r)&#123; if(!siz[p])return -1; if(l==r)return l; return siz[lc]?query(lc,l,mid):query(rc,mid+1,r);&#125;inline void update(int p,int l,int r,int k)&#123; if(l==r)&#123; siz[p]=0; return; &#125; k&lt;=mid?update(lc,l,mid,k):update(rc,mid+1,r,k); siz[p]=siz[lc]+siz[rc];&#125;inline int query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return query(p,l,r); if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); int res=query(lc,l,mid,ql,qr); if(~res)return res; return query(rc,mid+1,r,ql,qr); &#125;#undef lc#undef rc#undef midint ans[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); K=readl(); ll ss=0; if(K&lt;(ll)n*(n+1)/2)return puts(\"-1\"),0; ll T=K; K-=(ll)n*(n+1)/2; build(1,1,n); for(ri i=n;i;--i)&#123; int ql=max(1ll,i-K),qr=i; int x=query(1,1,n,ql,qr); if(~x)ans[x]=i,K-=i-x; else ans[x=query(1,1,n,qr+1,n)]=i; update(1,1,n,x); &#125; cout&lt;&lt;T-K&lt;&lt;'\\n'; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;i&lt;&lt;' '; puts(\"\"); for(ri i=1;i&lt;=n;++i)cout&lt;&lt;ans[i]&lt;&lt;' '; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"LibreOJ NOI Round2 Day1 简要题解","slug":"LNRR2D1","date":"2019-10-14T08:41:11.000Z","updated":"2019-10-14T08:54:13.697Z","comments":true,"path":"LNRR2D1/","link":"","permalink":"http://ldxcaicai.github.io/LNRR2D1/","excerpt":"","text":"A容易发现原题中的运算可以用矩阵完成 $O(n)$ 维护矩阵和逆矩阵即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch; return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; inline int findInv(int a)&#123;return ksm(a,mod-2);&#125;&#125;using namespace modular;const int N=1e6+5;vector&lt;int&gt;e[N];struct Mat&#123; int a[2][2]; inline int*operator[](const int&amp;k)&#123;return a[k];&#125; Mat()&#123;a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;&#125; Mat(int x,int typ)&#123; typ==0? (a[0][0]=x,a[0][1]=1,a[1][0]=1,a[1][1]=0): (a[0][0]=0,a[0][1]=1,a[1][0]=1,a[1][1]=x?mod-x:0); &#125; friend inline Mat operator+(Mat a,Mat b)&#123; Mat ret; ret[0][0]=((ll)a[0][0]*b[0][0]+(ll)a[0][1]*b[1][0])%mod; ret[0][1]=((ll)a[0][0]*b[0][1]+(ll)a[0][1]*b[1][1])%mod; ret[1][0]=((ll)a[1][0]*b[0][0]+(ll)a[1][1]*b[1][0])%mod; ret[1][1]=((ll)a[1][0]*b[0][1]+(ll)a[1][1]*b[1][1])%mod; return ret; &#125;&#125;pre[N][2];int n,m,opt,a[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),opt=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); pre[0][0]=Mat(0,0),pre[0][1]=Mat(0,1); for(ri i=1;i&lt;=n;++i)&#123; pre[i][0]=pre[i-1][0]+Mat(a[i],0); pre[i][1]=Mat(a[i],1)+pre[i-1][1]; &#125; for(ri ansx=0,ansy=0,op,l,r,i=1;i&lt;=m;++i)&#123; op=read(); if(op==1)&#123; a[++n]=read()^ansx^ansy; pre[n][0]=pre[n-1][0]+Mat(a[n],0); pre[n][1]=Mat(a[n],1)+pre[n-1][1]; &#125; else&#123; l=read()^ansx^ansy,r=read()^ansx^ansy; Mat coe=pre[l-1][1]+pre[r-1][0]; ansx=((ll)coe[0][0]*a[r]+coe[0][1])%mod; cout&lt;&lt;ansx&lt;&lt;' '; ansy=((ll)coe[1][0]*a[r]+coe[1][1])%mod; cout&lt;&lt;ansy&lt;&lt;'\\n'; &#125; ansx*=opt; ansy*=opt; &#125; return 0;&#125; B容易想到费用流做法，然后发现可以用 $HLD$ +贪心模拟费用流来解决掉先出现所有金矿的数据点 下面将金矿成为洞，矿工称为老鼠 考虑用线段树分治来将问题转化成上述情况，考虑对每个洞建一个虚的老鼠进行匹配，使得代价和为一个确定的极大值 $inf$ ，然后给原本放洞的地方建一个虚儿子 $x$ ，将这个洞和老鼠都放入 $x$ 即可，正确性显然 然后将 $HLD$ +线段树换成全局平衡二叉树即可，复杂度 $O(n\\log^2 n)$ 然后我和cyk两个人一起卡常数卡了一下午没卡过去，只能 $96pts$ 滚了，提出这个算法的用户hychyc的ac代码貌似放宽了时限才过掉了最后一个点，我本地测了一下他最后一个点比我慢7s 留个链分治的坑以后来填吧 96ptsCODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=2e5+5;int n,m,dist[N];vector&lt;pii&gt;e[N];int siz[N],dep[N],dis[N],fa[N],top[N],bot[N],num[N],hson[N],pred[N],tot=0;void dfs1(int p)&#123; siz[p]=1; for(ri i=0,v;i&lt;(int)e[p].size();++i)&#123; v=e[p][i].fi,fa[v]=p; dis[v]=dis[p]+e[p][i].se; dep[v]=dep[p]+1,dfs1(v); siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]])hson[p]=v; &#125;&#125;void dfs2(int p,int tp)&#123; top[p]=tp,pred[num[p]=++tot]=p; if(!hson[p])&#123; bot[p]=p; return; &#125; dfs2(hson[p],tp),bot[p]=bot[hson[p]]; for(ri i=0,v;i&lt;(int)e[p].size();++i)&#123; if((v=e[p][i].fi)==hson[p])continue; dfs2(v,v); &#125;&#125;const int inf=1e9;struct Set&#123; priority_queue&lt;ll&gt;a,b; inline void ins(int x)&#123;a.push(x);&#125; inline void del(int x)&#123;b.push(x);&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline int size()const&#123;return a.size()-b.size();&#125; inline int top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125;&#125;S[N];namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) int M; pii mx[1&lt;&lt;20|5]; inline void build(int n)&#123; for(M=1;M&lt;=n+1;M&lt;&lt;=1); for(ri i=1;i&lt;=M*2-1;++i)mx[i]=pii(-inf,-inf); for(ri i=1;i&lt;=n;++i)mx[i+M]=pii(-inf,pred[i]); for(ri p=M-1;p;--p)mx[p]=max(mx[lc],mx[rc]); cerr&lt;&lt;mx[1].fi&lt;&lt;' '&lt;&lt;mx[1].se&lt;&lt;'\\n'; &#125; inline void update(int p,int vl)&#123; mx[p+=M].fi=vl; for(p&gt;&gt;=1;p;p&gt;&gt;=1)mx[p]=max(mx[lc],mx[rc]); &#125; inline pii query(int l,int r)&#123; pii res=mx[l+M]; for(l+=M-1,r+=M+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1)&#123; if(l&amp;1^1)res=max(res,mx[l^1]); if(r&amp;1)res=max(res,mx[r^1]); &#125; if(!res.se)&#123; cerr&lt;&lt;res.fi&lt;&lt;'\\n'; &#125; return res; &#125; #undef lc #undef rc #undef mid&#125;//namespace sgt&#123;// #define lc (p&lt;&lt;1)// #define rc (p&lt;&lt;1|1)// #define mid (l+r&gt;&gt;1)// pli mx[N&lt;&lt;2];// inline void build(int p,int l,int r)&#123;// if(l==r)&#123;// mx[p]=pli(-inf,pred[l]);// return;// &#125;// build(lc,l,mid),build(rc,mid+1,r);// mx[p]=max(mx[lc],mx[rc]);// &#125;// inline void update(int p,int l,int r,int k,ll vl)&#123;// if(l==r)&#123;// mx[p].fi=vl;// return;// &#125;// k&lt;=mid?update(lc,l,mid,k,vl):update(rc,mid+1,r,k,vl);// mx[p]=max(mx[lc],mx[rc]);// &#125;// inline pli query(int p,int l,int r,int ql,int qr)&#123;// if(ql&lt;=l&amp;&amp;r&lt;=qr)return mx[p];// if(qr&lt;=mid)return query(lc,l,mid,ql,qr);// if(ql&gt;mid)return query(rc,mid+1,r,ql,qr);// return max(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr));// &#125;// #undef lc// #undef rc// #undef mid//&#125;inline pii operator+(pii a,pii b)&#123; if(a.fi!=b.fi)return min(a,b); return dep[a.se]&gt;dep[b.se]?a:b;&#125;namespace bst&#123; #define lc (son[p][0]) #define rc (son[p][1]) int ft[N],tg[N&lt;&lt;2],son[N][2]; pii vl[N&lt;&lt;2],mn[N&lt;&lt;2]; inline void pushup(int p)&#123; if(lc&amp;&amp;rc)mn[p]=mn[lc]+vl[p]+mn[rc]; else if(lc)mn[p]=mn[lc]+vl[p]; else if(rc)mn[p]=vl[p]+mn[rc]; else mn[p]=vl[p]; &#125; inline bool isroot(int x)&#123;return !ft[x]||(son[ft[x]][0]!=x&amp;&amp;son[ft[x]][1]!=x);&#125; inline void pushnow(int x,int v)&#123;vl[x].fi+=v,mn[x].fi+=v,tg[x]+=v;&#125; inline void pushdown(int p)&#123; if(tg[p])&#123; if(lc)pushnow(lc,tg[p]); if(rc)pushnow(rc,tg[p]); tg[p]=0; &#125; &#125; inline int build(int l,int r,int dt=0)&#123; if(l&gt;r)return 0; if(l==r)return pred[l]; for(ri p,i=r;i&gt;=l;--i)&#123; if(siz[pred[i]]*2&gt;=siz[pred[l]]+dt)&#123; p=pred[i]; lc=build(l,i-1,siz[p]); rc=build(i+1,r,dt); ft[lc]=ft[rc]=p; pushup(p); return p; &#125; &#125; &#125; inline int build(int p)&#123; for(ri x=p;x;x=hson[x])&#123; vl[x]=mn[x]=pii(0,x); for(ri i=0,v;i&lt;(int)e[x].size();++i) if((v=e[x][i].fi)!=hson[x])ft[build(v)]=x; &#125; return build(num[p],num[bot[p]]); &#125; int Stk[N],Tp; inline void update(int p,int v)&#123; while(p)&#123; Stk[Tp=1]=p; for(ri x=p;!isroot(x);x=ft[x])Stk[++Tp]=ft[x]; while(Tp)pushdown(Stk[Tp--]); vl[p].fi+=v; if(lc)pushnow(lc,v); pushup(p); while(!isroot(p))&#123; if(son[ft[p]][1]==p)&#123; vl[ft[p]].fi+=v; if(son[ft[p]][0])pushnow(son[ft[p]][0],v); &#125; p=ft[p]; pushup(p); &#125; p=ft[p]; &#125; &#125; inline pii query(int p)&#123; pii res=pii(inf,0); while(p)&#123; Stk[Tp=1]=p; for(ri x=p;!isroot(x);x=ft[x])Stk[++Tp]=ft[x]; while(Tp)pushdown(Stk[Tp--]); res=res+vl[p]; if(lc)res=res+mn[lc]; while(!isroot(p))&#123; if(son[ft[p]][1]==p)&#123; res=res+vl[ft[p]]; if(son[ft[p]][0])res=res+mn[son[ft[p]][0]]; &#125; p=ft[p]; &#125; p=ft[p]; &#125; return res; &#125; int Dep[N]; inline int querydep(int x)&#123; if(!ft[x])return Dep[x]=1; if(Dep[x])return Dep[x]; return Dep[x]=querydep(ft[x])+1; &#125; #undef lc #undef rc&#125;int rt,suf[N];struct Qry&#123;int op,id,vl;&#125;qry[N];bool vs[N];#define lc (p&lt;&lt;1)#define rc (p&lt;&lt;1|1)#define mid (l+r&gt;&gt;1)vector&lt;pii&gt;upd[N&lt;&lt;2];inline void update(int p,int l,int r,int ql,int qr,pii v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return upd[p].pb(v); if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v);&#125;ll ss=0,curss;struct node&#123; int op,id,vl; node()&#123;op=id=vl=0;&#125; node(int op,int id,ll vl):op(op),id(id),vl(vl)&#123;&#125;&#125;;vector&lt;node&gt;stk;inline void change(pii F)&#123; pii tp=bst::query(F.se); int p=tp.fi&gt;0?rt:tp.se; //pli tp=sgt::query(1,1,n,num[p],num[p]+siz[p]-1); tp=sgt::query(num[p],num[p]+siz[p]-1); if(tp.fi+F.fi&lt;=0)return; ss+=tp.fi+F.fi; S[F.se].ins(-F.fi); //sgt::update(1,1,n,num[F.se],S[F.se].top()); sgt::update(num[F.se],S[F.se].top()); bst::update(F.se,-1); stk.pb(node(1,F.se,-F.fi)); stk.pb(node(3,F.se,1)); S[tp.se].del(tp.fi); //sgt::update(1,1,n,num[tp.se],S[tp.se].top()); sgt::update(num[tp.se],S[tp.se].top()); bst::update(tp.se,1); stk.pb(node(2,tp.se,tp.fi)); stk.pb(node(3,tp.se,-1));&#125;inline void Pop()&#123; node t=stk.back(); stk.pop_back(); if(t.op==1)&#123; S[t.id].del(t.vl); //sgt::update(1,1,n,num[t.id],S[t.id].top()); sgt::update(num[t.id],S[t.id].top()); &#125; if(t.op==2)&#123; S[t.id].ins(t.vl); //sgt::update(1,1,n,num[t.id],S[t.id].top()); sgt::update(num[t.id],S[t.id].top()); &#125; if(t.op==3)bst::update(t.id,t.vl);&#125;inline void solve(int p,int l,int r)&#123; int sz=stk.size(); ll curss=ss; for(ri i=(int)upd[p].size()-1;~i;--i)change(upd[p][i]); if(l==r)cout&lt;&lt;ss-(ll)suf[l]*inf&lt;&lt;'\\n'; else solve(lc,l,mid),solve(rc,mid+1,r); while(stk.size()!=sz)Pop(); ss=curss;&#125;#undef lc#undef rc#undef midsigned main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); freopen(\"std.out\",\"w\",stdout); #endif int tt=clock(); n=read(),m=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); vs[v]=1; e[u].pb(pii(v,w)); &#125; for(ri i=1;i&lt;=n;++i)if(!vs[i])&#123; rt=i; break; &#125; for(ri i=1;i&lt;=m;++i)&#123; qry[i].op=read(); qry[i].id=read(); qry[i].vl=read(); if(qry[i].op==2)&#123; ++n; e[qry[i].id].pb(pii(n,0)); qry[i].id=n; &#125; &#125; for(ri i=1;i&lt;=n;++i)S[i].ins(-inf); dep[rt]=1; dfs1(rt); dfs2(rt,rt); //sgt::build(1,1,n); sgt::build(n); bst::build(rt); int mxdep=0; for(ri i=1;i&lt;=n;++i)mxdep=max(mxdep,bst::querydep(i)); for(ri i=1;i&lt;=m;++i)&#123; if(qry[i].op==1)&#123; qry[i].vl-=dis[qry[i].id]; update(1,1,m,i,m,pii(qry[i].vl,qry[i].id)); &#125; else&#123; qry[i].vl+=dis[qry[i].id]; if(i!=1)update(1,1,m,1,i-1,pii(inf-qry[i].vl,qry[i].id)); S[qry[i].id].ins(qry[i].vl); //sgt::update(1,1,n,num[qry[i].id],S[qry[i].id].top()); sgt::update(num[qry[i].id],S[qry[i].id].top()); &#125; &#125; suf[m]=0; for(ri i=m-1;i;--i)suf[i]=suf[i+1]+(qry[i+1].op==2); solve(1,1,m); return 0;&#125; C一个比较套路化的容斥，基本上跟 $PE$ 的 $permuted\\ matrices$ 是一样的，就不细讲了 然后要加上一个分治 $ntt$ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(int*s)&#123; int top=0; char ch=gc(); while(ch!='&lt;'&amp;&amp;ch!='&gt;')ch=gc(); while(ch=='&lt;'||ch=='&gt;')s[++top]=ch=='&gt;',ch=gc(); return top;&#125;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int lim,tim,w[22],invv[22];vector&lt;int&gt;rev[22];inline void init_ntt()&#123; invv[0]=1; for(ri iv=mod+1&gt;&gt;1,i=1;i&lt;22;++i)invv[i]=mul(invv[i-1],iv); w[21]=ksm(3,(mod-1)&gt;&gt;22); for(ri i=20;~i;--i)w[i]=mul(w[i+1],w[i+1]);&#125;inline void init(const int&amp;up)&#123; lim=1,tim=0; while(lim&lt;up)lim&lt;&lt;=1,++tim; if(rev[tim].size())return; rev[tim].resize(lim); for(ri i=1;i&lt;lim;++i)rev[tim][i]=(rev[tim][i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(tim-1));&#125;inline void ntt(poly&amp;a,int typ)&#123; for(ri i=0;i&lt;lim;++i)if(i&lt;rev[tim][i])swap(a[i],a[rev[tim][i]]); for(ri i=1,t=0,a0,a1;i&lt;lim;i&lt;&lt;=1,++t)for(ri j=0,len=i&lt;&lt;1;j&lt;lim;j+=len) for(ri k=0,mt=1;k&lt;i;++k,Mul(mt,w[t]))a0=a[j+k],a1=mul(mt,a[j+k+i]),a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1); if(~typ)return; reverse(++a.begin(),a.end()); for(ri i=0;i&lt;lim;++i)Mul(a[i],invv[tim]);&#125;inline poly operator*(poly a,poly b)&#123; int n=a.size(),m=b.size(),t=n+m-1; if(t&lt;=64)&#123; poly c(t); for(ri i=0;i&lt;n;++i)for(ri j=0;j&lt;m;++j)Add(c[i+j],mul(a[i],b[j])); return c; &#125; init(t); a.resize(lim),ntt(a,1); b.resize(lim),ntt(b,1); for(ri i=0;i&lt;lim;++i)Mul(a[i],b[i]); return ntt(a,-1),a.resize(t),a;&#125;poly f,g;const int N=1e5+5;int s[N];int n,cnt[N],fac[N],ifac[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]); ifac[0]=0;&#125;inline void solve(int l,int r)&#123; if(l==r)return; int mid=l+r&gt;&gt;1; solve(l,mid); poly a(mid-l+1),b(r-l+1); for(ri i=l;i&lt;=mid;++i)a[i-l]=mul(f[i],mul(s[i],cnt[i])); b.resize(r-l+1); for(ri i=0;i&lt;=r-l;++i)b[i]=ifac[i]; a=a*b; for(ri i=mid+1;i&lt;=r;++i)Add(f[i],mul(a[i-l],cnt[i-1])); solve(mid+1,r);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif init_ntt(); n=Read(s)+1; f.resize(n+1); init(); s[0]=1,cnt[0]=0; f[0]=1; for(ri i=1;i&lt;=n;++i)cnt[i]=cnt[i-1]+s[i]; for(ri i=0;i&lt;=n;++i)cnt[i]=cnt[i]&amp;1?mod-1:1; solve(0,n); cout&lt;&lt;mul(f[n],fac[n]); return 0;&#125; 告辞","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"CodeForces 1228 简要题解","slug":"CF1228","date":"2019-10-12T15:45:41.000Z","updated":"2019-10-22T23:48:26.300Z","comments":true,"path":"CF1228/","link":"","permalink":"http://ldxcaicai.github.io/CF1228/","excerpt":"","text":"A模拟 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int l,r;inline bool check(int x)&#123; int cnt[15]; for(ri i=0;i&lt;10;++i)cnt[i]=0; while(x)++cnt[x%10],x/=10; for(ri i=0;i&lt;10;++i)if(cnt[i]&gt;1)return 0; return 1;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif l=read(),r=read(); for(ri i=l;i&lt;=r;++i)&#123; if(check(i))return cout&lt;&lt;i,0; &#125; puts(\"-1\"); return 0;&#125; B模拟 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1005;int n,m,f[N][N],a[N],b[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); for(ri i=1;i&lt;=m;++i)b[i]=read(); int res=1; for(ri i=1;i&lt;=n;++i)&#123; for(ri j=1;j&lt;=m;++j)&#123; if(a[i]&gt;=j&amp;&amp;b[j]+1==i)return puts(\"0\"),0; if(a[i]+1==j&amp;&amp;b[j]&gt;=i)return puts(\"0\"),0; if(b[j]+1==i||a[i]+1==j||a[i]&gt;=j||b[j]&gt;=i)continue; res=add(res,res); &#125; &#125; cout&lt;&lt;res; return 0;&#125; C分解质因数 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;int x;ll n;vector&lt;int&gt;divv;inline void divid(int x)&#123; for(ri i=2,lm=sqrt(x);i&lt;=lm&amp;&amp;x!=1;++i)&#123; if(x!=x/i*i)continue; divv.pb(i); while(x==x/i*i)x/=i; &#125; if(x^1)divv.pb(x);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif x=read(); n=readl(); divid(x); int res=1; for(ri i=divv.size()-1;~i;--i)&#123; ll mt=divv[i]; while(1)&#123; int tot=(n/mt-n/mt/divv[i])%(mod-1); Mul(res,ksm((ll)mt%mod,tot)); if(!(n/mt/divv[i]))break; mt*=divv[i]; &#125; &#125; cout&lt;&lt;res; return 0;&#125; D普及-题为啥不放 $A$ 啊？？？ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=3e5+5;int n,m,col[N];vector&lt;int&gt;e[N],tp[4];bool vs[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)col[i]=-1; for(ri u,v,i=1;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; for(ri i=0;i&lt;e[1].size();++i)vs[e[1][i]]=1; for(ri i=1;i&lt;=n;++i)if(!vs[i])tp[1].pb(i),col[i]=1; int ps=-1; for(ri i=1;i&lt;=n;++i)&#123; if(vs[i])&#123; ps=i; break; &#125; &#125; if(ps==-1)return puts(\"-1\"),0; for(ri i=0;i&lt;e[ps].size();++i)if(vs[e[ps][i]])tp[3].pb(e[ps][i]),col[e[ps][i]]=3; for(ri i=1;i&lt;=n;++i)if(col[i]==-1)col[i]=2,tp[2].pb(i); if(!tp[2].size()||!tp[3].size())return puts(\"-1\"),0; if((ll)tp[1].size()*tp[2].size()+(ll)tp[2].size()*tp[3].size()+(ll)tp[3].size()*tp[1].size()!=m)return puts(\"-1\"),0; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;e[i].size();++j)if(col[i]==col[e[i][j]])return puts(\"-1\"),0; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;col[i]&lt;&lt;' '; return 0;&#125; E简单容斥即可 $O(n^2)$ ，把式子拆开也可以做到 $O(n\\log n)$ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=255*255;int n,K,fac[N],ifac[N],pw1[N],pw2[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1,pw1[0]=pw2[0]=1,pw1[1]=K,pw2[1]=K-1; for(ri i=2;i&lt;=n*n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); pw1[i]=mul(pw1[i-1],K); pw2[i]=mul(pw2[i-1],K-1); &#125; for(ri i=2;i&lt;=n*n;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int C(int n,int m)&#123;return mul(fac[n],mul(ifac[m],ifac[n-m]));&#125; int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); init(); int res=0; for(ri t,x,i=0;i&lt;=n;++i)for(ri j=0;j&lt;=n;++j)&#123; t=mul(pw1[(n-i)*(n-j)],pw2[n*n-(n-i)*(n-j)]); Mul(t,mul(C(n,i),C(n,j))); (i+j)&amp;1?Dec(res,t):Add(res,t); &#125; cout&lt;&lt;res&lt;&lt;'\\n'; return 0;&#125; F大分类讨论，不知道为啥我写的那么麻烦=.=，看别人讨论的好像很简单，直接去世了 我的讨论： 自己是叶子 父亲是根 自己不是叶子且父亲不是根 代码丑死了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef vector&lt;int&gt; poly;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=1&lt;&lt;18|5;int n,m,siz[N],Fa[N];vector&lt;int&gt;e[N],RT;#define fail puts(\"0\"),exit(0)void dfs(int p,int ft)&#123; siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; Fa[v]=p; dfs(v,p); siz[p]+=siz[v]; &#125; if(siz[p]*2==n)RT.pb(p),RT.pb(ft);&#125;int ban,ad[N];bool check(int p,int ft)&#123; if(siz[p]==1)return 1; if(p==ban)&#123; vector&lt;pii&gt;tp; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; tp.pb(pii(siz[v],v)); &#125; sort(tp.begin(),tp.end()); if(tp[0].fi!=tp[1].fi)fail; if(tp[0].fi+tp[1].fi+1!=tp[2].fi)fail; return check(tp[0].se,p)&amp;&amp;check(tp[1].se,p)&amp;&amp;check(tp[2].se,p); &#125; else&#123; int son1=0,son2=0; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; if(!son1)son1=v; else son2=v; &#125; if(!son2)return 0; if(siz[son1]+ad[son1]!=siz[son2]+ad[son2])return 0; return check(son1,p)&amp;&amp;check(son2,p); &#125;&#125;bool checkk(int p,int ft)&#123; if(siz[p]==1)return 1; if(p==ban)&#123; vector&lt;pii&gt;tp; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; tp.pb(pii(siz[v],v)); &#125; return tp[0].fi==1; &#125; else&#123; int son1=0,son2=0; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; if(!son1)son1=v; else son2=v; &#125; if(!son2)return 0; if(siz[son1]+ad[son1]!=siz[son2]+ad[son2])return 0; return checkk(son1,p)&amp;&amp;checkk(son2,p); &#125;&#125;void dfss(int p,int ft)&#123; siz[p]=1; int son1=0,son2=0; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; if(!son1)son1=v; else son2=v; dfss(v,p),siz[p]+=siz[v]; &#125; if(siz[son1]!=siz[son2])fail;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif m=read(),n=(1&lt;&lt;m)-2; if(n==2)return cout&lt;&lt;2&lt;&lt;'\\n'&lt;&lt;1&lt;&lt;' '&lt;&lt;2,0; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v); e[v].pb(u); &#125; int ct1=0,ct2=0,ct3=0; for(ri i=1;i&lt;=n;++i)&#123; if(e[i].size()&gt;4)fail; if(e[i].size()==4)++ct1; if(e[i].size()==2)++ct2; if(e[i].size()==3)++ct3; &#125; if(ct1&gt;1)fail; if(ct1==1)&#123; if(ct2!=1)fail; int ps; for(ps=1;ps&lt;=n;++ps)if(e[ps].size()==2)break; for(ri i=1;i&lt;=n;++i)if(e[i].size()==4)ban=i; dfs(ps,0); int tp=ban; while(tp!=ps)&#123; ad[tp]=1; tp=Fa[tp]; &#125; if(!check(ps,0))fail; cout&lt;&lt;1&lt;&lt;'\\n'; cout&lt;&lt;ban; return 0; &#125; if(ct2&amp;&amp;ct2!=2)fail; if(ct2==2)&#123; int a=0,b=0; for(ri i=1;i&lt;=n;++i)if(e[i].size()==2)&#123; if(!a)a=i; else b=i; &#125; dfs(a,0); ban=b; while(ban!=a)&#123; ad[ban]=1; ban=Fa[ban]; &#125; ban=b; if(checkk(a,0))return cout&lt;&lt;1&lt;&lt;'\\n'&lt;&lt;ban,0; while(ban!=a)&#123; ad[ban]=0; ban=Fa[ban]; &#125; dfs(b,0); ban=a; while(ban!=b)&#123; ad[ban]=1; ban=Fa[ban]; &#125; ban=a; if(checkk(b,0))return cout&lt;&lt;1&lt;&lt;'\\n'&lt;&lt;ban,0; fail; &#125; if(!ct3)fail; dfs(1,0); if(RT.size()!=2)fail; dfss(RT[0],RT[1]),dfss(RT[1],RT[0]); cout&lt;&lt;2&lt;&lt;'\\n'; cout&lt;&lt;min(RT[0],RT[1])&lt;&lt;' '&lt;&lt;max(RT[0],RT[1]); return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"CodeForces 1101 简要题解","slug":"CF1101","date":"2019-10-12T15:31:54.000Z","updated":"2019-10-22T23:48:07.686Z","comments":true,"path":"CF1101/","link":"","permalink":"http://ldxcaicai.github.io/CF1101/","excerpt":"","text":"A按照题意模拟 CODE 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=105;int mod,n,m,k;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri l,r,d,tt=read();tt;--tt)&#123; l=read(),r=read(),d=read(); if(l&gt;d)cout&lt;&lt;d&lt;&lt;'\\n'; else cout&lt;&lt;((r/d+1)*d)&lt;&lt;'\\n'; &#125; return 0;&#125; B从两边开始各扫一遍即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=105;int mod,n,m,k;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;char s[500005];int len;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif scanf(\"%s\",s+1); len=strlen(s+1); int ps1=-1,ps2=-1,ps3=-1,ps4=-1; for(ri i=1;i&lt;=len;++i)&#123; if(s[i]=='['&amp;&amp;ps1==-1)&#123; ps1=i; &#125; if(s[i]==':'&amp;&amp;ps1!=-1)&#123; ps2=i; break; &#125; &#125; for(ri i=len;i;--i)&#123; if(s[i]==']'&amp;&amp;ps3==-1)&#123; ps3=i; &#125; if(s[i]==':'&amp;&amp;ps3!=-1)&#123; ps4=i; break; &#125; &#125; if(ps1==-1||ps2==-1||ps3==-1||ps4==-1||ps2&gt;=ps4)return cout&lt;&lt;-1,0; int res=4; for(ri i=ps2+1;i&lt;ps4;++i)if(s[i]=='|')++res; cout&lt;&lt;res; return 0;&#125; C用个栈来模拟贪心即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;int mod;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=2e5+5;int n;struct Node&#123; int l,r,id; friend inline bool operator&lt;(Node a,Node b)&#123;return a.r^b.r?a.r&lt;b.r:a.l&lt;b.l;&#125;&#125;a[N];int ans[N],vl[N&lt;&lt;1],sig;inline int find(int x)&#123;return lower_bound(vl+1,vl+sig+1,x)-vl;&#125;pii stk[N];int top=0,tot=0;inline void insert(int l,int r)&#123; ++tot; int idl=tot,idr=tot; while(top)&#123; if(l&gt;a[stk[top].se].r)break; if(l&gt;=a[stk[top].fi].l)&#123; stk[top].se=tot; return; &#125; idl=stk[top].fi; --top; &#125; stk[++top]=pii(idl,idr);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=read(); sig=0; for(ri i=1;i&lt;=n;++i)vl[++sig]=a[i].l=read(),vl[++sig]=a[i].r=read(); sort(vl+1,vl+sig+1); sig=unique(vl+1,vl+sig+1)-vl-1; for(ri i=1;i&lt;=n;++i)a[i].l=find(a[i].l),a[i].r=find(a[i].r),a[i].id=i; sort(a+1,a+n+1); top=tot=0; for(ri i=1;i&lt;=n;++i)insert(a[i].l,a[i].r); if(top==1)&#123; cout&lt;&lt;-1; &#125; else&#123; for(ri i=1;i&lt;=top;++i)&#123; for(ri j=stk[i].fi;j&lt;=stk[i].se;++j)&#123; ans[a[j].id]=2-(i&amp;1); &#125; &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;ans[i]&lt;&lt;' '; &#125; puts(\"\"); &#125; return 0;&#125; D令边权等于连接两个点的 $\\gcd(i,j)$ ，然后可以枚举每个数的倍数然后做树形 $dp$ 求直径 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;int mod;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=2e5+5;int n,a[N],tim[N],timm[N];vector&lt;pii&gt;E[N];vector&lt;int&gt;e[N];int dist=0,len[N];void dfs(int p,int ft,int ct)&#123; len[p]=1; timm[p]=ct; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==ft)continue; dfs(v,p,ct); dist=max(dist,len[p]+len[v]); len[p]=max(len[p],len[v]+1); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); if(a[i]&gt;1)&#123; dist=1; &#125; &#125; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); E[__gcd(a[u],a[v])].pb(pii(u,v)); &#125; for(ri i=2;i&lt;=200000;++i)&#123; vector&lt;int&gt;t; for(ri j=i;j&lt;=200000;j+=i)&#123; for(ri u,v,k=0;k&lt;E[j].size();++k)&#123; u=E[j][k].fi,v=E[j][k].se; if(tim[u]!=i)&#123; t.pb(u); tim[u]=i; e[u].clear(); &#125; if(tim[v]!=i)&#123; t.pb(v); tim[v]=i; e[v].clear(); &#125; e[u].pb(v),e[v].pb(u); &#125; &#125; for(ri k=0;k&lt;t.size();++k)&#123; if(timm[t[k]]!=i)dfs(t[k],0,i); &#125; t.clear(); &#125; cout&lt;&lt;dist; return 0;&#125; E普及-题，为啥不放 $A$ 啊？？？ 读懂题意即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;int mod;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=5e5+5;int n;char op;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int mx1=0,mx2=0; for(ri i=1;i&lt;=n;++i)&#123; op=gc(); while(op!='+'&amp;&amp;op!='?')op=gc(); if(op=='+')&#123; int a=read(),b=read(); if(a&gt;b)swap(a,b); mx1=max(mx1,a); mx2=max(mx2,b); &#125; else&#123; int a=read(),b=read(); if(a&gt;b)swap(a,b); puts(a&gt;=mx1&amp;&amp;b&gt;=mx2?\"YES\":\"NO\"); &#125; &#125; return 0;&#125; F貌似有区间 $dp$ +单调队列的做法，但我直接随机化+剪枝+二分+单调队列艹过了 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch; return top;&#125;namespace modular&#123; int mod; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=405,M=250005;int n,m,ps[N],s,t,C,r,f[N];inline bool check(ll V)&#123; static int q[N],hd,tl; f[s]=0; q[hd=tl=1]=s; for(ri coe,i=s+1;i&lt;=t;++i)&#123; while(hd&lt;=tl&amp;&amp;(ll)(ps[i]-ps[q[hd]])*C&gt;V)++hd; coe=hd&gt;tl?1e9:f[q[hd]]; if(i==t)return coe&lt;=r; f[i]=coe+1; while(hd&lt;=tl&amp;&amp;f[q[tl]]&gt;=f[i])--tl; q[++tl]=i; &#125;&#125;struct Node&#123;int a,b,c,d;&#125;a[M];int main()&#123; srand(time(0)); #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)ps[i]=read(); for(ri i=1;i&lt;=m;++i)a[i].a=read(),a[i].b=read(),a[i].c=read(),a[i].d=read(); random_shuffle(a+1,a+m+1); ll res=0; for(ri i=1;i&lt;=m;++i)&#123; s=a[i].a,t=a[i].b,C=a[i].c,r=a[i].d; if(check(res))continue; ll l=res+1,r=1e18,ress=1e18; while(l&lt;=r)&#123; ll mid=l+r&gt;&gt;1; if(check(mid))ress=mid,r=mid-1; else l=mid+1; &#125; res=ress; &#125; cout&lt;&lt;res; return 0;&#125; G$bzoj2460$ 弱化版，直接求出前缀和然后线性基即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;namespace modular&#123; int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; &#125;;using namespace modular;const int N=2e5+5;int n,a[N],ok[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1,x;i&lt;=n;++i)&#123; a[i]=read()^a[i-1]; x=a[i]; for(ri j=31;~j;--j)&#123; if(x&gt;&gt;j&amp;1)&#123; if(ok[j])x^=ok[j]; else&#123; ok[j]=x; break; &#125; if(!x)break; &#125; &#125; &#125; if(!a[n])return puts(\"-1\"),0; int res=0; for(ri i=31;~i;--i)if(ok[i])++res; cout&lt;&lt;res; return 0;&#125; 感觉以后还是得 $vp$ $div1$ 场 告辞","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"AtCoder Grand Contest 039 简要题解","slug":"AGC039","date":"2019-10-10T03:43:21.000Z","updated":"2019-10-11T15:33:29.541Z","comments":true,"path":"AGC039/","link":"","permalink":"http://ldxcaicai.github.io/AGC039/","excerpt":"","text":"A简单分类讨论即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef pair&lt;int,int&gt; pii;typedef long long ll;typedef unsigned long long Ull;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;char s[105];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif int len=Read(s),k=read(); if(s[1]!=s[len])&#123; int res=0; for(ri l=1,r;l&lt;=len;l=r+1)&#123; r=l; while(r!=len&amp;&amp;s[r+1]==s[r])++r; res+=(r-l+1)/2; &#125; cout&lt;&lt;(ll)res*k; return 0; &#125; bool ff=1; for(ri i=2;i&lt;=len;++i)if(s[i]!=s[i-1])&#123; ff=0; break; &#125; if(ff)&#123; cout&lt;&lt;(ll)len*k/2; return 0; &#125; int ct=2,ps1,ps2; for(ri i=2;i&lt;=len;++i)&#123; if(s[i]==s[i-1])++ct; else&#123; ps1=i; break; &#125; &#125; for(ri i=len-1;i;--i)&#123; if(s[i]==s[i+1])++ct; else&#123; ps2=i; break; &#125; &#125; int res=ct/2; for(ri l=ps1,r;l&lt;=ps2;l=r+1)&#123; r=l; while(r!=ps2&amp;&amp;s[r+1]==s[r])++r; res+=(r-l+1)/2; &#125; ll ans=(ll)res*(k-1); for(ri l=1,r;l&lt;=len;l=r+1)&#123; r=l; while(r!=len&amp;&amp;s[r+1]==s[r])++r; ans+=(r-l+1)/2; &#125; cout&lt;&lt;ans; return 0;&#125; B先判掉奇环，然后枚举每个点做根求 $bfs$ 树的 $mxdep$ 更新最大值即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef pair&lt;int,int&gt; pii;typedef long long ll;typedef unsigned long long Ull;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;char s[205];int n,dep[205];bool vs[205];vector&lt;int&gt;e[205];void check(int p)&#123; vs[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if(vs[v=e[p][i]])&#123; if((dep[v]+dep[p])&amp;1)continue; puts(\"-1\"); exit(0); &#125; dep[v]=dep[p]+1;check(v); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)&#123; Read(s); for(ri j=1;j&lt;=n;++j)if(s[j]=='1')e[i].pb(j); &#125; check(1); int mx=0; for(ri s=1;s&lt;=n;++s)&#123; memset(dep,0,sizeof(dep)); memset(vs,0,sizeof(vs)); queue&lt;int&gt;q; q.push(s),dep[s]=1; while(q.size())&#123; int x=q.front(); q.pop(); vs[x]=1; for(ri i=0,v;i&lt;e[x].size();++i)&#123; if(vs[v=e[x][i]])continue; dep[v]=dep[x]+1; vs[v]=1; q.push(v); &#125; &#125; for(ri i=1;i&lt;=n;++i)mx=max(mx,dep[i]); &#125; cout&lt;&lt;mx; return 0;&#125; C模拟一下会发现每次把最后一位删掉，然后在第一位加上相反的数字，打表再证明可以发现所有非 $n$ 的约数它们的贡献相同都是 $2n$ ，对于 $n$ 满足 $n/x$ 为奇数的约数 $x$ 其贡献为 $2x$ 那么我们枚举 $x$ 然后跟它的倍数或者约数容斥即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;const int mod=998244353;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=2e5+5;char s[N],t[N];int n;int pre[N],f[N];inline int solve(int len)&#123; int res=pre[len]; for(ri i=1;i&lt;=len;++i)t[i]=s[i]; for(ri l=len+1,r=len&lt;&lt;1;l&lt;=n;l+=len,r+=len)&#123; for(ri i=l;i&lt;=r;++i)&#123; t[i]=t[i-len]^1; if(s[i]&gt;t[i])return res+1; if(s[i]&lt;t[i])return res; &#125; &#125; return res+1;&#125;int pri[N],tot=0;bool vs[N];inline void init()&#123; for(ri i=2;i&lt;=n;++i)&#123; if(!vs[i])pri[++tot]=i; for(ri j=1,up=n/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j)&#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j])break; &#125; &#125;&#125;int a[N],b[N],top;vector&lt;int&gt;divv;void dfs(int ps,int mt)&#123; divv.pb(mt); for(ri mlt=a[ps],i=ps;i&lt;=top;++i,mlt=a[i])for(ri j=1;j&lt;=b[i];++j,mlt*=a[i])dfs(i+1,mt*mlt);&#125;inline int calc(int lm)&#123; int x=lm; top=0; for(ri i=1,up=sqrt(lm);i&lt;=tot&amp;&amp;pri[i]&lt;=up&amp;&amp;lm!=1;++i)&#123; if(lm!=lm/pri[i]*pri[i])continue; ++top,a[top]=pri[i],b[top]=0; while(lm==lm/pri[i]*pri[i])lm/=pri[i],++b[top]; &#125; if(lm^1)a[++top]=lm,b[top]=1; divv.clear(); dfs(1,1); int res=0; for(ri i=divv.size()-1;~i;--i)if(divv[i]!=1)if((n/(x/divv[i]))&amp;1)Add(res,f[x/divv[i]]); return res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),Read(s); init(); int res=0; for(ri i=1;i&lt;=n;++i)pre[i]=add(add(pre[i-1],pre[i-1]),s[i]-'0'); res=add(pre[n],1); Mul(res,n*2); for(ri tp,i=1;i*3&lt;=n;++i)&#123; if(n%i)continue; if(!((n/i)&amp;1))continue; f[i]=dec(solve(i),calc(i)); Dec(res,mul(2*(n-i),f[i])); &#125; cout&lt;&lt;res; return 0;&#125; D为啥是MO题啊2333 对于一个 $\\Delta ABC$ ，令 $A’$ 为 $BC$ 不包含 $A$ 的弧的中点， $B’C’$ 同理，这样 $\\Delta A’B’C’$ 的重心即为 $\\Delta ABC$ 的内心，然后利用欧拉线的性质分类讨论计算贡献即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch,ch=gc(); return top;&#125;const int mod=998244353;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=3005;int t[N],n,L;const double pi=acos(-1.0);int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),L=read(); for(ri i=1;i&lt;=n;++i)t[i]=read(); double resx=0,resy=0,Ang=pi/L; for(ri i=1;i&lt;n;++i)for(ri j=i+1;j&lt;=n;++j)&#123; resx+=cos(Ang*(t[i]+t[j]))*(n-(j-i+1)); resy+=sin(Ang*(t[i]+t[j]))*(n-(j-i+1)); resx+=cos(Ang*(t[i]+t[j])+pi)*(j-i-1); resy+=sin(Ang*(t[i]+t[j])+pi)*(j-i-1); &#125; printf(\"%.10lf %.10lf\",resx*6.0/n/(n-1)/(n-2),resy*6.0/n/(n-1)/(n-2)); return 0;&#125; E$f_{l,r,p}$ 表示对于区间 $[l,r]$ ，点 $p$ 连向了 $[l,r]$ 外的区间的方案数，然后 $O(n^4)$ 枚举新的小区间即可,时间复杂度 $O(n^7)$ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;details&gt;&lt;summary&gt;CODE&lt;/summary&gt;#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef long long ll;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(bool*s)&#123; int top=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))s[++top]=ch^48,ch=gc(); return top;&#125;const int N=45;int n;ll f[N][N][N],res=0;bool trans[N][N];ll dfs(int l,int r,int p)&#123; if(~f[l][r][p])return f[l][r][p]; if(l==r)return f[l][r][p]=1; if(l==p||r==p)return f[l][r][p]=0; ll res=0ll; for(ri _l=l;_l&lt;p;++_l)for(ri _r=r;_r&gt;p;--_r)if(trans[_l][_r]) for(ri a=_l;a&lt;p;++a)for(ri b=_r;b&gt;p;--b)res+=dfs(l,a,_l)*dfs(a+1,b-1,p)*dfs(b,r,_r); return f[l][r][p]=res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); memset(f,-1,sizeof(f)); for(ri i=1;i&lt;=n*2;++i)Read(trans[i]); if(n==1)return cout&lt;&lt;trans[1][2],0; for(ri i=3;i&lt;n*2;++i)(trans[1][i])&amp;&amp;(res+=dfs(2,n*2,i)); cout&lt;&lt;res; return 0;&#125; F考虑转化问题成为如下新模型： 要求填上两个矩阵 $A,B$ ，满足 $A$ 的行最大值不超过 $B$ 的行最小值， $A$ 的列最大值不超过 $B$ 的列最小值，求方案数 那么就可以设计出枚举两维转移的 $dp$ ，发现好像还能用 $fft$ 优化到 $O(n^4\\log n)$ 但仍然不够，我们需要一个 $O(n^4)$ 做法，因为有权值的限制状态应该是 $O(n^3)$ 的，因此需要定义可以将横纵坐标分开或者分步转移的状态 于是令 $x_i$ 为 $A$ 第 $i$ 行最大值， $y_i$ 为 $B$ 第 $i$ 列最小值 设 $f_{i,j,k}$ 表示已经枚举了 $i$ 行 $j$ 列，已经填上了 $A$ 数组这 $i$ 行 $j$ 列并集的位置，已接近填上了 $B$ 数组这 $i$ 行 $j$ 列交集的位置，且满足已经填好的 $x_i,y_i\\le k$ 的可行状态的方案数 然后就可以分步枚举行列的增量转移到 $f_{i+a,j+b,k+1}$ 了 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=105;int n,m,L,f[N][N][N][2],C[N][N],pw[4][N];inline void init()&#123; for(ri i=0,up=max(n,m);i&lt;=up;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j-1],C[i-1][j]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),L=read(),mod=read(); init(); f[0][0][0][0]=1; for(ri i=0;i&lt;4;++i)pw[i][0]=1; for(ri vl=0;vl&lt;L;++vl)&#123; for(ri i=1,up=max(n,m);i&lt;=up;++i)&#123; pw[0][i]=pw[1][i]; pw[1][i]=mul(pw[1][i-1],vl+1); pw[2][i]=mul(pw[2][i-1],L-vl); pw[3][i]=mul(pw[3][i-1],L-vl-1); &#125; for(ri mt,mlt,a=0;a&lt;=n;++a)for(ri b=0;b&lt;=m;++b)if(f[vl][a][b][0])&#123; mt=1,mlt=mul(pw[2][b],dec(pw[1][m-b],pw[0][m-b])); for(ri t=0;a+t&lt;=n;++t,Mul(mt,mlt)) Add(f[vl][a+t][b][1],mul(f[vl][a][b][0],mul(mt,C[n-a][t]))); &#125; for(ri mt,mlt,a=0;a&lt;=n;++a)for(ri b=0;b&lt;=m;++b)if(f[vl][a][b][1])&#123; mt=1,mlt=mul(pw[1][n-a],dec(pw[2][a],pw[3][a])); for(ri t=0;b+t&lt;=m;++t,Mul(mt,mlt)) Add(f[vl+1][a][b+t][0],mul(f[vl][a][b][1],mul(mt,C[m-b][t]))); &#125; &#125; cout&lt;&lt;f[L][n][m][0]; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"2019.10.09 模拟测试题解","slug":"191009test","date":"2019-10-10T03:27:23.000Z","updated":"2019-10-11T15:33:33.345Z","comments":true,"path":"191009test/","link":"","permalink":"http://ldxcaicai.github.io/191009test/","excerpt":"","text":"A题意简述： 给一个长度为 $n$ 的数组，每个数都为 $0,1,\\cdots,9$ 中的一个，给出 $Q$ 个限制 $(l,r,v)$ 表示区间 $[l,r]$ 的乘积模 $10$ 的余数为 $v$ ，问合法数组数 数据范围： $n\\le100$ $q\\le50$ 解题思路： 考虑转化为计算模 $2$ 和模 $5$ 的方案数再乘起来 然后发现除了 $0$ 都有逆元，容易想到把强制不为 $0$ 的位置和可能为 $0$ 的位置分开考虑，前者在给区间进行简单操作后可以直接算，后者可以用简单 $dp$ 算 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; const int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=105,Q=55;struct F&#123; int l,r,v; F(int l=0,int r=0,int v=0):l(l),r(r),v(v)&#123;&#125; friend inline bool operator&lt;(F a,F b)&#123;return a.l^b.l?a.l&lt;b.l:a.r&lt;b.r;&#125;&#125;a[N],ori[N],vl[N];int n,q,ps[N],top,coe,sig,tot,Inv[5]=&#123;0,1,3,2,4&#125;,f[N],pw[N];pii L[N],R[N];bool ban[N];inline bool insert(F x)&#123; while(1)&#123; if(!L[x.l].fi&amp;&amp;!R[x.r].fi)break; if(L[x.l].fi==x.r)return x.v==L[x.l].se; if(L[x.l].fi)&#123; if(L[x.l].fi&gt;x.r)&#123; swap(x.v,L[x.l].se); R[L[x.l].fi]=pii(0,0); swap(x.r,L[x.l].fi); R[L[x.l].fi]=pii(x.l,L[x.l].se); &#125; (x.v*=Inv[L[x.l].se])%=coe; x.l=L[x.l].fi+1; &#125; else&#123; if(R[x.r].fi&lt;x.l)&#123; swap(x.v,R[x.r].se); L[R[x.r].fi]=pii(0,0); swap(x.l,R[x.r].fi); L[R[x.r].fi]=pii(x.r,R[x.r].se); &#125; (x.v*=Inv[R[x.r].se])%=coe; x.r=R[x.r].fi-1; &#125; &#125; ++sig; L[x.l]=pii(x.r,x.v); R[x.r]=pii(x.l,x.v); return 1;&#125;inline int solve1()&#123; if(coe==2)return 1; sig=0; for(ri i=1;i&lt;=top;++i)L[i]=R[i]=pii(0,0); for(ri i=1;i&lt;=tot;++i)if(!insert(vl[i]))return 0; return ksm(coe-1,top-sig);&#125;inline bool check(int len,int ps)&#123; for(ri i=tot;i&amp;&amp;vl[i].l&gt;ps;--i)if(vl[i].r&lt;=len)return 0; return 1;&#125;inline int solve2()&#123; sort(vl+1,vl+tot+1); pw[0]=1; f[0]=1; for(ri len=1;len&lt;=top;++len)&#123; pw[len]=mul(pw[len-1],coe-1); f[len]=0; for(ri ps=0;ps&lt;=len;++ps)check(len,ps)&amp;&amp;(Add(f[len],mul(pw[len-ps],ps?f[ps-1]:1)),1); &#125; return f[top];&#125;inline void fix1()&#123; tot=0; for(ri i=1;i&lt;=q;++i)if(a[i].v)&#123; ++tot; vl[tot].l=lower_bound(ps+1,ps+top+1,a[i].l)-ps; vl[tot].r=lower_bound(ps+1,ps+top+1,a[i].r)-ps; vl[tot].v=a[i].v; &#125;&#125;inline void fix2()&#123; tot=0; for(ri t,i=1;i&lt;=q;++i)if(!a[i].v)&#123; ++tot; for(t=1;t&lt;=top&amp;&amp;ps[t]&lt;a[i].l;++t); vl[tot].l=t; for(t=top;t&amp;&amp;ps[t]&gt;a[i].r;--t); vl[tot].r=t; vl[tot].v=a[i].v; &#125;&#125;inline int solve()&#123; for(ri i=1;i&lt;=n;++i)ban[i]=0; for(ri i=1;i&lt;=q;++i)if(a[i].v) for(ri j=a[i].l;j&lt;=a[i].r;++j)ban[j]=1; for(ri i=1;i&lt;=q;++i)if(!a[i].v)&#123; bool ff=0; for(ri j=a[i].l;j&lt;=a[i].r;++j)if(!ban[j])&#123;ff=1;break;&#125; if(!ff)return 0; &#125; top=0; for(ri i=1;i&lt;=n;++i)if(ban[i])ps[++top]=i; fix1(); int res=solve1(); top=0; for(ri i=1;i&lt;=n;++i)if(!ban[i])ps[++top]=i; fix2(); return mul(res,solve2());&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),q=read(); for(ri l,r,v,i=1;i&lt;=q;++i)&#123; l=read()+1,r=read()+1,v=read(); ori[i]=F(l,r,v); &#125; for(ri i=1;i&lt;=q;++i)a[i]=ori[i],a[i].v%=2; coe=2; int res=solve(); for(ri i=1;i&lt;=q;++i)a[i]=ori[i],a[i].v%=5; coe=5; cout&lt;&lt;mul(res,solve()); return 0;&#125; B题意简述： 对于一张 $n$ 个点的无向完全图，每条边有 $P$ 的概率出现，问等概率随机一个点，从 $1$ 号点到其的最短路长度（不连通答案为 $10^9$ )的期望 数据范围: $n\\le400$ 解题思路： 考虑定义状态 $P_{i,j}$ 表示考虑了 $i$ 个点的分层图，最后一层有 $j$ 个点，到达这个状态的概率， $E_{i,j}$ 同理不过换成了期望，这样就能边 $dp$ 边统计答案，转移可以考虑新加进来的一层和当前最后一层的连边情况，复杂度 $O(n^3)$ CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef long long ll;namespace modular&#123; const int mod=998244353; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125; &#125;using namespace modular;const int N=405;int n,E[N][N],P[N][N],fac[N],ifac[N],pw2[N*N],coe[N][N],_P;inline int C(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],mul(ifac[m],ifac[n-m]));&#125;inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1,pw2[0]=1; pw2[1]=dec(1,_P); for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); &#125; for(ri i=2;i&lt;=n*n;++i)pw2[i]=mul(pw2[i-1],pw2[1]); for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]); for(ri i=1;i&lt;=n;++i)&#123; coe[i][0]=1; coe[i][1]=dec(1,pw2[i]); for(ri j=2;j&lt;=n;++j)coe[i][j]=mul(coe[i][j-1],coe[i][1]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),_P=mul(ksm(1000000,mod-2),read()); init(); int res=0; P[1][1]=1; for(ri i=1;i&lt;n;++i)for(ri j=1;j&lt;=i;++j)&#123; if(i&gt;1&amp;&amp;i==j)continue; Add(res,mul(add(E[i][j],P[i][j]),coe[j][1])); Add(res,mul(1000000000%mod,mul(pw2[j*(n-i)],P[i][j]))); for(ri k=1;k+i&lt;n;++k)&#123; Add(P[i+k][k],mul(mul(P[i][j],coe[j][k]),mul(C(n-i-1,k),pw2[j*(n-i-k)]))); Add(E[i+k][k],mul(mul(add(P[i][j],E[i][j]),coe[j][k]),mul(C(n-i-1,k),pw2[j*(n-i-k)]))); &#125; &#125; cout&lt;&lt;mul(res,mul(n-1,ksm(1000000,n*n))); return 0;&#125; C题意简述： 求有多少本质不同的不超过 $n$ 个点的、无重边、可以有自环、存在至少一条欧拉回路的带标号连通无向图 数据范围： $n\\le45$ 解题思路： 首先用最小表示法 + $burnside$ 求出不要求连体桶的答案，这个方法参见洛谷一道叫做画画的题目，然后就可以用补集转化的思想枚举不连通的情况求出答案 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;namespace modular&#123; int mod=1e9+7; inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125; inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125; inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125; inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125; inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125; inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;&#125;using namespace modular;const int N=55;int n,fac[N],ifac[N],inv[N],pw[N*N*2];inline void init()&#123; inv[1]=fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)&#123; fac[i]=mul(fac[i-1],i); inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); ifac[i]=mul(ifac[i-1],inv[i]); &#125; pw[0]=1; for(ri i=1;i&lt;=n*n*2;++i)pw[i]=add(pw[i-1],pw[i-1]);&#125;int res,a[N],cnt[N],vl[N],top=0,ft[N],up;inline int find(int x)&#123;return x^ft[x]?ft[x]=find(ft[x]):x;&#125;inline int gcd(int a,int b)&#123;int t;while(b)t=a,a=b,b=t-t/a*a;return a;&#125;inline void update()&#123; int coe=1,ss=0; for(ri i=1;i&lt;=up;++i)Mul(coe,ifac[cnt[i]]),ft[i]=i; for(ri i=1;i&lt;=top;++i)&#123; ss+=(a[i]-1)/2; vl[i]=!(a[i]&amp;1); Mul(coe,inv[a[i]]); &#125; for(ri x,y,fx,fy,g,i=1;i&lt;top;++i)for(ri j=i+1;j&lt;=top;++j)&#123; g=gcd(a[i],a[j]); x=(a[j]/g)&amp;1,y=(a[i]/g)&amp;1; if(x^y)(x?vl[i]:vl[j])+=g; else&#123; ss+=g; if(x&amp;y)&#123; fx=find(i); fy=find(j); if(fx^fy)ft[fx]=fy; &#125; &#125; &#125; for(ri i=1;i&lt;=top;++i)if(find(i)!=i)vl[find(i)]+=vl[i]; for(ri i=1;i&lt;=top;++i)if(find(i)==i)ss+=max(vl[i],1); Add(res,mul(coe,pw[ss]));&#125;inline void dfs(int sz,int all)&#123; if(!all)return update(); if(sz&gt;all)return; for(ri i=sz;i&lt;=all;++i)&#123; ++cnt[i]; a[++top]=i; dfs(i,all-i); --cnt[i]; --top; &#125;&#125;inline int C(int n,int m)&#123; if(n&lt;m)return 0; int ret=ifac[m]; for(ri i=0;i&lt;m;++i)Mul(ret,n-i); return ret;&#125;int f[N],g[N],h[N];inline void IEP()&#123; res=0; g[0]=1; for(ri i=1;i&lt;=n;++i)&#123; h[i]=dec(f[i],g[i]); for(ri j=n;j;--j)for(ri k=1;i*k&lt;=j;++k)Add(g[j],mul(g[j-i*k],C(add(h[i],k-1),k))); &#125; for(ri i=1;i&lt;=n;++i)Add(res,h[i]); cout&lt;&lt;dec(res,1);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),mod=read(); init(); for(up=1;up&lt;=n;++up)&#123; res=0; dfs(1,up); f[up]=res; &#125; IEP(); return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://ldxcaicai.github.io/tags/考试题解/"}]},{"title":"2019.10.07 模拟测试题解","slug":"191007test","date":"2019-10-10T03:08:47.000Z","updated":"2019-10-11T15:33:34.569Z","comments":true,"path":"191007test/","link":"","permalink":"http://ldxcaicai.github.io/191007test/","excerpt":"","text":"题目来源： $A:CF793G$ $B:CF335E$ $C:CF809E$A题意简述： 给你一个 $n\\times n$ 的网格图和 $q$ 个不相交的矩形，问除开这 $q$ 个矩形剩下的格子中最多能放多少个互不影响的車 数据范围： $n\\le10000$ $q\\le10000$ 解题思路： 暴力是很显然的按照行列建二分图然后最大匹配，正解可以考虑用数据结构优化建图，简单思考后容易想到扫描线+主席树，WOJ上被卡常了什么辣鸡评测姬 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef long long ll;const int N=10005,M=6e6+5,inf=0x3f3f3f3f;int n,m;struct edge&#123;int v,next,c;&#125;;namespace dinic&#123; int s,t,first[M],cnt,d[M],cur[M]; edge e[M]; inline void addedge(int u,int v,int c)&#123;e[++cnt]=(edge)&#123;v,first[u],c&#125;,first[u]=cnt;&#125; inline void add(int u,int v,int c)&#123;if(!c)return;addedge(u,v,c),addedge(v,u,0);&#125; inline bool bfs()&#123; static int que[M],hd,tl; for(ri i=s;i&lt;=t;++i)d[i]=-1; d[s]=0,que[hd=tl=1]=s; while(hd&lt;=tl)&#123; int x=que[hd++]; for(ri i=first[x],v;~i;i=e[i].next)&#123; v=e[i].v; if(~d[v]||e[i].c&lt;=0)continue; d[v]=d[x]+1; if(v==t)return 1; que[++tl]=v; &#125; &#125; return 0; &#125; inline int dfs(int p,int f)&#123; if(!f||p==t)return f; int flow=f; for(ri i=first[p],v,tp;~i;i=e[i].next)&#123; if(!flow)return f; v=e[i].v; if(d[v]&gt;d[p]&amp;&amp;e[i].c&gt;0)&#123; tp=dfs(v,min(flow,e[i].c)); (!tp)&amp;&amp;(d[v]=-1); e[i].c-=tp,e[i^1].c+=tp,flow-=tp; &#125; &#125; return f-flow; &#125; inline int solve()&#123; int res=0,tp=0; while(bfs())while((tp=dfs(s,inf)))res+=tp; return res; &#125;&#125;namespace subtask1&#123; int det[105][105]; inline void Main()&#123; dinic::cnt=-1; dinic::s=0,dinic::t=2*n+1; for(ri i=0;i&lt;=n*2+1;++i)dinic::first[i]=-1; for(ri i=1;i&lt;=n;++i)dinic::add(0,i,1),dinic::add(i+n,n*2+1,1); for(ri x1,x2,y1,y2,i=1;i&lt;=m;++i)&#123; x1=read(),y1=read(),x2=read(),y2=read(); ++det[x1][y1],--det[x1][y2+1],--det[x2+1][y1],++det[x2+1][y2+1]; &#125; for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)&#123; det[i][j]+=det[i-1][j]+det[i][j-1]-det[i-1][j-1]; if(!det[i][j])dinic::add(i,j+n,1); &#125; cout&lt;&lt;dinic::solve(); exit(0); &#125;&#125;int all=0,idx[M],rt[N],tot=0,son[M][2],siz[M];#define lc (son[p][0])#define rc (son[p][1])#define mid (l+r&gt;&gt;1)inline void build(int&amp;p,int l,int r)&#123; p=++tot,siz[p]=r-l+1; idx[p]=++all,dinic::first[all]=-1; if(l==r)&#123; dinic::add(idx[p],l+n,1); return; &#125; build(lc,l,mid),build(rc,mid+1,r); dinic::add(idx[p],idx[lc],siz[lc]); dinic::add(idx[p],idx[rc],siz[rc]);&#125;inline void update(int&amp;p,int o,int O,int l,int r,int ql,int qr,int v)&#123; p=++tot; siz[p]=siz[o]+v*(min(qr,r)-max(ql,l)+1),lc=son[o][0],rc=son[o][1]; idx[p]=++all,dinic::first[all]=-1; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; if(l==r)dinic::add(idx[p],l+n,1); else&#123; dinic::add(idx[p],idx[son[O][0]],siz[son[O][0]]); dinic::add(idx[p],idx[son[O][1]],siz[son[O][1]]); &#125; return; &#125; if(qr&lt;=mid)update(lc,lc,son[O][0],l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,rc,son[O][1],mid+1,r,ql,qr,v); else update(lc,lc,son[O][0],l,mid,ql,qr,v),update(rc,rc,son[O][1],mid+1,r,ql,qr,v); dinic::add(idx[p],idx[lc],siz[lc]); dinic::add(idx[p],idx[rc],siz[rc]);&#125;#undef lc#undef rc#undef midstruct F&#123;int l,r,typ;friend inline bool operator&lt;(F a,F b)&#123;return a.typ&lt;b.typ;&#125;;&#125;;vector&lt;F&gt;upd[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri x1,y1,x2,y2,i=1;i&lt;=m;++i)&#123; x1=read(),y1=read(),x2=read(),y2=read(); upd[x1].pb((F)&#123;y1,y2,-1&#125;),upd[x2+1].pb((F)&#123;y1,y2,1&#125;); &#125; all=n*2; dinic::s=0; dinic::cnt=-1; for(ri i=0;i&lt;=all;++i)dinic::first[i]=-1; for(ri i=1;i&lt;=n;++i)dinic::add(0,i,1); build(rt[0],1,n); for(ri i=1;i&lt;=n;++i)&#123; rt[i]=rt[i-1]; sort(upd[i].begin(),upd[i].end()); for(ri j=upd[i].size()-1;~j;--j) update(rt[i],rt[i],rt[0],1,n,upd[i][j].l,upd[i][j].r,upd[i][j].typ); dinic::add(i,idx[rt[i]],siz[rt[i]]); &#125; dinic::t=++all,dinic::first[all]=-1; for(ri i=1;i&lt;=n;++i)dinic::add(i+n,all,1); cout&lt;&lt;dinic::solve(); return 0;&#125; B解题思路： 首先考虑给你一个 $Bob$ 的情况，根据样例不难猜出答案为 $n$ 然后考虑给你一个 $Alice$ 的情况，发现可以枚举高度令其一点点增加然后算新滑索减原来滑索的期望增量 CODE 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;char s[10];int n,H,pw[35];double ipw[35];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif scanf(\"%s%d%d\",s,&amp;n,&amp;H); if(s[0]=='B')&#123; cout&lt;&lt;n; return 0; &#125; pw[0]=ipw[0]=1; for(ri i=1;i&lt;=H;++i)pw[i]=pw[i-1]*2,ipw[i]=1.0/pw[i]; double res=0,mt; for(ri h=1;h&lt;=H;++h)&#123; mt=ipw[h]*ipw[h]; for(ri len=1;len&lt;n;++len)&#123; res+=(n-len)*mt*(pw[h]-pw[h-1]*(1.0+(double)(len-1)/(double)(pw[h]-1))); mt*=1-ipw[h]; &#125; &#125; printf(\"%.10lf\",res+n); return 0;&#125; C题意简述： 给出一棵树和每个点点权 $a_i$ 求 $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\phi(a_ia_j)dist(i,j)$数据范围： $n\\le200000$ 保证 $\\{a\\}$ 是一个排列解题思路：考虑到有等式 $\\phi(ij)=\\phi(i)\\phi(j)\\frac{\\gcd(i,j)}{\\phi(\\gcd(i,j))}$ 于是容易想到可以莫比乌斯反演+调和级数枚举点+虚树统计答案 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int mod=1e9+7;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline void Mul(int&amp;a,int b)&#123;a=mul(a,b);&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=2e5+5;vector&lt;int&gt;e[N],E[N];int n,a[N],b[N],mu[N],phi[N],pri[N],inv[N],tot=0,F[N];bool vs[N];inline void init()&#123; phi[1]=inv[1]=mu[1]=1; for(ri i=2;i&lt;=n;++i)&#123; inv[i]=mul(inv[mod-mod/i*i],mod-mod/i); if(!vs[i])pri[++tot]=i,phi[i]=i-1,mu[i]=mod-1; for(ri j=1,up=n/i;j&lt;=tot&amp;&amp;pri[j]&lt;=up;++j)&#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j])&#123; mu[i*pri[j]]=0; phi[i*pri[j]]=phi[i]*pri[j]; break; &#125; phi[i*pri[j]]=phi[i]*(pri[j]-1); mu[i*pri[j]]=mu[i]?mod-mu[i]:0; &#125; &#125; for(ri i=1;i&lt;=n;++i)for(ri j=i,t=1;j&lt;=n;j+=i,++t)Add(F[j],mul(i,mul(inv[phi[i]],mu[t])));&#125;int siz[N],top[N],dep[N],fa[N],hson[N],dfntot=0,dfn[N];void dfs1(int p)&#123; siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==fa[p])continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; (siz[v]&gt;siz[hson[p]])&amp;&amp;(hson[p]=v); &#125;&#125;void dfs2(int p,int tp)&#123; dfn[p]=++dfntot,top[p]=tp; if(!hson[p])return; dfs2(hson[p],tp); for(ri i=0,v;i&lt;e[p].size();++i)((v=e[p][i])!=hson[p]&amp;&amp;v!=fa[p])&amp;&amp;(dfs2(v,v),1);&#125;inline int lca(int x,int y)&#123; while(top[x]^top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;bool key[N];int tp=0,stk[N];inline void insert(int x)&#123; if(tp&lt;2)&#123;stk[++tp]=x;return;&#125; int t=lca(x,stk[tp]); if(t==stk[tp])&#123;stk[++tp]=x;return;&#125; while(dfn[stk[tp]]&gt;dfn[t])&#123; if(dfn[t]&gt;=dfn[stk[tp-1]])&#123; E[t].pb(stk[tp]),--tp; if(t^stk[tp])stk[++tp]=t; stk[++tp]=x; return; &#125; E[stk[tp-1]].pb(stk[tp]),--tp; &#125;&#125;int res=0,ss,ss1[N],ss2[N];void dfs(int p)&#123; ss1[p]=ss2[p]=0; for(ri i=0,v;i&lt;E[p].size();++i)&#123; v=E[p][i]; dfs(v); Add(ss2[p],ss2[v]); Add(ss1[p],ss1[v]); &#125; if(key[p])&#123; Add(ss,dec(mul(ss2[p],phi[a[p]]),mul(ss1[p],mul(phi[a[p]],dep[p])))); Add(ss2[p],mul(phi[a[p]],dep[p])); Add(ss1[p],phi[a[p]]); &#125; for(ri i=0,v;i&lt;E[p].size();++i)&#123; v=E[p][i]; Dec(ss2[p],ss2[v]); Dec(ss1[p],ss1[v]); Add(ss,mul(ss1[v],ss2[p])); Add(ss,mul(ss1[p],ss2[v])); Dec(ss,mul(mul(2,dep[p]),mul(ss1[v],ss1[p]))); Add(ss2[p],ss2[v]); Add(ss1[p],ss1[v]); &#125;&#125;void clear(int p)&#123; key[p]=0; for(ri i=0;i&lt;E[p].size();++i)clear(E[p][i]); E[p].clear();&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); init(); for(ri i=1;i&lt;=n;++i)b[a[i]=read()]=i; for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; dfs1(1),dfs2(1,1); vector&lt;pii&gt;t; for(ri d=1;d&lt;=n;++d)&#123; t.clear(); for(ri p=d;p&lt;=n;p+=d)t.pb(pii(dfn[b[p]],b[p])),key[b[p]]=1; sort(t.begin(),t.end()); tp=0; if(!key[1])insert(1); for(ri i=0;i&lt;t.size();++i)insert(t[i].se); while(tp&gt;1)E[stk[tp-1]].pb(stk[tp]),--tp; ss=0; dfs(1),clear(1); Add(res,mul(ss,F[d])); &#125; cout&lt;&lt;mul(res,mul(inv[n],inv[n-1])); return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://ldxcaicai.github.io/tags/考试题解/"}]},{"title":"CodeForces 1220 简要题解","slug":"CF1220","date":"2019-10-04T08:43:54.000Z","updated":"2019-10-22T23:48:20.283Z","comments":true,"path":"CF1220/","link":"","permalink":"http://ldxcaicai.github.io/CF1220/","excerpt":"","text":"A显然尽量多选 $1$ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;int n,c[5];char s[100005];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); Read(s); for(ri i=1;i&lt;=n;++i)&#123; if(s[i]=='z')++c[0]; if(s[i]=='e')++c[1]; if(s[i]=='r')++c[2]; if(s[i]=='o')++c[3]; if(s[i]=='n')++c[4]; &#125; for(ri i=1,up=min(c[4],min(c[3],c[1]));i&lt;=up;++i)--c[4],--c[3],--c[1],cout&lt;&lt;1&lt;&lt;' '; for(ri i=1,up=min(min(c[0],c[1]),min(c[2],c[3]));i&lt;=up;++i)cout&lt;&lt;0&lt;&lt;' '; return 0;&#125; B按照题意模拟，先算出 $a_1$ ，然后可以用 $a_{i,1}/a_1$ 得出剩余的数 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;int n;int res[1005],a[1005][1005];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=n;++j)a[i][j]=read(); res[1]=sqrt((ll)a[1][2]*a[1][3]/a[2][3]); for(ri i=2;i&lt;=n;++i)res[i]=a[1][i]/res[1]; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;res[i]&lt;&lt;' '; puts(\"\"); return 0;&#125; C显然只用考虑首字母大小，取前缀最小值比一比即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=5e5+5;char s[N];int n;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=Read(s); int premn=26; for(ri i=1;i&lt;=n;++i)&#123; int x=s[i]-'a'; if(premn&lt;x)&#123; puts(\"Ann\"); &#125; else puts(\"Mike\"); premn=min(premn,x); &#125; return 0;&#125; D手玩一下可以发现规律，设最后保留的集合为 $\\{a_1,a_2,\\cdots,a_n\\}$，那么满足 $\\forall i,j,lcm(a_i,a_j)/\\gcd(a_i,a_j)\\%2==1$ 于是按 $2$ 的幂次分组即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=2e5+5;int n;bool vs[N];ll a[N];bool in[N];vector&lt;ll&gt;vl[105];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); set&lt;int&gt;A,B; for(ri i=1;i&lt;=n;++i)&#123; ll x=readl(),s=x,t=0; while(!(s&amp;1))s&gt;&gt;=1,++t; vl[t].pb(x); &#125; int mx=0; for(ri i=0;i&lt;63;++i)mx=max(mx,(int)vl[i].size()); cout&lt;&lt;n-mx&lt;&lt;'\\n'; bool ff=1; for(ri i=0;i&lt;63;++i)&#123; if(vl[i].size()==mx&amp;&amp;ff)&#123;ff=0;continue;&#125; for(ri j=0;j&lt;vl[i].size();++j)cout&lt;&lt;vl[i][j]&lt;&lt;' '; &#125; return 0;&#125; E先 $tarjan$ 一次，然后用树形 $dp$ 即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;typedef pair&lt;int,int&gt; pii;typedef long long ll;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=2e5+5;int S,n,m,w[N],dfn[N],low[N],tot=0,stk[N],top=0,siz[N],col[N],sig=0;bool vs[N];ll sum[N];vector&lt;int&gt;e[N],E[N];void tarjan(int p,int fa)&#123; dfn[p]=low[p]=++tot,stk[++top]=p; vs[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if(dfn[v=e[p][i]])&#123; if(v==fa||!vs[v])continue; low[p]=min(low[p],dfn[v]); &#125; else tarjan(v,p),low[p]=min(low[p],low[v]); &#125; if(low[p]==dfn[p])&#123; int x; ++sig; while(1)&#123; x=stk[top--]; ++siz[sig]; col[x]=sig; vs[x]=0; sum[sig]+=w[x]; if(x==p)break; &#125; &#125;&#125;ll F[N][2];bool ok[N];void dfs(int p,int fa)&#123; ok[p]=siz[p]&gt;1; F[p][0]=sum[p]; for(ri i=0,v;i&lt;E[p].size();++i)&#123; if((v=E[p][i])==fa)continue; dfs(v,p); if(ok[v])F[p][0]+=F[v][0],ok[p]=1; &#125; F[p][1]=F[p][0]; for(ri i=0,v;i&lt;E[p].size();++i)&#123; if((v=E[p][i])==fa)continue; if(ok[v])F[p][0]-=F[v][0]; F[p][1]=max(F[p][1],F[p][0]+F[v][1]); if(ok[v])F[p][0]+=F[v][0]; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)w[i]=read(); for(ri u,v,i=1;i&lt;=m;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; S=read(); tarjan(S,0); for(ri u=1,v;u&lt;=n;++u)for(ri i=0;i&lt;e[u].size();++i)&#123; v=e[u][i]; if(col[u]==col[v])continue; E[col[u]].pb(col[v]); &#125; dfs(col[S],0); cout&lt;&lt;max(F[col[S]][0],F[col[S]][1]); return 0;&#125; F用线段树维护题意即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=4e5+5;int a[N],n,b[N],dep[N];namespace sgt1&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) int mx[N&lt;&lt;2],dt[N&lt;&lt;2]; inline void pushup(int p)&#123;mx[p]=max(mx[lc],mx[rc]);&#125; inline void pushnow(int p,int v)&#123; mx[p]+=v; dt[p]+=v; &#125; inline void pushdown(int p)&#123; if(dt[p])&#123; pushnow(lc,dt[p]); pushnow(rc,dt[p]); dt[p]=0; &#125; &#125; inline void build(int p,int l,int r)&#123; if(l==r)&#123;mx[p]=dep[a[l]];return;&#125; build(lc,l,mid),build(rc,mid+1,r); pushup(p); &#125; inline void modify(int p,int l,int r,int k,int v)&#123; if(l==r)&#123;mx[p]=v;return;&#125; pushdown(p); k&lt;=mid?modify(lc,l,mid,k,v):modify(rc,mid+1,r,k,v); pushup(p); &#125; inline void update(int p,int l,int r,int ql,int qr,int v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return pushnow(p,v); pushdown(p); if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); pushup(p); &#125; inline int query(int p,int l,int r,int k)&#123; if(l==r)return mx[p]; pushdown(p); return k&lt;=mid?query(lc,l,mid,k):query(rc,mid+1,r,k); &#125;&#125;namespace sgt2&#123; int mn[N&lt;&lt;2]; inline void pushup(int p)&#123;mn[p]=min(mn[lc],mn[rc]);&#125; inline void build(int p,int l,int r)&#123; if(l==r)&#123;mn[p]=a[l];return;&#125; build(lc,l,mid),build(rc,mid+1,r); pushup(p); &#125; inline int Ql(int p,int l,int r,int v)&#123; if(mn[p]&gt;=v)return -1; if(l==r)return l; if(mn[lc]&lt;v)return Ql(lc,l,mid,v); return Ql(rc,mid+1,r,v); &#125; inline int Ql(int p,int l,int r,int ql,int qr,int v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return Ql(p,l,r,v); if(qr&lt;=mid)return Ql(lc,l,mid,ql,qr,v); if(ql&gt;mid)return Ql(rc,mid+1,r,ql,qr,v); int res=Ql(lc,l,mid,ql,qr,v); if(~res)return res; return Ql(rc,mid+1,r,ql,qr,v); &#125; inline int Qr(int p,int l,int r,int v)&#123; if(mn[p]&gt;=v)return -1; if(l==r)return l; if(mn[rc]&lt;v)return Qr(rc,mid+1,r,v); return Qr(lc,l,mid,v); &#125; inline int Qr(int p,int l,int r,int ql,int qr,int v)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return Qr(p,l,r,v); if(qr&lt;=mid)return Qr(lc,l,mid,ql,qr,v); if(ql&gt;mid)return Qr(rc,mid+1,r,ql,qr,v); int res=Qr(rc,mid+1,r,ql,qr,v); if(~res)return res; return Qr(lc,l,mid,ql,qr,v); &#125; #undef lc #undef rc #undef mid&#125;int stk[N],top=0,son[N][2];void dfs(int p)&#123; if(son[p][0])dep[son[p][0]]=dep[p]+1,dfs(son[p][0]); if(son[p][1])dep[son[p][1]]=dep[p]+1,dfs(son[p][1]);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=a[i+n]=read(),b[a[i]]=i; sgt2::build(1,1,n&lt;&lt;1); stk[top=1]=a[1]; for(ri i=2;i&lt;=n;++i)&#123; int x=0; while(top&amp;&amp;stk[top]&gt;a[i])x=stk[top--]; son[a[i]][0]=x; top&amp;&amp;(son[stk[top]][1]=a[i]); stk[++top]=a[i]; &#125; dep[1]=1; dfs(1); sgt1::build(1,1,n); int ans=n+1,res=-1; for(ri l=1,dt=0,r=n;l&lt;=n;++l,++r,++dt)&#123; if(ans&gt;sgt1::mx[1])ans=sgt1::mx[1],res=dt; int ps1=sgt2::Ql(1,1,n&lt;&lt;1,l,r,a[l]); if(~ps1)&#123; if(ps1&lt;=n+1)sgt1::update(1,1,n,l,ps1-1,-1); else sgt1::update(1,1,n,l,n,-1),sgt1::update(1,1,n,1,ps1-1-n,-1); &#125; else sgt1::pushnow(1,-1); int ps2=sgt2::Qr(1,1,n&lt;&lt;1,l+1,r+1,a[l]); if(~ps2)&#123; if(ps2&lt;n)sgt1::update(1,1,n,ps2+1,n,1),sgt1::update(1,1,n,1,r+1-n,1); else sgt1::update(1,1,n,ps2+1-n,r+1-n,1); &#125; else sgt1::pushnow(1,1); sgt1::modify(1,1,n,l,~ps2?sgt1::query(1,1,n,ps2&lt;=n?ps2:ps2-n)+1:1); &#125; cout&lt;&lt;ans&lt;&lt;' '&lt;&lt;res; return 0;&#125; G考虑到一个等式： \\begin{aligned} \\sum\\limits_{i=1}^nd_i=&\\sum\\limits_{i=1}^n(x-x_i)^2+(y-y_i)^2\\\\ =&n(x^2+y^2)-2x\\sum\\limits_{i=1}^nx_i-2y\\sum\\limits_{i=1}^ny_i+\\sum\\limits_{i=1}^nx_i^2+y_i^2 \\end{aligned}然后把重心 $G$ 设置成新的原点，这样中间两坨就没了，变为： \\begin{aligned} (x-G_x)^2+(x-G_y)^2=\\frac1n\\sum\\limits_{i=1}^nd_i-(x_i-G_x)^2-(y_i-G_y)^2 \\end{aligned}不难看出这是一个圆的方程，即所有满足要求的解都在这个圆上，然后我们枚举 $a_1$ 所对的半径为 $d_i$ 来得到一个新的圆，求出所有圆的交点一一带入验证是否合法即可 由于数据随机因此复杂度是对的 注意直接 $long$ $double$ 有可能会炸精度，于是可以封装一个模意义下的实数来进行运算 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)typedef long long ll;typedef pair&lt;int,int&gt; pii;inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline ll readl()&#123; ll ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=1e5+5;const long double eps=1e-10;inline int sgn(long double x)&#123;return (x&gt;eps)-(x&lt;-eps);&#125;const int mod=1e9+7;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;template&lt;class T&gt;struct modular&#123; T vl; explicit operator T()const&#123;return vl;&#125; modular()&#123;vl=0;&#125; modular(const ll&amp;v)&#123;vl=v&gt;=-mod&amp;&amp;v&lt;=mod?v:v%mod,vl&lt;0?vl+=mod:0;&#125; friend inline bool operator==(const modular&amp;a,const modular&amp;b)&#123;return a.vl==b.vl;&#125; friend inline bool operator!=(const modular&amp;a,const modular&amp;b)&#123;return a.vl!=b.vl;&#125; friend inline bool operator&lt;(const modular&amp;a,const modular&amp;b)&#123;return a.vl&lt;b.vl;&#125; friend inline bool operator&gt;(const modular&amp;a,const modular&amp;b)&#123;return a.vl&gt;b.vl;&#125; friend inline bool operator&lt;=(const modular&amp;a,const modular&amp;b)&#123;return a.vl&lt;=b.vl;&#125; friend inline bool operator&gt;=(const modular&amp;a,const modular&amp;b)&#123;return a.vl&gt;=b.vl;&#125; inline modular operator-()const&#123;return mod-vl;&#125; friend inline modular operator+(const modular&amp;a,const modular&amp;b)&#123;return modular(a.vl+b.vl&lt;mod?a.vl+b.vl:a.vl+b.vl-mod);&#125; friend inline void operator+=(modular&amp;a,const modular&amp;b)&#123;a=a+b;&#125; friend inline modular operator-(const modular&amp;a,const modular&amp;b)&#123;return modular(a.vl&lt;b.vl?a.vl-b.vl+mod:a.vl-b.vl);&#125; friend inline void operator-=(modular&amp;a,const modular&amp;b)&#123;a=a-b;&#125; friend inline modular operator*(const modular&amp;a,const modular&amp;b)&#123;return modular((ll)a.vl*b.vl%mod);&#125; friend inline void operator*=(modular&amp;a,const modular&amp;b)&#123;a=a*b;&#125; friend inline modular operator^(modular a,ll p)&#123;modular ans=1;for(;p;p&gt;&gt;=1,a*=a)if(p&amp;1)ans*=a;return ans;&#125; friend inline void operator^=(modular&amp;a,const ll&amp;p)&#123;a=a^p;&#125; friend inline modular operator^(modular a,int p)&#123;modular ans=1;for(;p;p&gt;&gt;=1,a*=a)if(p&amp;1)ans*=a;return ans;&#125; friend inline void operator^=(modular&amp;a,const int&amp;p)&#123;a=a^p;&#125; friend inline modular inv(const modular&amp;a)&#123;return a^(mod-2);&#125; friend inline modular operator/(const modular&amp;a,const modular&amp;b)&#123;return modular(a*inv(b));&#125; friend inline void operator/=(modular&amp;a,const modular&amp;b)&#123;a=a/b;&#125; &#125;;typedef modular&lt;int&gt; mi;struct F&#123; mi x,y; F(mi x=mi(0),mi y=mi(0)):x(x),y(y)&#123;&#125; friend inline F operator+(F a,F b)&#123;return F(a.x+b.x,a.y+b.y);&#125; friend inline void operator+=(F&amp;a,F b)&#123;a=a+b;&#125; friend inline F operator-(F a,F b)&#123;return F(a.x-b.x,a.y-b.y);&#125; friend inline void operator-=(F&amp;a,F b)&#123;a=a-b;&#125; friend inline F operator/(F a,mi b)&#123;return F(a.x/b,a.y/b);&#125; friend inline void operator/=(F&amp;a,mi b)&#123;a=a/b;&#125; friend inline F operator*(F a,mi b)&#123;return F(a.x*b,a.y*b);&#125; friend inline void operator*=(F&amp;a,mi b)&#123;a=a*b;&#125; friend inline bool operator&lt;(F a,F b)&#123;return a.x!=b.x?a.x&lt;b.x:a.y&lt;b.y;&#125; friend inline bool operator==(F a,F b)&#123;return a.x==b.x&amp;&amp;a.y==b.y;&#125; inline mi mod()const&#123;return x*x+y*y;&#125;&#125;a[N],G,O1,O2;int W;inline int rd()&#123;return rand()|(rand()&lt;&lt;15);&#125;struct cp&#123; int x,y; cp(int x=0,int y=0):x(x),y(y)&#123;&#125; friend inline cp operator*(cp a,cp b)&#123;return cp(add(mul(a.x,b.x),mul(W,mul(a.y,b.y))),add(mul(a.x,b.y),mul(a.y,b.x)));&#125; friend inline cp operator^(cp a,ll p)&#123;cp res=cp(1,0);for(;p;p&gt;&gt;=1,a=a*a)if(p&amp;1)res=res*a;return res;&#125;&#125;;inline int Sqrt(int x)&#123; if(x==0)return 0; if(ksm(x,(mod-1)&gt;&gt;1)==mod-1)return -1; int a; while(1)&#123; a=(rd()%mod+mod)%mod,W=dec(mul(a,a),x); if(ksm(W,(mod-1)&gt;&gt;1)==mod-1)&#123; int res=(cp(a,1)^((mod+1)&gt;&gt;1)).x; return min(res,mod-res); &#125; &#125;&#125;int n;inline mi sq(mi x)&#123;return x*x;&#125;inline ll fix(mi x)&#123; int res=(int)x; if(res&gt;abs(res-mod))res-=mod; return res;&#125;vector&lt;pair&lt;ll,ll&gt; &gt;res;ll d[N],_d[N];inline ll dist(ll x,ll y,ll a,ll b)&#123;return (x-a)*(x-a)+(y-b)*(y-b);&#125;inline void check(F pt,ll dis)&#123; ll dx=fix(pt.x),dy=fix(pt.y); if(dist(dx,dy,(int)a[1].x,(int)a[1].y)!=dis)return; for(ri i=1;i&lt;=n;++i)_d[i]=dist(dx,dy,(int)a[i].x,(int)a[i].y); sort(_d+1,_d+n+1); for(ri i=1;i&lt;=n;++i)if(_d[i]!=d[i])return; res.pb(make_pair(dx,dy));&#125;inline void modify(F o1,mi r1,F o2,mi r2,ll dis)&#123; mi a=(o1.x-o2.x)*2,b=(o1.y-o2.y)*2,c=r2-r1+o1.mod()-o2.mod(); if(a!=0)&#123; b=b/a,c=c/a; mi A=b*b+1,B=(b*o1.x-b*c-o1.y)*2,C=(c-o1.x)*(c-o1.x)+o1.y*o1.y-r1,delta; B/=A,C/=A; delta=B*B-C*4; int res=Sqrt(delta.vl); mi x,y; if(res==-1)return; y=(-B+res)/2,x=c-y*b; check(F(x,y),dis); y=(-B-res)/2,x=c-y*b; check(F(x,y),dis); &#125; else&#123; mi y=c/b; int s=Sqrt((r1-sq(o1.y-y)).vl); if(s==-1)return; check(F(o1.x+s,y),dis); check(F(o1.x-s,y),dis); &#125;&#125;mi dall=mi(0),Dall=mi(0),R1,R2;int main()&#123; srand(time(NULL)); #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i].x=read(),a[i].y=read(),G=G+a[i],dall-=a[i].mod(); G=G/mi(n); if(a[1]==G)swap(a[1],a[2]); O1=G; O2=a[1]; dall+=n*G.mod(); for(ri tt=read();tt;--tt)&#123; Dall=dall; for(ri i=1;i&lt;=n;++i)d[i]=readl(),Dall+=d[i]; sort(d+1,d+n+1); res.clear(); R1=Dall/n; for(ri i=1;i&lt;=n;++i)&#123; if(i!=1&amp;&amp;d[i]==d[i-1])continue; R2=d[i]; modify(O1,R1,O2,R2,d[i]); &#125; sort(res.begin(),res.end()); res.erase(unique(res.begin(),res.end()),res.end()); cout&lt;&lt;res.size()&lt;&lt;' '; for(ri i=0;i&lt;res.size();++i)cout&lt;&lt;res[i].fi&lt;&lt;' '&lt;&lt;res[i].se&lt;&lt;' '; puts(\"\"); &#125; return 0;&#125; 告辞","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"2019.10.03 模拟测试题解","slug":"191003test","date":"2019-10-03T07:07:45.000Z","updated":"2019-10-11T15:33:35.719Z","comments":true,"path":"191003test/","link":"","permalink":"http://ldxcaicai.github.io/191003test/","excerpt":"","text":"A题意简述： 给出一个 $n$ 个点 $m$ 条边的带权有向图，要求删去某些边使得最后的图每个点的入度出度均不能超过 $1$ ，问删去的边权和最小值 数据范围： $n\\le200$ $m\\le10000$ 解题思路： 考虑简单补集转化，变为求保留的边权和最大值，然后考虑按照题意建图变成最大费用流问题或者说二分图最大匹配问题 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef long long ll;typedef pair&lt;int,int&gt; pii;#define fi first#define se secondconst int N=10005,M=2e6+5,inf=0x3f3f3f3f;struct edge&#123;int v,c,w,next;&#125;;int n,m;namespace mcmf&#123; ll dis[N],res,sum; int ps[N],cnt,first[N],s,t; bool in[N]; edge e[M]; inline void addedge(int u,int v,int c,int w)&#123; e[++cnt]=(edge)&#123;v,c,w,first[u]&#125;; first[u]=cnt; &#125; inline void add(int u,int v,int c,int w)&#123; addedge(u,v,c,w); addedge(v,u,0,-w); &#125; inline void init()&#123;memset(first,-1,sizeof(first)),cnt=-1,s=0,t=2*n+1,res=sum=0;&#125; inline bool bfs()&#123; queue&lt;int&gt;q; for(ri i=s;i&lt;=t;++i)dis[i]=-inf,ps[i]=-1; in[s]=1,dis[s]=0,q.push(s); while(q.size())&#123; int x=q.front(); q.pop(); in[x]=0; for(ri i=first[x],v;~i;i=e[i].next)&#123; v=e[i].v; if(e[i].c&gt;0&amp;&amp;dis[v]&lt;dis[x]+e[i].w)&#123; dis[v]=dis[x]+e[i].w; ps[v]=i; if(!in[v])in[v]=1,q.push(v); &#125; &#125; &#125; if(dis[t]==-inf)return 0; sum+=dis[t]; res=max(res,sum); int p=t; while(p^s)--e[ps[p]].c,++e[ps[p]^1].c,p=e[ps[p]^1].v; return 1; &#125; inline ll solve()&#123; while(bfs()); return res; &#125;&#125;int main()&#123; n=read(),m=read(); ll ss=0; mcmf::init(); for(ri i=1;i&lt;=n;++i)&#123; mcmf::add(mcmf::s,i,1,0); mcmf::add(i+n,mcmf::t,1,0); &#125; for(ri i=1,u,v,w;i&lt;=m;++i)&#123; u=read(),v=read(),w=read(); ss+=w; if(w&lt;=0)continue; mcmf::add(u,v+n,1,w); &#125; cout&lt;&lt;ss-mcmf::solve(); return 0;&#125; B题意简述： 给出一个 $n*m$ 的格子让你染色并给出染色的终态，保证每个位置颜色数值不超过 $C$ ，现在最初格子上都未被染过色，每次可以把某一行或者某一列染成一个相同的颜色，求染色次数最少的任意方案，无解输出 $-1$ 数据范围： $n,m\\le50$ $C\\le100$ 解题思路： 先思考如何得到可行解，然后对染色次数进行优化 考虑时间倒流，最后染上颜色后一定某一行或者某一列是同一种颜色，考虑删去这样的行或者列然后对剩下的矩阵迭代该操作，最后如果合法一定剩下一个全零矩阵，否则就非法 这样就成功得到了一个可行解，然后下面考虑两个简单优化： 假如当前非零行的个数不超过非零列的个数，那么优先消去一行，否则优先消去一列 假如当前有若干个合法的行/列，将其按照颜色分类，然后优先消去某种可行次数最少的颜色对应的任意一行/列 这样可以通过现有的所有数据点 想必会有数据能够×掉上述做法，毕竟正解要加一个topsoort并且笔者并不会证明上述做法正确性 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef long long ll;typedef pair&lt;int,int&gt; pii;int n,m,a[55][55],C;struct F&#123; int op,x,y; F(int op=0,int x=0,int y=0):op(op),x(x),y(y)&#123;&#125;&#125;;int cnt1[155],cnt2[155],Ps1[155],Ps2[155];vector&lt;F&gt;res;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(),C=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); vector&lt;int&gt;X,Y; for(ri i=1;i&lt;=n;++i)X.pb(i); for(ri i=1;i&lt;=m;++i)Y.pb(i); while(X.size()&amp;&amp;Y.size())&#123; int ct1=0,ct2=0; for(ri i=1;i&lt;=C;++i)cnt1[i]=0,cnt2[i]=0; for(ri i=0;i&lt;X.size();++i)&#123; bool ff=1; for(ri j=0;j&lt;Y.size();++j)if(a[X[i]][Y[j]])&#123; ff=0; break; &#125; if(ff)++ct1; &#125; for(ri i=0;i&lt;Y.size();++i)&#123; bool ff=1; for(ri j=0;j&lt;X.size();++j)if(a[X[j]][Y[i]])&#123; ff=0; break; &#125; if(ff)++ct2; &#125; if(ct1==X.size())break; int ps1=-1; for(ri i=0;i&lt;X.size();++i)&#123; bool ff=1; for(ri j=0;j&lt;Y.size();++j)&#123; if(!a[X[i]][Y[j]]||(j&amp;&amp;a[X[i]][Y[j]]!=a[X[i]][Y[j-1]]))&#123; ff=0; break; &#125; &#125; if(ff)&#123; ps1=i; ++cnt1[a[X[i]][Y[0]]]; Ps1[a[X[i]][Y[0]]]=i; &#125; &#125; int ps2=-1; for(ri i=0;i&lt;Y.size();++i)&#123; bool ff=1; for(ri j=0;j&lt;X.size();++j)&#123; if(!a[X[j]][Y[i]]||(j&amp;&amp;a[X[j]][Y[i]]!=a[X[j-1]][Y[i]]))&#123; ff=0; break; &#125; &#125; if(ff)&#123; ps2=i; ++cnt2[a[X[0]][Y[i]]]; Ps2[a[X[0]][Y[i]]]=i; &#125; &#125; if(ps1==-1&amp;&amp;ps2==-1)&#123; puts(\"-1\"); return 0; &#125; if(X.size()-ct1&lt;Y.size()-ct2)&#123; if(~ps1)&#123; int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt1[i])mn=min(mn,cnt1[i]); for(ri i=1;i&lt;=C;++i)if(cnt1[i]==mn)&#123;ps1=Ps1[i];break;&#125; res.pb(F(1,X[ps1],a[X[ps1]][Y[0]])); for(ri i=ps1+1;i&lt;X.size();++i)X[i-1]=X[i]; X.pop_back(); continue; &#125; else&#123; int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt2[i])mn=min(mn,cnt2[i]); for(ri i=1;i&lt;=C;++i)if(cnt2[i]==mn)&#123;ps2=Ps2[i];break;&#125; res.pb(F(0,Y[ps2],a[X[0]][Y[ps2]])); for(ri i=ps2+1;i&lt;Y.size();++i)Y[i-1]=Y[i]; Y.pop_back(); continue; &#125; &#125; else&#123; if(~ps2)&#123; int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt2[i])mn=min(mn,cnt2[i]); for(ri i=1;i&lt;=C;++i)if(cnt2[i]==mn)&#123;ps2=Ps2[i];break;&#125; res.pb(F(0,Y[ps2],a[X[0]][Y[ps2]])); for(ri i=ps2+1;i&lt;Y.size();++i)Y[i-1]=Y[i]; Y.pop_back(); continue; &#125; else&#123; int mn=0x3f3f3f3f; for(ri i=1;i&lt;=C;++i)if(cnt1[i])mn=min(mn,cnt1[i]); for(ri i=1;i&lt;=C;++i)if(cnt1[i]==mn)&#123;ps1=Ps1[i];break;&#125; res.pb(F(1,X[ps1],a[X[ps1]][Y[0]])); for(ri i=ps1+1;i&lt;X.size();++i)X[i-1]=X[i]; X.pop_back(); continue; &#125; &#125; &#125; cout&lt;&lt;res.size()&lt;&lt;'\\n'; for(ri i=res.size()-1;~i;--i)&#123; if(res[i].op)cout&lt;&lt;\"R \"; else cout&lt;&lt;\"C \"; cout&lt;&lt;res[i].x&lt;&lt;' '&lt;&lt;res[i].y&lt;&lt;'\\n'; &#125; return 0;&#125; C题意简述： 给你一棵带权树，每个点有一个限制 $d_i$ ，现在从时刻 $0$ 开始的每个时刻，对于每个限制被打破的节点会有一个人出发向根走，每个单位时间行走一个单位长度，当一个人经过某个点时，如果其限制未被打破，那么该点限制减一，当限制为 $0$ 时就视为被打破，保证叶子的限制一定是 $0$ ，询问树上的所有叶子的限制全部被打破的时刻 数据范围： $n\\le10^5$ $w_i\\le1000$ $d_i\\le10^8$ 解题思路： 考虑对每个节点建立时刻为横轴，已经过人数为纵轴的函数图像，这样的话对于每个节点相当于要支持如下操作： 将某个子树的函数图像的横坐标整体右移一个值 将所有子树的函数图像给叠加起来 在已经叠加好的图像中求出自己打破限制的时间 将自己打破限制之后的一次函数加到图像中 那么这就成了一道经典的折线题，考虑维护所有拐点，那么要维护的就是整体打标记，平衡树+启发式合并，二分求答案和单点插入，直接用 $Treap$ 维护即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_back#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=1e5+5;inline int rnd()&#123;return rand()|(rand()&lt;&lt;15);&#125;int rt[N],n,lm[N],tim[N],det[N];vector&lt;pii&gt;e[N];vector&lt;int&gt;tp;namespace bst&#123; #define lc (son[p][0]) #define rc (son[p][1]) int rd[N],vl[N],siz[N],tot=0,top=0,stk[N*20],son[N][2]; ll ss[N]; inline int newidx()&#123;return top?stk[top--]:++tot;&#125; inline int newnode(int v)&#123; int p=newidx(); lc=rc=0,vl[p]=ss[p]=v,rd[p]=rnd(),siz[p]=1; return p; &#125; inline void pushup(int p)&#123; siz[p]=siz[lc]+1+siz[rc]; ss[p]=ss[lc]+vl[p]+ss[rc]; &#125; inline int merge(int a,int b)&#123; if(!a||!b)return a|b; if(rd[a]&lt;rd[b])return son[a][1]=merge(son[a][1],b),pushup(a),a; return son[b][0]=merge(a,son[b][0]),pushup(b),b; &#125; inline pii split(int p,int k)&#123; if(!p)return pii(0,0); pii res; if(siz[lc]&gt;=k)return res=split(lc,k),lc=res.se,pushup(p),pii(res.fi,p); return res=split(rc,k-siz[lc]-1),rc=res.fi,pushup(p),pii(p,res.se); &#125; inline int rank(int p,int v)&#123; if(!p)return 0; if(vl[p]&lt;=v)return siz[lc]+1+rank(rc,v); return rank(lc,v); &#125; inline void insert(int _rt,int v)&#123; int k=rank(rt[_rt],v); pii x=split(rt[_rt],k); rt[_rt]=merge(x.fi,merge(newnode(v),x.se)); &#125; inline void update(int p,int det)&#123; if(!p)return; update(lc,det),update(rc,det); stk[++top]=p; tp.pb(vl[p]+det); &#125; inline int query(int _rt,int lm)&#123; int l=-1e9,r=1e9,res=1e9,mid,k; while(l&lt;=r)&#123; mid=l+r&gt;&gt;1,k=rank(rt[_rt],mid); pii x=split(rt[_rt],k); if((ll)mid*siz[x.fi]-ss[x.fi]&gt;=lm)r=mid-1,res=mid; else l=mid+1; rt[_rt]=merge(x.fi,x.se); &#125; return res; &#125; #undef lc #undef rc&#125;inline void Merge(int a,int b)&#123; if(bst::siz[rt[a]]&lt;bst::siz[rt[b]])swap(rt[a],rt[b]),swap(det[a],det[b]); bst::update(rt[b],det[b]-det[a]); while(tp.size())bst::insert(a,tp.back()),tp.pop_back();&#125;int ans=0,q[N],fa[N],vll[N],hd,tl;int main()&#123; srand(time(NULL)); #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)lm[i]=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); &#125; q[hd=tl=1]=1; while(hd&lt;=tl)&#123; int x=q[hd++]; for(ri i=0,v;i&lt;e[x].size();++i)&#123; if((v=e[x][i].fi)==fa[x])continue; vll[v]=e[x][i].se,fa[v]=x,q[++tl]=v; &#125; &#125; for(ri p,ft,i=n;i;--i)&#123; p=q[i],ft=fa[p]; if(!lm[p])tim[p]=-det[p]; else tim[p]=bst::query(p,lm[p]); ans=max(ans,det[p]+tim[p]); bst::insert(p,tim[p]); det[p]+=vll[p]; if(ft)Merge(ft,p); &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://ldxcaicai.github.io/tags/考试题解/"}]},{"title":"2019.10.02 模拟测试题解","slug":"191002test","date":"2019-10-02T12:49:11.000Z","updated":"2019-10-11T15:33:36.965Z","comments":true,"path":"191002test/","link":"","permalink":"http://ldxcaicai.github.io/191002test/","excerpt":"","text":"题目来源： $A:TCO499$ $1000pts$ $B:CF613E$ $C:出题人原创$ A题意简述： 在初始你自己创造一个由 $A,B,C,D$ 组成的长度为 $n$ 的字符串，给出有 $m$ 种转移，每种转移用两个长度相同的 $ABCD$ 串来表示，前者可以变成后者，然后进行若干次如下两种操作： 交换其中两个相邻字符 进行一次转移 问得到的不同字符串数的最大值 数据范围： $n\\le30$ $m\\le50$ 解题思路： 分析两种操作，第一个操作相当于告诉我们一个字符串可以由以下信息表示 $(cnt_a,cnt_b,cnt_c,cnt_d)$ ，而方案数则是 $C_{a}^a\\times C_{a+b}^b\\times C_{a+b+c}^c*C_{a+b+c+d}^d$ ，第二个操作相当于是建立边，这样相当于求一个有向图的带权最长链长度，只需要按照题意建出图来然后用 $tarjan+topsort$ 即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define ri register int#define pb push_backusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;typedef long long ll;const int mod=998244353;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=1e6+5;int n,m,all,col[N],trans[2][55][5];bool in[N];ll res=0,F[N],vl[N],C[35][35],mx[N];vector&lt;int&gt;e[N],E[N];char s[35];inline int idx(int a,int b,int c,int d)&#123;return (n+1)*(n+1)*(n+1)*a+(n+1)*(n+1)*b+(n+1)*c+d;&#125;inline void init()&#123; for(ri i=0;i&lt;=n;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=C[i-1][j-1]+C[i-1][j]; &#125; for(ri a=0,d;a&lt;=n;++a)for(ri b=0;a+b&lt;=n;++b) for(ri c=0;a+b+c&lt;=n;++c)&#123; d=n-a-b-c; F[idx(a,b,c,d)]=C[a][a]*C[a+b][b]*C[n-d][c]*C[n][d]; &#125;&#125;int tot=0,top=0,sig=0,dfn[N],low[N],stk[N],du[N];inline void dfs(int p)&#123; dfn[p]=low[p]=++tot; in[stk[++top]=p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if(!dfn[v=e[p][i]])dfs(v),low[p]=min(low[p],low[v]); else if(in[v])low[p]=min(low[p],dfn[v]); &#125; if(dfn[p]==low[p])&#123; ++sig; int x; while(1)&#123; x=stk[top--]; col[x]=sig,in[x]=0; vl[sig]+=F[x]; if(x==p)break; &#125; &#125;&#125;inline void topsort()&#123; queue&lt;int&gt;q; for(ri i=1;i&lt;=sig;++i)if(!du[i])q.push(i),mx[i]=vl[i]; while(q.size())&#123; int x=q.front(); q.pop(); for(ri i=0,v;i&lt;E[x].size();++i)&#123; v=E[x][i]; mx[v]=max(mx[v],mx[x]+vl[v]); if(!(--du[v]))q.push(v); &#125; &#125; for(ri i=1;i&lt;=sig;++i)res=max(res,mx[i]); cout&lt;&lt;res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); init(); for(ri len,i=1;i&lt;=m;++i)for(ri t=0;t&lt;2;++t)&#123;len=Read(s);for(ri j=1;j&lt;=len;++j)++trans[t][i][s[j]-'A'+1];&#125; int all=n*(n+1)*(n+1)*(n+1); for(ri a=0,d,_a,_b,_c,_d;a&lt;=n;++a)for(ri b=0;a+b&lt;=n;++b) for(ri c=0;a+b+c&lt;=n;++c)&#123; d=n-a-b-c; for(ri i=1;i&lt;=m;++i)&#123; _a=a-trans[0][i][1]; if(_a&lt;0)continue; _a+=trans[1][i][1]; _b=b-trans[0][i][2]; if(_b&lt;0)continue; _b+=trans[1][i][2]; _c=c-trans[0][i][3]; if(_c&lt;0)continue; _c+=trans[1][i][3]; _d=d-trans[0][i][4]; if(_d&lt;0)continue; _d+=trans[1][i][4]; e[idx(a,b,c,d)].pb(idx(_a,_b,_c,_d)); &#125; &#125; for(ri i=1;i&lt;=all;++i)if(!dfn[i])dfs(i); for(ri i=1;i&lt;=all;++i)for(ri j=0;j&lt;e[i].size();++j)if(col[i]^col[e[i][j]])E[col[i]].pb(col[e[i][j]]),++du[col[e[i][j]]]; topsort(); return 0;&#125; B题意简述： 给出一个 $2\\times n$ 的矩阵 $\\boldsymbol{A}$ ，矩阵中每个格子都是一个小写字母，同时有一个长度为 $M$ 的字符串 $S$问在矩阵中起点和终点任意，只允许向上、下、左、右走，不经过重复格子，且依次经过的字母连起来是 $S$ 的路径有多少种。 数据范围： $n\\le2000$ $m\\le2000$ 解题思路： 设路径的开头结尾是 $S,T$ ，那么所有合法路径可以划分成三段 ； 从 $S$ 开始向左走一段然后走回来 从 $T$ 开始向右走一段然后走回来 中间段上下上下的向右走 然后考虑对中间的进行 $dp$，设 $f_{i,j,k}$ 表示走到第 $i$ 行 $j$ 列匹配到第 $k$ 个字符的方案数，左边和右边直接用 $hash$ 搞一下，注意细节即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;typedef long long ll;const int mod=1e9+7,N=2005,bas=137;inline int add(const int&amp;a,const int&amp;b)&#123;return a+b&gt;=mod?a+b-mod:a+b;&#125;inline int dec(const int&amp;a,const int&amp;b)&#123;return a&gt;=b?a-b:a-b+mod;&#125;inline int mul(const int&amp;a,const int&amp;b)&#123;return (ll)a*b%mod;&#125;inline void update(int&amp;a,const int&amp;b)&#123;a=add(a,b);&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,a=mul(a,a))if(p&amp;1)ret=mul(ret,a);return ret;&#125;int n,m;int ans,fl[2][N][N],fr[2][N][N],pre[2][N],suf[2][N],h1[N],h2[N],hs[N],ihs[N];char s[2][N],t[N];inline int get_nl(int id,int l,int r)&#123;return mul(dec(pre[id][r],mul(pre[id][l-1],hs[r-l+1])),ihs[r-l+1]);&#125;inline int get_nr(int id,int l,int r)&#123;return mul(dec(suf[id][r],mul(suf[id][l+1],hs[l-r+1])),ihs[l-r+1]);&#125;inline int get_ml(int l,int r)&#123;return mul(dec(h1[r],mul(h1[l-1],hs[r-l+1])),ihs[r-l+1]);&#125;inline int get_mr(int l,int r)&#123;return mul(dec(h2[r],mul(h2[l+1],hs[l-r+1])),ihs[l-r+1]);&#125;inline void init_n()&#123; for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;2;++j)pre[j][i]=add(mul(pre[j][i-1],bas),s[j][i]); for(ri i=n;i;--i)for(ri j=0;j&lt;2;++j)suf[j][i]=add(mul(suf[j][i+1],bas),s[j][i]);&#125;inline void init_m()&#123; for(ri i=1;i&lt;=m;++i)h1[i]=add(mul(h1[i-1],bas),t[i]); for(ri i=m;i;--i)h2[i]=add(mul(h2[i+1],bas),t[i]);&#125;inline void init()&#123; hs[0]=ihs[0]=1; for(ri i=1;i&lt;=n;++i)hs[i]=mul(hs[i-1],bas),ihs[i]=ksm(hs[i],mod-2); init_n(); init_m();&#125;int main()&#123; scanf(\"%s%s%s\",s[0]+1,s[1]+1,t+1); n=strlen(s[0]+1),m=strlen(t+1); init(); for(ri i=1;i&lt;=n;++i)&#123; for(ri id=0;id&lt;2;++id)update(fl[id][i+1][2],s[id][i]==t[1]),update(fr[id][i+1][m-1],(m^1)&amp;&amp;s[id][i]==t[m]); for(ri j=2,up=min(n-i+1,m/2);j&lt;=up;++j)for(ri id=0;id&lt;2;++id)&#123; update(ans,get_nl(id^1,i,i+j-1)==get_mr(m,m-j+1)&amp;&amp;get_nr(id,i+j-1,i)==get_mr(m-j,m-j*2+1)&amp;&amp;j*2==m); update(ans,get_nl(id^1,i,i+j-1)==get_mr(m,m-j+1)&amp;&amp;get_nr(id,i+j-1,i)==get_mr(m-j,m-j*2+1)?fl[id][i][m-j*2+1]:0); update(ans,get_nl(id^1,i,i+j-1)==get_ml(1,j)&amp;&amp;get_nr(id,i+j-1,i)==get_ml(j+1,j*2)?fr[id][i][j*2]:0); &#125; for(ri j=1;j&lt;=m;++j)for(ri id=0;id&lt;2;++id)if(s[id][i]==t[j])&#123; update(fl[id][i+1][j+1],fl[id][i][j]),update(fl[id^1][i+1][j+2],(j^m)&amp;&amp;s[id^1][i]==t[j+1]?fl[id][i][j]:0); update(fr[id][i+1][j-1],fr[id][i][j]),update(fr[id^1][i+1][j-2],(j^1)&amp;&amp;s[id^1][i]==t[j-1]?fr[id][i][j]:0); &#125; for(ri id=0;id&lt;2;++id)update(ans,add(fl[id][i+1][m+1],fr[id][i+1][0])); for(ri j=1,up=min(i,m/2);j&lt;=up;++j)for(ri id=0;id&lt;2;++id)&#123; update(ans,get_nr(id^1,i,i-j+1)==get_ml(1,j)&amp;&amp;get_nl(id,i-j+1,i)==get_ml(j+1,j*2)&amp;&amp;j*2==m); update(fl[id][i+1][j*2+1],get_nr(id^1,i,i-j+1)==get_ml(1,j)&amp;&amp;get_nl(id,i-j+1,i)==get_ml(j+1,j*2)); update(fr[id][i+1][m-j*2],get_nr(id^1,i,i-j+1)==get_mr(m,m-j+1)&amp;&amp;get_nl(id,i-j+1,i)==get_mr(m-j,m-j*2+1)); &#125; &#125; cout&lt;&lt;ans; return 0;&#125; C题意简述： 求 $\\sum\\limits_{i=1}^n\\mu(i)i^m$ 数据范围： $n\\le10^9$ $m\\le2*10^5$ 解题思路： 令 $f(x)=\\mu(x)x^m,S(x)=\\sum\\limits_{i=1}^xf(i)$ 考虑构造 $g(x)=x^m,h=f\\times g\\Rightarrow h(x)=[i==1]i^m=\\epsilon(x)$ 故可以用杜教筛，现在问题转换成求 $\\sqrt n$ 个 $\\sum\\limits_{i=1}^xi^m$ 的值，在空间限制不严的情况下可以合理的平衡结合预处理范围+拉格朗日插值或者直接用多项式多点插值 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ri register intusing namespace std;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;typedef long long ll;const int mod=998244353;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=3e6+5;int mu[N],pri[N],ss[N],F1[N],tot=0,up,n,m,lm,lagup,lagf[N],fac[N],ifac[N],F2[N];bool vs[N],Vs1[N],Vs2[N];map&lt;int,int&gt;S;inline int lagrange(int x)&#123; if(x&lt;=up)return lagf[x]; if(S.count(x))return S[x]; static int pre[N],suf[N]; int res=0; pre[0]=suf[lagup+1]=1; for(ri i=1;i&lt;=lagup;++i)pre[i]=mul(pre[i-1],(x-i)%mod); for(ri i=lagup;i;--i)suf[i]=mul(suf[i+1],(x-i)%mod); for(ri t,i=1;i&lt;=lagup;++i)&#123; t=mul(lagf[i],mul(mul(ifac[i-1],ifac[lagup-i]),mul(pre[i-1],suf[i+1]))); (lagup-i)&amp;1?Dec(res,t):Add(res,t); &#125; return S[x]=res;&#125;inline void init()&#123; lagup=m+2,lagf[1]=fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=lagup;++i)fac[i]=mul(fac[i-1],i),ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); for(ri i=2;i&lt;=lagup;++i)Mul(ifac[i],ifac[i-1]); mu[1]=ss[1]=1; for(ri i=2;i&lt;=up;++i)&#123; if(!vs[i])pri[++tot]=i,mu[i]=mod-1; lagf[i]=ksm(i,m); ss[i]=add(ss[i-1],mul(mu[i],lagf[i])); Add(lagf[i],lagf[i-1]); for(ri j=1,lm=up/i;j&lt;=tot&amp;&amp;pri[j]&lt;=lm;++j)&#123; vs[i*pri[j]]=1; if(i==i/pri[j]*pri[j])&#123;mu[i*pri[j]]=0;break;&#125; mu[i*pri[j]]=dec(0,mu[i]); &#125; &#125;&#125;map&lt;int,int&gt;F;inline int Sum1(int x)&#123; if(x&lt;=up)return ss[x]; if(F.count(x))return F[x]; int res=1; for(ri l=2,r;l&lt;=x;l=r+1)&#123; r=x/(x/l); Dec(res,mul(dec(lagrange(r),lagrange(l-1)),Sum1(x/l))); &#125; return F[x]=res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); up=3e6,init(); cout&lt;&lt;Sum1(n); return 0;&#125; 多项式多点插值估计等博主身体好了再更 有生之年","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://ldxcaicai.github.io/tags/考试题解/"}]},{"title":"2019.09.30 模拟测试题解","slug":"190930test","date":"2019-10-01T03:57:51.000Z","updated":"2019-10-11T15:33:38.015Z","comments":true,"path":"190930test/","link":"","permalink":"http://ldxcaicai.github.io/190930test/","excerpt":"","text":"A题意简述： 给出 $n$ 个长度相同的串，现在在这 $n$ 个串中随机选择一个作为答案串，然后你现在每次随机猜一个之前未猜过的位置，在能够凭借已有的信息确定出答案串的时候游戏结束，问猜位置的期望次数 数据范围： $n\\le50$ $len\\le20$ 解题思路： 考虑一个 $O(nl2^l)$ 的暴力状压 $dp$ ，即枚举答案串是啥，然后 $f_{s}$ 表示该情况下猜过位置集合为 $s$ 时离结束的期望步数，并令 $cnt$ 是当前集合猜过的位置数量，那么可以进行如下转移： 集合 $s$ 中的位置可以区分出答案串和其余串，则有 $f_{s}=0$ 集合 $s$ 中的位置不能区分出答案串和其余串，那么 $f_s=1+\\frac1{len-cnt}\\sum\\limits_{i,i\\not \\in s}f_{s\\cup i}$ 这样可以拿到 $60^+pts$ 现在考虑优化，容易发现可以把 $n$ 个串压在一起转移，具体来说，考虑预处理出 $Cnt_s$ 表示集合 $s$ 不能区分开的串的个数，这样第二种转移变为 $f_s=Cnt_s+\\frac1{len-cnt}\\sum\\limits_{i,i\\not \\in s}f_{s\\cup i}$ 最后答案为 $\\frac{f_0}n$ ，因为我们把所有串压在了一起因此期望要带一个 $\\frac 1n$ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=1e5+5;int n,K,len;char s[55][25];double f[1&lt;&lt;20];int cnt[1&lt;&lt;20];bool vs[1&lt;&lt;20];ll sm[1&lt;&lt;20];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline double dfs(int sta,int ct)&#123; if(vs[sta])return f[sta]; vs[sta]=1,f[sta]=0; if(cnt[sta]==n)return f[sta]=0; int s=((1&lt;&lt;len)-1)^sta,t; while(s)&#123; t=lowbit(s); f[sta]+=dfs(sta|t,ct+1); s^=t; &#125; return (f[sta]/=(len-ct))+=n-cnt[sta];&#125;int main()&#123; n=read(); for(ri i=1;i&lt;=n;++i)len=Read(s[i]); for(ri i=1;i&lt;=n;++i)for(ri st=0,j=1;j&lt;=n;++j,st=0)if(i!=j)&#123; for(ri k=1;k&lt;=len;++k)if(s[i][k]==s[j][k])st|=1&lt;&lt;(k-1); sm[st]|=1ll&lt;&lt;(i-1); &#125; sm[0]=(1ll&lt;&lt;n)-1; for(ri a,b,s=(1&lt;&lt;len)-1;~s;--s)&#123; for(ri i=1;i&lt;=n;++i)if(!(sm[s]&gt;&gt;(i-1)&amp;1))++cnt[s]; a=s; while(a)&#123; b=lowbit(a); sm[s^b]|=sm[s]; a^=b; &#125; &#125; printf(\"%.10lf\",dfs(0,0)/n); return 0;&#125; B题意简述： 给你 $n$ 个点，现在询问 $m=1,2,3,\\cdots,n$ 个点的生成树个数，如果 $i$ 在生成树里，其度数不超过 $d_i$ 数据范围： $n\\le100$ 解题思路： 考虑利用 $prufer$ 序列的如下性质： 对于一棵 $n$ 个点的树， $\\sum du_i=2n-2$ 对于一棵 $n$ 个点的树，每个点在 $prufer$ 序列中出现 $du_i-1$ 次 每棵树和其 $prufer$ 序列满足双射关系 那么问题转化成了一个非常显然的二元生成函数问题，由于数据范围很小可以直接用背包代替多项式乘法 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=1e9+7;typedef vector&lt;int&gt; poly;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;mod?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))(p&amp;1)&amp;&amp;(Mul(ret,a),1);return ret;&#125;const int N=105;int n,f[2][N][N],cur=0,C[N][N];inline void init()&#123; for(ri i=0;i&lt;=n;++i)&#123; C[i][0]=1; for(ri j=1;j&lt;=i;++j)C[i][j]=add(C[i-1][j],C[i-1][j-1]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); f[cur=0][0][0]=1; init(); for(ri t=1,du;t&lt;=n;++t)&#123; cur^=1; du=read(); for(ri i=0;i&lt;=t;++i)for(ri j=0;j&lt;=n-2;++j)f[cur][i][j]=f[!cur][i][j]; for(ri i=0;i&lt;=t;++i)for(ri j=0;j&lt;=n-2;++j)if(f[!cur][i][j]) for(ri k=0;k&lt;du&amp;&amp;j+k&lt;=n-2;++k)Add(f[cur][i+1][j+k],mul(f[!cur][i][j],C[j+k][j])); &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;(i==1?n:f[cur][i][i-2])&lt;&lt;' '; return 0;&#125; C题意简述： 给出一个字符串，要求强制在线支持如下操作： 在当前串尾加上一个字符 $c$ 询问区间 $[l,r]$ 中的不同子串数 数据范围： $n,m\\le50000$ 解题思路： 显然需要补集转化变成求重复子串数，考虑建出 $link-cut-parent$ $tree$，然后考虑在字符串结尾加一个字符对子串数影响，发现就是把其对应动态树上的一条链的信息改掉，而对于 $endpos$ 相同的集合它们对应的子串的左端点也是连续的，于是可以把 $endpos$ 相同的放到一棵 $splay$ 里，然后每次加点就成了 $access$ 操作，显然能用主席树辅助维护答案 但直接这样做有个小毛病，是对于维护答案信息不能随意的进行 $access$ 操作，于是 $cut$ 操作也不能用了，这样的话在 $clone$ 节点需要弄一个小 $trick$ ，就是每次我们先 $access$ 新的 $endpos$ 对应的链，这个时候被 $clone$ 的点成为虚儿子，可以直接将 $cut$ 变成换父亲操作 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int N=2e5+5,M=N*100;int lm;namespace sgt&#123; #define lc (son[p][0]) #define rc (son[p][1]) #define mid (l+r&gt;&gt;1) int son[M][2],tg[M],tot=0; ll ss[M]; inline void update(int&amp;o,int l,int r,int ql,int qr,int v)&#123; if(ql&gt;qr)return; int p=++tot; lc=son[o][0],rc=son[o][1],ss[p]=ss[o],tg[p]=tg[o]; o=p; ss[p]+=(ll)(min(qr,r)-max(ql,l)+1)*v; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123;tg[p]+=v;return;&#125; if(qr&lt;=mid)update(lc,l,mid,ql,qr,v); else if(ql&gt;mid)update(rc,mid+1,r,ql,qr,v); else update(lc,l,mid,ql,qr,v),update(rc,mid+1,r,ql,qr,v); &#125; inline ll query(int p,int l,int r,int ql,int qr)&#123; if(!p)return 0ll; if(ql&lt;=l&amp;&amp;r&lt;=qr)return ss[p]; int res=(ll)(min(qr,r)-max(ql,l)+1)*tg[p]; if(qr&lt;=mid)return res+query(lc,l,mid,ql,qr); if(ql&gt;mid)return res+query(rc,mid+1,r,ql,qr); return res+query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); &#125; #undef mid #undef lc #undef rc&#125;int rt[N],n;namespace lct&#123; #define lc (son[p][0]) #define rc (son[p][1]) int son[N][2],fa[N],edpos[N],tg[N],len[N]; inline void pushnow(int p,int v)&#123;tg[p]=edpos[p]=v;&#125; inline void pushdown(int p)&#123;tg[p]&amp;&amp;(pushnow(lc,tg[p]),pushnow(rc,tg[p]),tg[p]=0);&#125; inline bool isroot(int x)&#123;return !fa[x]||((son[fa[x]][0]^x)&amp;&amp;(son[fa[x]][1]^x));&#125; inline bool which(int x)&#123;return x==son[fa[x]][1];&#125; inline void rotate(int x)&#123; int y=fa[x],z=fa[y],t=which(x); if(!isroot(y))son[z][which(y)]=x; fa[x]=z,fa[y]=x,son[y][t]=son[x][t^1],son[x][t^1]=y; son[y][t]&amp;&amp;(fa[son[y][t]]=y); &#125; inline void splay(int x)&#123; static int stk[N],top=0; stk[top=1]=x; for(ri i=x;!isroot(i);i=fa[i])stk[++top]=fa[i]; while(top)pushdown(stk[top--]); while(!isroot(x))&#123; if(!isroot(fa[x]))rotate(which(x)^which(fa[x])?x:fa[x]); rotate(x); &#125; &#125; inline void access(int x,int ps)&#123; int y=0; for(;x;x=fa[y=x])&#123; splay(x),son[x][1]=y; edpos[x]&amp;&amp;(sgt::update(rt[ps],1,lm,edpos[x]-len[x]+1,edpos[x]-len[fa[x]],1),1); &#125; pushnow(y,ps); &#125; inline int queryid(int x)&#123;return splay(x),edpos[x];&#125; inline void link(int x,int y)&#123;splay(x),fa[x]=y;&#125; #undef lc #undef rc&#125;namespace sam&#123; int son[N][26],tot,last,len[N],link[N]; inline void init()&#123;tot=last=1;&#125; inline void insert(int x,int id)&#123; int np=++tot,p=last; rt[id]=rt[id-1]; last=np,lct::len[np]=len[np]=len[p]+1; while(p&amp;&amp;!son[p][x])son[p][x]=np,p=link[p]; if(!p)&#123;lct::link(np,link[np]=1),lct::access(np,id);return;&#125; int q=son[p][x],nq; if(len[q]==len[p]+1)&#123;lct::link(np,link[np]=q),lct::access(np,id);return;&#125; nq=++tot,len[nq]=lct::len[nq]=len[p]+1,memcpy(son[nq],son[q],sizeof(son[q])); lct::edpos[nq]=lct::queryid(q); lct::link(nq,link[nq]=link[q]); lct::link(np,link[np]=nq),lct::access(np,id); lct::link(q,link[q]=nq); while(p&amp;&amp;son[p][x]==q)son[p][x]=nq,p=link[p]; &#125;&#125;int D,m;char s[N],ch;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif D=read(),n=Read(s),m=read(); ll lastans=0; lm=m+n; sam::init(); for(ri i=1;i&lt;=n;++i)sam::insert(s[i]-'a',i); for(ri op,l,r;m;--m)&#123; op=read(); if(op==1)&#123; ch=gc(); while(!isalpha(ch))ch=gc(); ++n; sam::insert(((ll)(ch-'a')+lastans)%26,n); &#125; else&#123; l=(lastans-1+read())%n+1; r=(lastans-1+read())%n+1; cout&lt;&lt;(lastans=(((ll)(r-l+1)*(r-l+2)/2)-sgt::query(rt[r],1,lm,l,r)))&lt;&lt;'\\n'; &#125; lastans*=D; &#125; return 0;&#125;","categories":[{"name":"private","slug":"private","permalink":"http://ldxcaicai.github.io/categories/private/"}],"tags":[{"name":"考试题解","slug":"考试题解","permalink":"http://ldxcaicai.github.io/tags/考试题解/"}]},{"title":"CodeForces 1208 简要题解","slug":"CF1208","date":"2019-09-29T07:31:41.000Z","updated":"2019-10-22T23:48:12.081Z","comments":true,"path":"CF1208/","link":"","permalink":"http://ldxcaicai.github.io/CF1208/","excerpt":"","text":"A按照模 $3$ 余数分类即可 CODE 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read()&#123; #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;int a[3];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; a[0]=read(),a[1]=read(),a[2]=a[1]^a[0]; cout&lt;&lt;a[read()%3]&lt;&lt;'\\n'; &#125; return 0;&#125; B双指针模拟即可 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read()&#123; #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=2005;int a[N],n;map&lt;int,int&gt;id;int cnt[N],sum=0;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); int tot=0; for(ri i=1;i&lt;=n;++i)&#123; a[i]=read(); if(!id[a[i]])id[a[i]]=++tot; ++cnt[id[a[i]]]; if(cnt[id[a[i]]]==2)++sum; &#125; if(!sum)return puts(\"0\"),0; int ans=n; for(ri l=1;l&lt;=n;++l)&#123; for(ri r=l;r&lt;=n;++r)&#123; --cnt[id[a[r]]]; if(cnt[id[a[r]]]==1)--sum; if(!sum)ans=min(ans,r-l+1); &#125; for(ri r=l;r&lt;=n;++r)&#123; ++cnt[id[a[r]]]; if(cnt[id[a[r]]]==2)++sum; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; C每 $16$ 个数为一组构造即可 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read()&#123; #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=2005;int n,ans[N][N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri l=0,r=15,a,b,i=0;i&lt;n;i+=4)for(ri j=0;j&lt;n;j+=4)&#123; a=i,b=j; ans[a][b]=l; ans[a][b+1]=l+1; ans[a+1][b]=l+2; ans[a+1][b+1]=l+3; a=i,b=j+2; l+=4; ans[a][b]=l+2; ans[a][b+1]=l+3; ans[a+1][b]=l; ans[a+1][b+1]=l+1; a=i+2,b=j; l+=4; ans[a][b]=l+1; ans[a][b+1]=l; ans[a+1][b]=l+3; ans[a+1][b+1]=l+2; a=i+2,b=j+2; l+=4; ans[a][b]=l+3; ans[a][b+1]=l+2; ans[a+1][b]=l+1; ans[a+1][b+1]=l; l+=4; &#125; for(ri i=0;i&lt;n;++i,puts(\"\"))for(ri j=0;j&lt;n;++j)cout&lt;&lt;ans[i][j]&lt;&lt;' '; return 0;&#125; D用个线段树模拟即可 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;inline int read()&#123; #define gc getchar int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline ll readl()&#123; #define gc getchar ll ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=2e5+5;int n,w;namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) ll ss[N&lt;&lt;2]; inline void build(int p,int l,int r)&#123; if(l==r)&#123;ss[p]=l;return;&#125; build(lc,l,mid),build(rc,mid+1,r); ss[p]=ss[lc]+ss[rc]; &#125; inline void update(int p,int l,int r,int k)&#123; if(l==r)&#123;ss[p]=0;return;&#125; if(k&lt;=mid)update(lc,l,mid,k); else update(rc,mid+1,r,k); ss[p]=ss[lc]+ss[rc]; &#125; inline int query(int p,int l,int r,ll v)&#123; if(l==r)return l; if(ss[lc]&gt;v)return query(lc,l,mid,v); return query(rc,mid+1,r,v-ss[lc]); &#125; #undef lc #undef rc #undef mid&#125;int a[N];ll s[N];int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); sgt::build(1,1,n); for(ri i=1;i&lt;=n;++i)s[i]=readl(); for(ri i=n;i;--i)&#123; a[i]=sgt::query(1,1,n,s[i]); sgt::update(1,1,n,a[i]); &#125; for(ri i=1;i&lt;=n;++i)cout&lt;&lt;a[i]&lt;&lt;' '; return 0;&#125; E观察一下发现可以对每一行用的贡献用单调队列/线段树/st表统计，但是最后要统计 $m$ 行的总贡献，然后发现每行的状态有以下几类： 开始的前 $k$ 个 结尾的前 $k$ 个 中间部分 这三段的贡献是类似的，可以分类+差分统计 CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int mod=998244353;typedef pair&lt;int,int&gt; pii;typedef long long ll;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Add(int&amp;a,int b)&#123;(a+=b)&lt;mod?a:(a-=mod);&#125;inline void Dec(int&amp;a,int b)&#123;(a-=b)&lt;0?(a+=mod):a;&#125; inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;inline int ksm(int a,int p)&#123;int ret=1;for(;p;p&gt;&gt;=1,Mul(a,a))if(p&amp;1)Mul(ret,a);return ret;&#125;const int N=1e6+50;int n,w,a[N];ll ans[N],ad[N];namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) ll mx[N&lt;&lt;2]; inline void build(int p,int l,int r)&#123; if(l==r)&#123;mx[p]=a[l];return;&#125; build(lc,l,mid),build(rc,mid+1,r); mx[p]=max(mx[lc],mx[rc]); &#125; inline int query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return mx[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return max(query(lc,l,mid,ql,qr),query(rc,mid+1,r,ql,qr)); &#125; #undef lc #undef rc #undef mid&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),w=read()+2; for(ri tt=1,m;tt&lt;=n;++tt)&#123; m=read(); for(ri i=2;i&lt;=m+1;++i)a[i]=read(); m+=2; a[1]=a[m]=0; sgt::build(1,1,m); if(w&lt;=m*3-1)for(ri i=1;i&lt;=w;++i)ans[i]+=sgt::query(1,1,m,max(1,i-w+m),min(i,m)); else&#123; for(ri i=1;i&lt;m;++i)ans[i]+=sgt::query(1,1,m,1,i); for(ri i=w;i&gt;w-m+1;--i)ans[i]+=sgt::query(1,1,m,m+i-w,m); ad[m]+=sgt::mx[1]; ad[w-m+2]-=sgt::mx[1]; &#125; &#125; for(ri i=1;i&lt;=w;++i)&#123; ad[i]+=ad[i-1]; ans[i]+=ad[i]; &#125; for(ri i=2;i&lt;=w-1;++i)cout&lt;&lt;ans[i]&lt;&lt;' '; return 0;&#125; F直接暴力+二进制枚举子集更新即可，每个集合最多被更新两次因此复杂度是对的~ 没想到吧 然后比赛的时候是个dd 其实我现在也是dd CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=1&lt;&lt;21|5;int cnt[N],a[N],n,lst[N],ans=0;inline void update(int vl,int ps)&#123; if(cnt[vl]&gt;=2||lst[vl]==ps)return; lst[vl]=ps,++cnt[vl]; for(ri i=21;~i;--i)if(vl&gt;&gt;i&amp;1)update(vl^(1&lt;&lt;i),ps);&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1;i&lt;=n;++i)a[i]=read(); for(ri t,res,i=n;i;--i)&#123; if(i&lt;=n-2)&#123; t=((1&lt;&lt;22)-1)^a[i],res=0; for(ri j=21;~j;--j)if(t&gt;&gt;j&amp;1)if(cnt[res|(1&lt;&lt;j)]==2)res|=1&lt;&lt;j; ans=max(ans,res|a[i]); &#125; update(a[i],i); &#125; cout&lt;&lt;ans; return 0;&#125; G钦定所有的多边形的某一个顶点重合与同一个点，发现之后假如要选 $x,x\\ge3$ ，且 $x$ 的所有约数已经被选，那么它会增加 $\\phi (x)$ 个点 ，由于对于每个数 $x$ 和它的因子 $y$ 满足 $\\phi(x)\\ge\\phi(y)$ ，因此直接考虑把所有合法的数按照 $\\phi$ 值大小排序过后贪心选择，注意特判一下 $k=1,2$ 的情况~ CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se secondusing namespace std;const int rlen=1&lt;&lt;18|1;inline char gc()&#123; static char buf[rlen],*ib,*ob; (ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)); return ib==ob?-1:*ib++;&#125;inline int read()&#123; int ans=0; bool f=1; char ch=gc(); while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef long long ll;const int N=2e6+5;int n,k,pri[N],tot=0,phi[N];bool vis[N];inline void init()&#123; phi[1]=1; for(ri i=2;i&lt;=n;++i)&#123; if(!vis[i])pri[++tot]=i,phi[i]=i-1; for(ri j=1;j&lt;=tot&amp;&amp;i*pri[j]&lt;=n;++j)&#123; vis[i*pri[j]]=1; if(i==i/pri[j]*pri[j])&#123; phi[i*pri[j]]=phi[i]*pri[j]; break; &#125; phi[i*pri[j]]=phi[i]*(pri[j]-1); &#125; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),k=read(); if(k==1)return puts(\"3\"),0; init(); sort(phi+3,phi+n+1); ll ans=0; for(ri i=3,j=1;j&lt;=k;++j,++i)ans+=phi[i]; cout&lt;&lt;ans+2; return 0;&#125; H神仙 $DDP$ 首先转化问题，发现是当 $b-r&lt;k$ 时颜色为 $r$ 考虑对每个点规定一个时间 $t(x)$ ,对于叶子结点，表示点 $x$ 在 $k\\ge t(x)$ 时会变成 $r$ ，如果颜色为 $r$ ， $t(x)=-inf$ 否则 $t(x)=inf$ ，对于非叶子节点显然可以把它儿子的信息插入到平衡树中然后通过调整法求出 $t(x)$ 这样的话，我们只需要对于一个 $x$ ，判断其 $t(x)$ 和 $k$ 的大小关系进而判断它的颜色 于是只需要考虑如何修改叶子的颜色 经过思考发现单纯的 $t(x)$ 并不好合并，于是我们进行如下精彩变换： 对树进行重链剖分，定义 $t(x,0/1)$ 表示当 $x$ 的重儿子是 $r/b$ 的时候它成为 $r$ 的最小时刻，这样就可以将 $t(x,0/1)$ 进行合并，而轻儿子的维护沿用上述平衡树做法即可 CODE(fhq_treap) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef pair&lt;int,int&gt; pii;const int N=1e6+5;int rt[N],n;inline int rnd()&#123;return rand()|(rand()&lt;&lt;15);&#125;namespace bst&#123; #define lc (son[p][0]) #define rc (son[p][1]) int son[N][2],siz[N],vl[N],rd[N]; int stk[N],top=0,tot=0; inline int newidx()&#123;return ++tot;&#125; inline int newnode(int v)&#123; int p=newidx(); lc=rc=0,siz[p]=1,vl[p]=v,rd[p]=rnd(); return p; &#125; inline int pushup(int p)&#123;siz[p]=(!p?0:siz[lc]+1+siz[rc]);&#125; inline int merge(int a,int b)&#123; if(!a||!b)return a|b; if(rd[a]&lt;rd[b])return son[a][1]=merge(son[a][1],b),pushup(a),a; return son[b][0]=merge(a,son[b][0]),pushup(b),b; &#125; inline pii split(int p,int k)&#123; if(!p)return pii(0,0); pii res; if(siz[lc]&gt;=k)return res=split(lc,k),lc=res.se,pushup(p),pii(res.fi,p); return res=split(rc,k-siz[lc]-1),rc=res.fi,pushup(p),pii(p,res.se); &#125; inline int rank(int p,int v)&#123; if(!p)return 0; if(vl[p]&gt;v)return rank(lc,v); return siz[lc]+1+rank(rc,v); &#125; inline void insert(int&amp;rt,int v)&#123; int rk=rank(rt,v); pii x=split(rt,rk); rt=merge(merge(x.fi,newnode(v)),x.se); &#125; inline void delet(int&amp;rt,int v)&#123; int rk=rank(rt,v); pii x=split(rt,rk-1),y=split(x.se,1); rt=merge(x.fi,y.se),y.fi&amp;&amp;(stk[++top]=y.fi); &#125; #undef lc #undef rc&#125;struct F&#123; int l,r; F(int l=0,int r=0):l(l),r(r)&#123;&#125; friend inline F operator+(F a,F b)&#123;return F(min(max(a.l,b.l),a.r),min(max(a.l,b.r),a.r));&#125;&#125;;const int inf=1e9;int K,tg[N];int siz[N],hson[N],dep[N],top[N],fa[N],num[N],pred[N],bot[N],col[N],tot=0;vector&lt;int&gt;e[N];void dfs1(int p)&#123; siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==fa[p])continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]])hson[p]=v; &#125;&#125;void dfs2(int p,int tp)&#123; top[p]=tp,bot[tp]=p,pred[num[p]=++tot]=p; if(!hson[p])return; dfs2(hson[p],tp); for(ri i=0,v;i&lt;e[p].size();++i)if((v=e[p][i])!=fa[p]&amp;&amp;v!=hson[p])dfs2(v,v);&#125;namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) F vl[N&lt;&lt;2]; inline void pushup(int p)&#123;vl[p]=vl[lc]+vl[rc];&#125; inline F query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); &#125; inline bool check(int p,int k,int dt)&#123; int R=bst::rank(rt[p],k)+dt,B=bst::siz[rt[p]]+1-R; return B-R&lt;k; &#125; inline void fix(int p,int&amp;k,int dt)&#123; while(check(p,k-1,dt))--k; while(!check(p,k,dt))++k; &#125; inline void getval(int p,int k)&#123; if(col[k]==1)vl[p]=F(inf,inf); else if(!col[k])vl[p]=F(-inf,-inf); else&#123; fix(k,vl[p].l,1); fix(k,vl[p].r,0); &#125; &#125; inline void build(int p,int l,int r)&#123; if(l==r)&#123; int k=pred[l]; getval(p,k); if(k==top[k]&amp;&amp;fa[k])&#123; if(bot[k]==k)bst::insert(rt[fa[k]],tg[k]=vl[p].l); else bst::insert(rt[fa[k]],tg[k]=(vl[p]+query(1,1,n,l+1,num[bot[k]])).l); &#125; return; &#125; build(rc,mid+1,r),build(lc,l,mid); pushup(p); &#125; inline void update(int p,int l,int r,int k)&#123; if(l==r)return getval(p,pred[l]); k&lt;=mid?update(lc,l,mid,k):update(rc,mid+1,r,k); pushup(p); &#125; #undef mid #undef lc #undef rc&#125;inline void change(int p)&#123; int tp,ftp; while(p)&#123; tp=top[p],ftp=fa[top[p]]; sgt::update(1,1,n,num[p]); if(ftp)&#123; bst::delet(rt[ftp],tg[tp]); bst::insert(rt[ftp],tg[tp]=sgt::query(1,1,n,num[tp],num[bot[tp]]).l); &#125; p=ftp; &#125;&#125;int main()&#123; srand(time(NULL)); #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; for(ri i=1;i&lt;=n;++i)col[i]=read(); dfs1(1),dfs2(1,1); sgt::build(1,1,n); for(ri op,x,tt=read();tt;--tt)&#123; op=read(); switch(op)&#123; case 1:&#123;x=read(),cout&lt;&lt;(sgt::query(1,1,n,num[x],num[bot[top[x]]]).l&gt;K)&lt;&lt;'\\n';break;&#125; case 2:&#123;x=read(),col[x]=read(),change(x);break;&#125; case 3:&#123;K=read();break;&#125; &#125; &#125; return 0;&#125; CODE(pbds) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;#include&lt;ext/pb_ds/tree_policy.hpp&gt;#include&lt;ext/pb_ds/assoc_container.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;template &lt;class T&gt;using Tree=tree&lt;T,null_type,less&lt;T&gt;,rb_tree_tag,tree_order_statistics_node_update&gt;;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;typedef pair&lt;int,int&gt; pii;inline pii operator+(pii a,pii b)&#123;return pii(min(max(a.fi,b.fi),a.se),min(max(a.fi,b.se),a.se));&#125;const int N=3e5+5;const int inf=1e9;int n,K,tg[N];int siz[N],hson[N],dep[N],top[N],fa[N],num[N],pred[N],bot[N],col[N],tot=0;vector&lt;int&gt;e[N];Tree&lt;pii&gt;T[N];decltype(begin(T[0])) D[N];namespace sgt&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (l+r&gt;&gt;1) pii vl[N&lt;&lt;2]; inline int rank(const Tree&lt;pii&gt; &amp;A,const int &amp;x)&#123; return A.order_of_key(pii(x,inf)); &#125; inline void pushup(int p)&#123;vl[p]=vl[lc]+vl[rc];&#125; inline pii query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)return vl[p]; if(qr&lt;=mid)return query(lc,l,mid,ql,qr); if(ql&gt;mid)return query(rc,mid+1,r,ql,qr); return query(lc,l,mid,ql,qr)+query(rc,mid+1,r,ql,qr); &#125; inline bool check(int p,int k,int dt)&#123; int R=rank(T[p],k)+dt,B=(int)(T[p].size())+1-R; return B-R&lt;k; &#125; inline void fix(int p,int&amp;k,int dt)&#123; while(check(p,k-1,dt))--k; while(!check(p,k,dt))++k; &#125; inline void getval(int p,int k)&#123; if(col[k]==1)vl[p]=pii(inf,inf); else if(!col[k])vl[p]=pii(-inf,-inf); else&#123; fix(k,vl[p].fi,1); fix(k,vl[p].se,0); &#125; &#125; inline void build(int p,int l,int r)&#123; if(l==r)&#123; int k=pred[l]; getval(p,k); if(k==top[k]&amp;&amp;k!=1)D[k]=T[fa[k]].insert(pii(bot[k]==k?vl[p].fi:(vl[p]+query(1,1,n,l+1,num[bot[k]])).fi,k)).fi; return; &#125; build(rc,mid+1,r),build(lc,l,mid); pushup(p); &#125; inline void update(int p,int l,int r,int k)&#123; if(l==r)return getval(p,pred[l]); k&lt;=mid?update(lc,l,mid,k):update(rc,mid+1,r,k); pushup(p); &#125; #undef mid #undef lc #undef rc&#125;void dfs1(int p)&#123; siz[p]=1; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i])==fa[p])continue; fa[v]=p,dep[v]=dep[p]+1,dfs1(v),siz[p]+=siz[v]; if(siz[v]&gt;siz[hson[p]])hson[p]=v; &#125;&#125;void dfs2(int p,int tp)&#123; top[p]=tp,bot[tp]=p,pred[num[p]=++tot]=p; if(!hson[p])return; dfs2(hson[p],tp); for(ri i=0,v;i&lt;e[p].size();++i)if((v=e[p][i])!=fa[p]&amp;&amp;v!=hson[p])dfs2(v,v);&#125;inline void change(int p)&#123; int tp,ftp; while(p)&#123; ftp=fa[tp=top[p]]; sgt::update(1,1,n,num[p]); if(ftp)&#123; T[ftp].erase(D[tp]); D[tp]=T[ftp].insert(pii(sgt::query(1,1,n,num[tp],num[bot[tp]]).fi,tp)).fi; &#125; p=ftp; &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),K=read(); for(ri i=1,u,v;i&lt;n;++i)&#123; u=read(),v=read(); e[u].pb(v),e[v].pb(u); &#125; for(ri i=1;i&lt;=n;++i)col[i]=read(); dfs1(1),dfs2(1,1); sgt::build(1,1,n); for(ri op,x,tt=read();tt;--tt)&#123; op=read(); switch(op)&#123; case 1:&#123;x=read(),cout&lt;&lt;(sgt::query(1,1,n,num[x],num[bot[top[x]]]).fi&gt;K)&lt;&lt;'\\n';break;&#125; case 2:&#123;x=read(),col[x]=read(),change(x);break;&#125; case 3:&#123;K=read();break;&#125; &#125; &#125; return 0;&#125; 告辞","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"CometOJ模拟赛测试Day2 简要题解","slug":"COJ70","date":"2019-09-28T15:35:27.000Z","updated":"2019-10-11T15:33:23.915Z","comments":true,"path":"COJ70/","link":"","permalink":"http://ldxcaicai.github.io/COJ70/","excerpt":"","text":"21:10分进入比赛界面结果手速慢了C没写完100+100+0滚了 A貌似归并就行了。。。 但我比较智障写了个链表，凑合看看吧~ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;const int N=1e5+5;int pre[N],suf[N],n,b[N],m;inline void delet(int x)&#123; suf[pre[x]]=suf[x]; pre[suf[x]]=pre[x];&#125;int main()&#123; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)pre[i]=i-1,suf[i]=i+1; suf[0]=1,pre[n+1]=n; for(ri i=1;i&lt;=m;++i)delet(b[i]=read()); int ps=1; while(ps&lt;=m)&#123; int p=suf[0]; while(p!=n+1&amp;&amp;p&lt;b[ps])cout&lt;&lt;p&lt;&lt;'\\n',p=suf[p]; for(ri i=pre[p];i;i=pre[i])delet(i); cout&lt;&lt;b[ps]&lt;&lt;'\\n'; ++ps; &#125; for(ri i=suf[0];i!=n+1;i=suf[i])cout&lt;&lt;i&lt;&lt;'\\n'; return 0;&#125; B考虑用 $trie$ 将所有字符串从小到大排序，然后问题转化成为一个排列在全排列中的排名 我并不会康拓展开然后跑去rush了一个bit CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(!isalpha(ch))ch=gc(); while(isalpha(ch))s[++top]=ch,ch=gc(); return top;&#125;const int mod=1e9+7;inline int add(int a,int b)&#123;return (a+=b)&lt;mod?a:a-mod;&#125;inline void Add(int&amp;a,int b)&#123;a=add(a,b);&#125;inline int dec(int a,int b)&#123;return (a-=b)&lt;0?a+mod:a;&#125;inline void Dec(int&amp;a,int b)&#123;a=dec(a,b);&#125;inline int mul(int a,int b)&#123;return (ll)a*b%mod;&#125;inline void Mul(int&amp;a,int b)&#123;a=(ll)a*b%mod;&#125;const int N=1e6+5;char s[N];int son[N][26],rk[N],cnt=0,ed[N];int tot=1;inline void insert(char*s,int len,int idx)&#123; int p=1; for(ri x,i=1;i&lt;=len;++i)&#123; x=s[i]-'a'; if(!son[p][x])son[p][x]=++tot; p=son[p][x]; &#125; ed[p]=idx;&#125;void dfs(int p)&#123; if(ed[p])rk[ed[p]]=++cnt; for(ri i=0;i&lt;26;++i)if(son[p][i])dfs(son[p][i]);&#125;int n,k,a[N],top=0,fac[N],ifac[N];inline void init()&#123; fac[0]=fac[1]=ifac[0]=ifac[1]=1; for(ri i=2;i&lt;=n;++i)fac[i]=mul(fac[i-1],i),ifac[i]=mul(ifac[mod-mod/i*i],mod-mod/i); for(ri i=2;i&lt;=n;++i)Mul(ifac[i],ifac[i-1]);&#125;inline int A(int n,int m)&#123;return n&lt;m||m&lt;0?0:mul(fac[n],ifac[n-m]);&#125;int bit[N];inline int lowbit(int x)&#123;return x&amp;-x;&#125;inline void update(int x,int v)&#123;for(ri i=x;i&lt;=n;i+=lowbit(i))bit[i]+=v;&#125;inline int query(int x)&#123;int ret=0;for(ri i=x;i;i-=lowbit(i))ret+=bit[i];return ret;&#125;int main()&#123; n=read(),k=read(); for(ri i=1,len;i&lt;=n;++i)len=Read(s),insert(s,len,i); dfs(1); int p=1,len=Read(s); for(ri i=1;i&lt;=len;++i)&#123; p=son[p][s[i]-'a']; if(ed[p])&#123; ++top; a[top]=rk[ed[p]]; p=1; &#125; &#125; init(); int res=0; for(ri i=1;i&lt;=k;++i)&#123; Add(res,mul(a[i]-1-query(a[i]),A(n-i,k-i))); update(a[i],1); &#125; cout&lt;&lt;res+1; return 0;&#125; C感觉还没 $Day1的C$ 难 直接考虑枚举删去的列的状态，然后只用看可行的保留行的数量，这个直接压一下每两行每个位置的大小状态然后 $f_{i,j}$ 表示前 $i$ 行一定保留第 $i$ 行的方案数 通过单次通过预处理+打时间标记可以做到 $O(n^2)dp$ 然后我是个 $zz$ ，先写了一个以为是 $O(n^3)$ 的 $O(n^4)dp$ 然后只有 $90pts$ 唉怎么会有90pts CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int n,m,p,q;int a[25][25];int b[25][25];ll f[25][25];inline bool check(int x,int y,int z)&#123; for(ri i=1;i&lt;=q;++i)if((b[x][i]&gt;b[y][i])^(b[y][i]&gt;b[z][i]))return 0; return 1;&#125;int main()&#123; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s)&#123; X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i)&#123; bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]]))&#123;ff=0;break;&#125; if(ff)X.pb(i); &#125; p=X.size(),q=Y.size(); for(ri i=0;i&lt;X.size();++i)for(ri j=0;j&lt;Y.size();++j)b[i+1][j+1]=a[X[i]][Y[j]]; res+=p; for(ri i=1;i&lt;=p;++i)&#123; for(ri j=i+1;j&lt;=p;++j)&#123; f[i][j]=1; for(ri k=i-1;k;--k)&#123; if(check(k,i,j))f[i][j]+=f[k][i]; &#125; res+=f[i][j]; &#125; &#125; &#125; cout&lt;&lt;res; return 0;&#125; 然后发现事情不对，改成了 $O(n^3)$ 的 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int n,m,p,q;int a[25][25];int b[25][25];ll f[25][25],ban[25][25];inline ll calc(int x,int y)&#123; ll res=0; for(ri i=1;i&lt;=q;++i)res+=(1ll*(b[x][i]&gt;b[y][i]))&lt;&lt;(i-1); return res;&#125;int main()&#123; n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s)&#123; X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i)&#123; bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]]))&#123;ff=0;break;&#125; if(ff)X.pb(i); &#125; p=X.size(),q=Y.size(); for(ri i=0;i&lt;X.size();++i)for(ri j=0;j&lt;Y.size();++j)b[i+1][j+1]=a[X[i]][Y[j]]; res+=p; for(ri i=1;i&lt;=p;++i)for(ri j=i+1;j&lt;=p;++j)ban[i][j]=calc(i,j); for(ri i=1;i&lt;=p;++i)&#123; for(ri j=i+1;j&lt;=p;++j)&#123; f[i][j]=1; for(ri k=i-1;k;--k)if(ban[k][i]==ban[i][j])f[i][j]+=f[k][i]; res+=f[i][j]; &#125; &#125; &#125; cout&lt;&lt;res; return 0;&#125; 然后发现被卡常了，加了个时间标记改成了以为是 $O(n^2)$ 的 $O(n^3)dp$ CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int n,m,p,q;int a[25][25];int b[25][25],tim[21][1&lt;&lt;20|5],Tim=0;int f[21][1&lt;&lt;20|5];int ban[25][25];inline int calc(int x,int y)&#123; int res=0; for(ri i=1;i&lt;=q;++i)res+=(b[x][i]&gt;b[y][i])&lt;&lt;(i-1); return res;&#125;inline int query(int x,int y)&#123;return tim[x][y]^Tim?0ll:f[x][y];&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s)&#123; X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i)&#123; bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]]))&#123;ff=0;break;&#125; if(ff)X.pb(i); &#125; p=X.size(),q=Y.size(); for(ri i=0;i&lt;X.size();++i)for(ri j=0;j&lt;Y.size();++j)b[i+1][j+1]=a[X[i]][Y[j]]; res+=p; ++Tim; for(ri i=1;i&lt;=p;++i)&#123; for(ri j=i+1;j&lt;=p;++j)&#123; ban[i][j]=calc(i,j); if(tim[j][ban[i][j]]^Tim)tim[j][ban[i][j]]=Tim,f[j][ban[i][j]]=0; f[j][ban[i][j]]+=query(i,ban[i][j])+1; res+=query(i,ban[i][j])+1; &#125; &#125; &#125; cout&lt;&lt;res; return 0;&#125; 最后终于过了 CODE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_back#define all(x) x.begin(),x.end()using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef pair&lt;ll,int&gt; pli;typedef vector&lt;int&gt; poly;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); while(!isdigit(ch))ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return ans;&#125;int n,m,p,q;int a[25][25];int b[25][25],tim[21][1&lt;&lt;20|5],Tim=0;int f[21][1&lt;&lt;20|5];int ban[25][25];inline int calc(int x,int y)&#123; int res=0; for(ri i=1;i&lt;=m;++i)res+=(a[x][i]&gt;a[y][i])&lt;&lt;(i-1); return res;&#125;inline int query(int x,int y)&#123;return tim[x][y]^Tim?0:f[x][y];&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(),m=read(); for(ri i=1;i&lt;=n;++i)for(ri j=1;j&lt;=m;++j)a[i][j]=read(); for(ri i=1;i&lt;=n;++i)for(ri j=i+1;j&lt;=n;++j)ban[i][j]=calc(i,j); ll res=0; vector&lt;int&gt;X,Y; for(ri s=0,up=1&lt;&lt;m;s&lt;up-1;++s)&#123; X.clear(),Y.clear(); for(ri i=1;i&lt;=m;++i)if(!(s&gt;&gt;(i-1)&amp;1))Y.pb(i); for(ri i=1;i&lt;=n;++i)&#123; bool ff=1; for(ri j=0;j+2&lt;Y.size();++j)if((a[i][Y[j]]&gt;a[i][Y[j+1]])^(a[i][Y[j+1]]&gt;a[i][Y[j+2]]))&#123;ff=0;break;&#125; if(ff)X.pb(i); &#125; p=X.size(),q=Y.size(); res+=p; ++Tim; for(ri i=1,ss;i&lt;=p;++i)&#123; for(ri j=i+1;j&lt;=p;++j)&#123; ss=ban[X[i-1]][X[j-1]]&amp;((up-1)^s); (tim[j][ss]^Tim)&amp;&amp;(tim[j][ss]=Tim,f[j][ss]=0); f[j][ss]+=query(i,ss)+1; res+=query(i,ss)+1; &#125; &#125; &#125; cout&lt;&lt;res; return 0;&#125; 被全场吊打了，告辞","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"CometOJ模拟赛测试Day1 简要题解","slug":"COJ69","date":"2019-09-28T02:27:35.000Z","updated":"2019-10-11T15:33:25.061Z","comments":true,"path":"COJ69/","link":"","permalink":"http://ldxcaicai.github.io/COJ69/","excerpt":"","text":"NMD因为网络原因交错了题，最后导致B,C爆炸了 A我的乱搞做法： 先取对把乘法转化成加法，然后打表求出每个数的不超过其一半的最大的最优决策点 发现决策模 $6$ 之后有规律，建立一个 $solve(x)$ 函数： $x\\le3$ ，返回 $x$ $(x-3)\\%6&lt;4$ ，返回 $solve(x/2)*solve(x-x/2)$ $(x-3)\\%6&gt;=4$ ，返回 $solve(x/2-1)*solve(x-x/2+1)$ 然后加个记忆化就能过了 CODE 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;map&lt;ll,int&gt;S;ll n;const int mod=1e9+7;inline int solve(ll n)&#123; if(S.count(n))return S[n]; if(n&lt;=3)return S[n]=n; int t=(n-4)%6; if(t&gt;=4)return S[n]=1ll*solve(n/2-1)*solve(n-n/2+1)%mod; return S[n]=1ll*solve(n/2)*solve(n-n/2)%mod;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif cin&gt;&gt;n; cout&lt;&lt;solve(n); return 0;&#125; B一道纯模拟题，分如下几类随便讨论一下： 形如 “###” 或者 “##.” ，那么这两种情况只需考虑它们前面的最优值 当前身上有 $2$ 个干扰器，那么可以直接扫一遍求答案， $Ans=干扰器个数-$”##“$个数$ 当前身上有 $1$ 个干扰器，且前面有一个形如 “*#” 的， 那么答案跟第二种情况相同 还有几类比较容易的就不列出来了。 CODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;inline int Read(char*s)&#123; int top=0; char ch=gc(); while(ch!='.'&amp;&amp;ch!='*'&amp;&amp;ch!='#')ch=gc(); while(ch=='.'||ch=='*'||ch=='#')s[++top]=ch,ch=gc(); return top;&#125;const int N=3e6+5;char s[N];int n;inline int calc(int l,int r)&#123; int res=0; for(ri i=l;i&lt;=r;++i)if(s[i]=='*')++res; for(ri i=l;i&lt;r;++i)if(s[i]=='#'&amp;&amp;s[i+1]=='#')--res; return res;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif for(ri tt=read();tt;--tt)&#123; n=Read(s); s[n+1]=s[n+2]='#'; for(ri i=1;i&lt;=n;++i)&#123; if(s[i]=='#'&amp;&amp;s[i+1]=='#'&amp;&amp;s[i+2]!='*')&#123; n=i-1; break; &#125; &#125; int res=0; for(ri ff=0,ct=0,i=1;i&lt;=n;++i)&#123; if(s[i]=='.')continue; if(s[i]=='*')&#123; ++ct,res=max(res,ct); if(ct==2)&#123; res=calc(1,n); break; &#125; if(ff)&#123; res=calc(1,n); break; &#125; continue; &#125; if(s[i]=='#')&#123; if(!ct)&#123; if(s[i+1]!='*')break; ff=0; continue; &#125; else&#123; if(s[i+1]=='#')&#123; ff=0; i+=2; continue; &#125; --ct,ff=1; continue; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;'\\n'; &#125; return 0;&#125; C一道比较容易的 $dp$ 考虑枚举断边然后处理出两个连通块的路径和最值然后乘起来更新答案，下面那个连通块的答案可以直接 $O(n)$ 树形 $dp$ 一遍得到，而上面的维护答案如果不想繁杂讨论的话可以对每个点搞个可删堆/multiset，不过不开 $O2$ 会被卡掉 否则可以维护儿子答案前后缀的 $min/max$ 来实现可删堆一样的东西，但这种 $O(n)$ 的做法也被卡 $TLE$ 了一个点，需要手动 $O2$ 可删堆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=2e5+5;int n,dep[N],mn[N],mx[N],fmn[N],fmx[N],gmx[N],gmn[N];typedef pair&lt;int,int&gt; pii;vector&lt;pii&gt;e[N];struct Q1&#123; priority_queue&lt;int&gt;a,b; inline void push(int x)&#123;a.push(x);&#125; inline void del(int x)&#123;b.push(x);&#125; inline int top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline int stop()&#123;int t=top(),ret;return pop(),ret=top(),a.push(t),ret;&#125; inline int size()&#123;return a.size()-b.size();&#125;&#125;S1[N],Mx[N];struct Q2&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;a,b; inline void push(int x)&#123;a.push(x);&#125; inline void del(int x)&#123;b.push(x);&#125; inline int top()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();return a.top();&#125; inline void pop()&#123;while(b.size()&amp;&amp;a.top()==b.top())a.pop(),b.pop();a.pop();&#125; inline int stop()&#123;int t=top(),ret;return pop(),ret=top(),a.push(t),ret;&#125; inline int size()&#123;return a.size()-b.size();&#125;&#125;S2[N],Mn[N];void dfs1(int p,int fa)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; dfs1(v,p); S1[p].push(S1[v].top()+e[p][i].se); S2[p].push(S2[v].top()+e[p][i].se); &#125; mx[p]=S1[p].top()+S1[p].stop(); mn[p]=S2[p].top()+S2[p].stop(); for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; mx[p]=max(mx[p],mx[v]); mn[p]=min(mn[p],mn[v]); Mx[p].push(mx[v]); Mn[p].push(mn[v]); &#125;&#125;ll res=0;void dfs2(int p,int fa)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; S1[p].del(S1[v].top()+e[p][i].se); S2[p].del(S2[v].top()+e[p][i].se); Mx[p].del(mx[v]); Mn[p].del(mn[v]); fmx[v]=max(0,max(fmx[p],S1[p].top())+e[p][i].se); fmn[v]=min(0,min(fmn[p],S2[p].top())+e[p][i].se); gmx[p]=max(gmx[fa],Mx[p].top()); gmx[p]=max(gmx[p],max(S1[p].stop(),fmx[p])+S1[p].top()); gmn[p]=min(gmn[fa],Mn[p].top()); gmn[p]=min(gmn[p],min(S2[p].stop(),fmn[p])+S2[p].top()); res=max(res,(ll)mx[v]*gmx[p]); res=max(res,(ll)mn[v]*gmn[p]); dfs2(v,p); S1[p].push(S1[v].top()+e[p][i].se); S2[p].push(S2[v].top()+e[p][i].se); Mx[p].push(mx[v]); Mn[p].push(mn[v]); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); &#125; for(ri i=1;i&lt;=n;++i)S1[i].push(0),S1[i].push(0),S2[i].push(0),S2[i].push(0),Mn[i].push(0),Mx[i].push(0); dfs1(1,0); dfs2(1,0); cout&lt;&lt;res; return 0;&#125; 前后缀max 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ri register int#define fi first#define se second#define pb push_backusing namespace std;typedef long long ll;const int rlen=1&lt;&lt;18|1;char buf[rlen],*ib=buf,*ob=buf;#define gc() (((ib==ob)&amp;&amp;(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)inline int read()&#123; int ans=0; char ch=gc(); bool f=1; while(!isdigit(ch))f^=ch=='-',ch=gc(); while(isdigit(ch))ans=((ans&lt;&lt;2)+ans&lt;&lt;1)+(ch^48),ch=gc(); return f?ans:-ans;&#125;const int N=2e5+5;int n,mx[N],fmx[N],gmx[N],dmx[N];typedef pair&lt;int,int&gt; pii;vector&lt;pii&gt;e[N];struct Mxx&#123; int mx,sx; Mxx(int mx=0,int sx=0):mx(mx),sx(sx)&#123;&#125; friend inline Mxx operator+(Mxx a,Mxx b)&#123;return Mxx(max(a.mx,b.mx),a.mx&gt;b.mx?max(a.sx,b.mx):max(a.mx,b.sx));&#125;&#125;;vector&lt;Mxx&gt;pmx[N],smx[N],Pmx[N],Smx[N];inline void init(int p,int fa)&#123; int n=e[p].size(); pmx[p].resize(n+1),smx[p].resize(n+1); Pmx[p].resize(n+1),Smx[p].resize(n+1); for(ri vl,i=1,ps=1;i&lt;=n;++i,++ps)&#123; if(e[p][i-1].fi==fa)&#123;--ps;continue;&#125; vl=dmx[e[p][i-1].fi]+e[p][i-1].se; pmx[p][ps]=pmx[p][ps-1]+Mxx(max(vl,0),0); vl=mx[e[p][i-1].fi]; Pmx[p][ps]=Pmx[p][ps-1]+Mxx(max(vl,0),0); &#125; for(ri vl,i=n,ps=n-1;i;--i,--ps)&#123; if(e[p][i-1].fi==fa)&#123;++ps;continue;&#125; vl=dmx[e[p][i-1].fi]+e[p][i-1].se; smx[p][ps]=smx[p][ps+1]+Mxx(max(vl,0),0); vl=mx[e[p][i-1].fi]; Smx[p][ps]=Smx[p][ps+1]+Mxx(max(vl,0),0); &#125;&#125;void dfs1(int p,int fa)&#123; for(ri i=0,v;i&lt;e[p].size();++i)&#123; if((v=e[p][i].fi)==fa)continue; dfs1(v,p); &#125; init(p,fa); dmx[p]=smx[p][1].mx; mx[p]=max(smx[p][1].mx+smx[p][1].sx,Smx[p][1].mx);&#125;ll res=0;void dfs2(int p,int fa)&#123; Mxx mx1,mx2; for(ri i=0,v,ps=1;i&lt;e[p].size();++i,++ps)&#123; if((v=e[p][i].fi)==fa)&#123;--ps;continue;&#125; mx1=pmx[p][ps-1]+smx[p][ps+1]; mx2=Pmx[p][ps-1]+Smx[p][ps+1]; fmx[v]=max(0,max(fmx[p],mx1.mx)+e[p][i].se); gmx[p]=max(gmx[fa],mx2.mx); gmx[p]=max(gmx[p],max(mx1.sx,fmx[p])+mx1.mx); res=max(res,(ll)mx[v]*gmx[p]); dfs2(v,p); &#125;&#125;int main()&#123; #ifdef ldxcaicai freopen(\"lx.in\",\"r\",stdin); #endif n=read(); for(ri i=1,u,v,w;i&lt;n;++i)&#123; u=read(),v=read(),w=read(); e[u].pb(pii(v,w)); e[v].pb(pii(u,w)); &#125; e[1].pb(pii(0,0)); dfs1(1,0); dfs2(1,0); for(ri i=1;i&lt;=n;++i)for(ri j=0;j&lt;e[i].size();++j)e[i][j].se*=-1; dfs1(1,0); dfs2(1,0); cout&lt;&lt;res; return 0;&#125;","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"比赛题解","slug":"比赛题解","permalink":"http://ldxcaicai.github.io/tags/比赛题解/"}]},{"title":"Linear programming","slug":"LP","date":"2019-09-27T02:20:44.000Z","updated":"2019-10-11T15:33:21.577Z","comments":true,"path":"LP/","link":"","permalink":"http://ldxcaicai.github.io/LP/","excerpt":"","text":"线性规划两种常见形式的转化标准型： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j\\le b_i\\\\ &x_i\\ge0 \\end{aligned}松弛型： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j= b_i\\\\ &x_i\\ge0 \\end{aligned}下面是一个常用的标准型转松弛型套路： 原线性规划： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j\\le b_i\\\\ &x_i\\ge0 \\end{aligned}令 $x_{i+m}=b_i-\\sum\\limits_{j=1}^na_{i,j}x_j\\ge 0$ 那么有新的线性规划： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j+x_{i+m}=b_i\\\\ &x_i\\ge0 \\end{aligned}单纯形法求解线性规划将上面的松弛型线性规划进行移项： \\begin{aligned} maximize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&x_{i+m}=b_i-\\sum\\limits_{j=1}^na_{i,j}x_j\\\\ &x_i\\ge0 \\end{aligned}然后一直重复下面的操作： 在目标函数中找出一个 $c_e&gt;0$ 的 $e$ 在约束条件中找出满足 $a_{l,e}&gt;0且\\frac{a_{l,0}}{a_{l,e}}最大$ 的 $l$ 将第 $l$ 个约束等式移项变形： $x_e=\\frac{b_i}{a_{l,e}}-\\sum\\limits_{j=1,j\\not=e}^n\\frac{a_{l,j}}{a_{l,e}}x_j-\\frac1{a_{l,e}}x_{l+m}$ 将移项得到的等式带入其余的约束等式和目标函数中，消去所有的 $x_e$ ，添加上 $x_{l+m}$ ，并更新剩余项的系数 讨论下面几种边界情况： 当第一步无法找到合法的 $e$ 时，说明求出了最优解 当第二步无法找到合法的 $l$ 时，说明该线性规划无界 复杂度指数级，但跑的比谁都快 正确性:线性规划有界时解空间是一个凸形区域，因此单纯形算法求出的局部最优值即为全局最优值 当然有时候需要构造一组初始解出来（大部分时候不需要），可以使用如下技巧构造辅助线性规划： \\begin{aligned} maximize:&-x_0\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j+x_0=b_i\\\\ &x_i\\ge0 \\end{aligned}容易看出如果该情况无解那么原问题无解 例题： UVA Happiness CC Flight Distance TCO precious stones 整数线性规划本来应该是 $NP-hard$ 问题 但是如果证明最优解一定是在整数解时可以取得的话可以用单纯形 原因还是来源于上面说过的凸形区域 或者可以一眼看出该线性规划的 $\\boldsymbol A$ 是一个全幺模矩阵也行 对偶原理考虑现在有如下线性规划： \\begin{aligned} minimize:&\\sum\\limits_{i=1}^nc_ix_i\\\\ limits:&\\sum\\limits_{j=1}^na_{i,j}x_j\\ge b_i\\\\ &x_i\\ge0 \\end{aligned}利用待定系数法的思想可以知道，该线性规划的任意可行解$(x_1^{\\times},x_2^\\times,…,x_n^\\times)$一定能表示成如下形式： \\begin{aligned} \\sum\\limits_{i=1}^nc_ix_i^\\times=&\\sum\\limits_{i=1}^my_i(\\sum\\limits_{j=1}^na_{i,j}x_j^\\times)\\ge\\sum\\limits_{i=1}^mb_iy_i\\\\ \\sum\\limits_{i=1}^my_ia_{i,j}\\le&c_j\\\\ y_i\\ge&0 \\end{aligned}现在要找出 $\\sum\\limits_{i=1}^nc_ix_i$ 的下界，等价于找出 $\\sum\\limits_{i=1}^mb_iy_i$ 的上界 于是我们得到了一个新的线性规划： \\begin{aligned} maximize:&\\sum_{i=1}^mb_iy_i\\\\ limits:&\\sum_{j=1}^ma_{j,i}y_j\\le c_j\\\\ &y_j\\ge0 \\end{aligned}同样的，将新得到的线性规划做类似转化可以转回原来的线性规划，我们称这两个线性规划互为对偶问题 互相转化的关键是这个等式： $\\sum\\limits_{i=1}^nc_ix_i\\ge\\sum\\limits_{i=1}^mb_iy_i$ ，即等号右边的上界不超过等号左边的下界 上述等式即是线性规划弱对偶性，即对于两个线性规划的任意可行解 $\\boldsymbol x^\\times,\\boldsymbol y^\\times$，均满足 $\\sum\\limits_{i=1}^nc_ix_i^\\times\\ge\\sum\\limits_{i=1}^mb_iy_i^\\times$ 线性规划的对偶原理用矩阵的形式可以简单表示为： \\min\\{\\boldsymbol{c}^T \\boldsymbol x|\\boldsymbol A\\boldsymbol x\\ge \\boldsymbol b,\\boldsymbol x\\ge\\boldsymbol0\\}\\Longleftrightarrow\\max\\{\\boldsymbol b^T\\boldsymbol x|\\boldsymbol A^T\\boldsymbol y\\ge\\boldsymbol c,\\boldsymbol y\\ge \\boldsymbol 0\\}下面证明一个重要定理： 线性规划对偶性：对于两个线性规划的任意最优解解 $\\boldsymbol x^\\times,\\boldsymbol y^\\times$，均满足 $\\sum\\limits_{i=1}^nc_ix_i^\\times=\\sum\\limits_{i=1}^mb_iy_i^\\times$ 证明： 对于第一个线性规划，考虑构造一个函数 $f(\\boldsymbol y)=\\boldsymbol c^T\\boldsymbol x+\\boldsymbol y^T(\\boldsymbol b-\\boldsymbol A\\boldsymbol x),\\boldsymbol y\\ge\\boldsymbol0$ 令 $g(\\boldsymbol y)=\\min\\{f(\\boldsymbol y)|\\boldsymbol A\\boldsymbol x\\ge \\boldsymbol b,\\boldsymbol x\\ge\\boldsymbol0\\}$ 显然$\\forall \\boldsymbol y,g(\\boldsymbol y)\\le \\boldsymbol c^T\\boldsymbol x^\\times$ 即$\\max\\{g(\\boldsymbol y)\\}=\\boldsymbol c^T\\boldsymbol x^\\times$ 转化问题： \\begin{aligned} \\boldsymbol c^T\\boldsymbol x^\\times=&\\max\\{g(\\boldsymbol y)\\}\\\\ =&\\max\\{\\boldsymbol y^T\\boldsymbol b+\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}\\}\\\\ =&\\max\\{\\boldsymbol b^T\\boldsymbol y+\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}\\} \\end{aligned}当 $\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A\\ge \\boldsymbol0$ 时，$\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}=0$ 当 $\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A\\not\\ge \\boldsymbol0$ 时，$\\min\\{(\\boldsymbol c^T-\\boldsymbol y^T\\boldsymbol A)\\boldsymbol x\\}=-inf$ 简单分析与变形后可知： \\begin{aligned} \\boldsymbol c^T\\boldsymbol x^\\times=&\\max\\{\\boldsymbol b^T\\boldsymbol y|\\boldsymbol A^T\\boldsymbol y\\le\\boldsymbol c,\\boldsymbol y\\ge\\boldsymbol0\\} \\end{aligned}得证 而且容易知道原问题和对偶问题同时取到目标取值~ 利用上述两个定理容易证明出线性规划的互相松弛定理： 对于原问题和对偶问题的可行解 $\\boldsymbol x^\\times,\\boldsymbol y^\\times$ ，它们均为问题的最优解当前仅当如下条件被满足： $\\forall 1\\le j\\le n,s.t.\\ x_j^\\times=0或\\sum\\limits_{i=1}^ma_{i,j}y_i^\\times=c_j$ $\\forall 1\\le i\\le m,s.t.\\ y_i^\\times=0或\\sum\\limits_{j=1}^na_{i,j}x_i^\\times=b_i$ 对偶原理的几个性质： 对于无限制变量 $x_i$ ，对偶后对应限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j=c_i$ 对于变量 $x_i=0$ ，对偶后对应 $\\sum\\limits_{j=1}^ma_{j,i}y_j$ 无限制 对于变量 $x_i\\ge0$ ，对偶后对应限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j\\ge0$ 对于变量 $x_i\\le0$ ，对偶后对应限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j\\le0$ 对于限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j=c_i$ ，对偶后对应无限制变量 $x_i$ 对于限制$\\sum\\limits_{j=1}^ma_{j,i}y_j$ ，对偶后对应变量 $x_i=0$ 对于限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j\\ge0$ ，对偶后对应变量 $x_i\\le0$ 对于限制 $\\sum\\limits_{j=1}^ma_{j,i}y_j\\le0$ ，对偶后对应变量 $x_i\\ge0$ 对偶原理在网络问题中的运用利用上述定理和性质可以很快证明如下两个结论： 最小割和最大流是对偶问题 二分图最大权匹配和最小费用流是对偶问题 证明比较容易，这里略去 例题： [SHOI2004]最小生成树 CC Flight Distance 线性规划与半平面交的转化 对于只有两个变量的线性规划，可以通过移项变成半平面交问题 对于只用两个限制的线性规划，可以通过对偶原理+移项变成半平面交问题 例题： poj equations 线性规划与网络流问题的转化考虑到网络流问题的最优解都是整数解，因此在转化的时候务必记住判定列出的线性规划是不是全幺模矩阵否则不一定解出的最优解是整数最优解~ 例题： CC Chefbook bzoj Orz the MST [ZJOI2013]战线防守 线性规划与博弈一个基本不可能填的坑 好难啊我不会纳什均衡，还是得cyktxdy学会了之后给我讲","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"segement tree trick","slug":"SGTtrick","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-11T15:30:11.450Z","comments":true,"path":"SGTtrick/","link":"","permalink":"http://ldxcaicai.github.io/SGTtrick/","excerpt":"","text":"SGTtrick$By\\ 蒟蒻\\ ldxcaicai$ Chapter 1.关于线段树操作的一些分析我们知道，线段树有两个核心的函数$pushdown$和$pushup$。 以及两类对于一段区间进行操作的函数$update$和$query$ 博主在这里简单讲一下几个函数的功能： 首先我们假设用$Val$表示维护信息的类型，$Tag$表示懒标记的类型。 显然一个线段树节点（类型为$Node$）是由一个$Val$元素和一个$Tag$以及表示区间管辖范围的$l,r$构成的。 123struct Tag&#123;...&#125;;struct Val&#123;...&#125;;struct Node&#123;Val val;Tag tag;int l,r;&#125;T[N&lt;&lt;2]; $pushdown(int\\ p)$表示将$p$的标记下传给$p$的儿子并更新它们的信息和标记 $pushup(int\\ p)$表示把$p$儿子的信息合并成$p$的信息 $query(int\\ p,int\\ ql,int\\ qr)$表示查询区间$[ql,qr]$的一些信息 $update(int\\ p,int\\ ql,int\\ qr,Tag\\ v)$表示用标记$v$对区间$[ql,qr]$的信息和标记进行更新 可以看出来这些函数分成两类： 父亲朝儿子转移：$update,pushdown$ 儿子朝父亲转移：$query,pushup$ 而我们继续将这几个函数的功能进行拆分并取上并集（雾，发现它其实是这几个东西的组合： 两个$Val$类型的元素的合并 一个$Tag$类型的元素对一个$Val$类型的元素的更新 一个$Tag$类型的元素对一个$Tag$类型的元素的更新123456inline Tag operator+(const Tag&amp;a,const Tag&amp;b)&#123;...&#125;inline void operator+=(Tag&amp;a,const Tag&amp;b)&#123;a=a+b;&#125;inline Val operator+(const Val&amp;a,const Tag&amp;b)&#123;...&#125;inline void operator+=(Val&amp;a,const Tag&amp;b)&#123;a=a+b&#125;inline Val operator+(const Val&amp;a,const Val&amp;b)&#123;...&#125;inline void operator+=(Val&amp;a,const Val&amp;b)&#123;a=a+b;&#125; 如果我们对这几个操作重载运算符的话，那么上述函数的实现就很简单了，为了让实现更加简便可以设计一个$pushnow函数$。 $pushup$函数：把儿子的$Val$合并成自己的$Val$。 123inline void pushup(int p)&#123; T[p].val=T[lc].val+T[rc].val;&#125; $pushnow$函数：$pushnow(int\\ p,Tag\\ v)$表示用标记$v$更新节点$p$的信息和标记。代码： 123inline void pushnow(int p,Tag v)&#123; T[p].val+=v,T[p].tag+=v;&#125; $pushdown$函数：用自己的$Tag$去更新儿子的$Val$和$Tag$ 12345inline void pushdown(int p)&#123; if(check(T[p].tag))return; pushnow(lc,T[p].tag),pushnow(rc,T[p].tag); T[p].tag=tag_empty;&#125; $query$函数：把要查询的区间拆成线段树上至多$log$个区间把它们的$Val$按一定顺序合并起来。 12345678inline Val query(int p,int ql,int qr)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return val_empty; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)return T[p].val; pushdown(p); if(qr&lt;=mid)return query(lc,ql,qr); if(qr&gt;mid)return query(rc,ql,qr); return query(lc,ql,qr)+query(rc,ql,qr);&#125; $update$函数：把要修改的区间拆成线段树上至多$log$个区间分别用给出的$Tag$更新它们的$Tag$和$Val$。 123456789inline void update(int p,int ql,int qr,Tag v)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)return pushnow(p,v); pushdown(p); if(qr&lt;=mid)update(lc,ql,qr,v); else if(ql&gt;mid)update(rc,ql,qr,v); else update(lc,ql,qr,v),update(rc,ql,qr,v); pushup(p);&#125; 所以当你拿到一道线段树题的时候，思考上述三种运算符如何重载即可$qwq$。 那么最后我们给上一波上述所有内容合起来的伪代码：才不会告诉你这是一个通用的框架呢 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859namespace SGT&#123; #define lc (p&lt;&lt;1) #define rc (p&lt;&lt;1|1) #define mid (T[p].l+T[p].r&gt;&gt;1) struct Tag&#123;...&#125;; struct Val&#123;...&#125;; const Tag tag_empty=(Tag)&#123;...&#125;; const Val val_empty=(Val)&#123;...&#125;; inline Tag operator+(const Tag&amp;a,const Tag&amp;b)&#123;...&#125; inline void operator+=(Tag&amp;a,const Tag&amp;b)&#123;a=a+b;&#125; inline Val operator+(const Val&amp;a,const Tag&amp;b)&#123;...&#125; inline void operator+=(Val&amp;a,const Tag&amp;b)&#123;a=a+b&#125; inline Val operator+(const Val&amp;a,const Val&amp;b)&#123;...&#125; inline void operator+=(Val&amp;a,const Val&amp;b)&#123;a=a+b;&#125; struct Node&#123;Val val;Tag tag;int l,r;&#125;T[N&lt;&lt;2]; inline bool check(const Tag&amp;v)&#123;...&#125; inline void pushdown(int p)&#123; if(check(T[p].tag))return; T[lc].val+=T[p].tag,T[lc].tag+=T[p].tag; T[rc].val+=T[p].tag,T[rc].tag+=T[p].tag; T[p].tag=tag_empty; &#125; inline void pushup(int p)&#123; T[p].val=T[lc].val+T[rc].val; &#125; inline void build(int p,int l,int r)&#123; T[p]=(Node)&#123;val_empty,tag_empty,l,r&#125;; if(l==r)&#123; T[p].val=(Val)&#123;...&#125;; return; &#125; build(lc,l,mid); build(rc,mid+1,r); pushup(p); &#125; inline void update(int p,int ql,int qr,Tag v)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)&#123; T[p].val+=v,T[p].tag+=v; return; &#125; pushdown(p); if(qr&lt;=mid)update(lc,ql,qr,v); else if(ql&gt;mid)update(rc,ql,qr,v); else update(lc,ql,qr,v),update(rc,ql,qr,v); pushup(p); &#125; inline Val query(int p,int ql,int qr)&#123; if(ql&gt;T[p].r||qr&lt;T[p].l)return val_empty; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)return T[p].val; pushdown(p); if(qr&lt;=mid)return query(lc,ql,qr); if(qr&gt;mid)return query(rc,ql,qr); return query(lc,ql,qr)+query(rc,ql,qr); &#125; #undef lc #undef rc #undef mid&#125; Chapter 2.线段树的两种写法吐槽：我吐我自己这里简单谈一谈线段树的两种实现方法：$dfs$版和$bfs$版，其中后者为我瞎$yy$的，经过测试实际效果跟$dfs$版差距不大。 我才不会告诉你们我测出来很多题用第二种写法要慢一些呢 好吧我承认我发现的这种$bfs$版写法很鸡肋。 正题众所周知，搜索有几种顺序，其中有两种很著名分别叫做$dfs$和$bfs$。 而我们的常规线段树就是使用的$dfs$序。 然而在博主的努力尝试下，$bfs$序也是可以处理的。 为什么呢？ 因为在$Chapter\\ 1$中我们已经谈到过线段树的$query$和$update$操作的本质了： $query$函数：把要查询的区间拆成线段树上至多$log$个区间把它们的$Val$按顺序合并起来。 $update$函数：把要修改的区间拆成线段树上至多$log$个区间分别用给出的$Tag$更新它们的$Tag$和$Val$。 这样的话，只要按照顺序把这$log$段区间找到再合起来一定就可以维护所有的操作。 因为按照$bfs$版本的顺序来合并也是正确的。 如何维护顺序？用一个队列即可。 于是我们可以给出$bfs$版的一些框架，这里跟$dfs$版本相同的函数就不拿上来了。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152namespace SGT&#123; ... int q[N&lt;&lt;2],hd,tl; inline void build(int n)&#123; q[hd=tl=1]=1,T[1]=(Node)&#123;val_empty,tag_empty,1,n&#125;; while(hd&lt;=tl)&#123; int p=q[hd++]; if(T[p].l==T[p].r)&#123; T[p].val=(Val)&#123;...&#125;; continue; &#125; T[lc]=(Node)&#123;val_empty,tag_empty,T[p].l,mid&#125;; T[rc]=(Node)&#123;val_empty,tag_empty,mid+1,T[p].r&#125;; q[++tl]=lc,q[++tl]=rc; &#125; for(ri i=tl;i^1;--i)T[q[i]&gt;&gt;1].val+=T[q[i]].val; &#125; inline void update(int p,int ql,int qr,Tag v)&#123; q[hd=tl=1]=1; while(hd&lt;=tl)&#123; int p=q[hd++]; if(ql&gt;T[p].r||qr&lt;T[p].l)continue; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)&#123; pushnow(p,v); continue; &#125; pushdown(p); if(qr&lt;=mid)q[++tl]=lc,T[p].val=T[rc].val; else if(ql&gt;mid)q[++tl]=rc,T[p].val=T[lc].val; else q[++tl]=lc,q[++tl]=rc,T[p].val=val_empty; &#125; for(ri i=tl;i^1;--i)T[q[i]&gt;&gt;1].val+=T[q[i]].val; &#125; inline Val update(int p,int ql,int qr,Tag v)&#123; Val ret=val_empty; q[hd=tl=1]=1; while(hd&lt;=tl)&#123; int p=q[hd++]; if(ql&gt;T[p].r||qr&lt;T[p].l)continue; if(ql&lt;=T[p].l&amp;&amp;T[p].r&lt;=qr)&#123; ret+=T[p].val; continue; &#125; pushdown(p); if(qr&lt;=mid)q[++tl]=lc; else if(ql&gt;mid)q[++tl]=rc; else q[++tl]=lc,q[++tl]=rc; &#125; return ret; &#125; ...&#125; 经过我们的努力改动，代码量成功翻了一倍！！！(滑稽$That’s\\ all$$Thank\\ you$","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"Generating function","slug":"gf","date":"2019-09-25T14:25:20.000Z","updated":"2019-11-27T14:37:49.752Z","comments":true,"path":"gf/","link":"","permalink":"http://ldxcaicai.github.io/gf/","excerpt":"","text":"生成函数定义： 一般生成函数（OGF）一般用于处理组合问题（无标号） $F(x)=\\sum_{i=0}^{\\infty}f_ix^i$ OGF的运算假设现在有两类组合对象$A,B$ 首先考虑如何对它们取并 显然对于一个元素$t$，在$A$中出现了$a_t$次，在$B$中出现了$b_t$次，一共会出现$a_t+b_t$次 记为$C(x)=A(x)+B(x)$ 那么对应标号的系数相加即可 然后考虑如何求它们的笛卡尔积 假设$A,B$笛卡尔积为$C$，那么表示$C$中每个元素$c$都是由$A$中的一个元素$a$和$B$中的一个元素$b$拼成的二元组$(a,b),|c|=|a|+|b|$ 记为$C(x)=A(x)B(x)$ 在生成函数为有限项的时候用$FFT/NTT$多项式乘法即可 OGF生成序列现在有一类组合对象$A$，定义$seq(A)$ 是由$A$的元素排列成的序列组成的集合，一个序列的大小定义为其元素大小总和。$eg1:A=\\{“0”,”1”\\}$，$seq(A)=\\{all\\ 01\\ string\\}$$eg2:N^\\times=\\{1,2,3,…\\}$，元素的大小定义为它的数值，则$seq(N)=\\{正整数的有序拆分\\}$规定A 中不含大小为0 的元素，则$seq(A)=1+A+A^2+A^3+…=\\frac1{1-A}$ 指数生成函数(EGF)一般用于处理组合问题（有标号）常见带标号的组合对象：标号图，置换将两个元素$a,b$拼接起来，$|a|=n,|b|=m$无标号时，只有一种方法；带标号时，规定拼接时拼接对象内部相对标号顺序不变，而互相的标号可以改变，则有$\\frac{(n+m)!}{n!m!}=C_{n+m}^n$种方法 $F(x)=\\sum_{i=0}^{\\infty}f_i\\frac{x^i}{i!}$ EGF的运算并集：$C(x)=A(x)+B(x)$笛卡尔积：$C(x)=A(x)B(x)$对比系数后很好理解 EGF生成序列同$OGF$，$seq(A)=\\frac1{1-A}$ EGF生成集合集合与序列的区别：同样由$i$个$EGF$生成，集合的顺序不重要，序列的顺序确实确定的。因此由$i$个$EGF$生成的集合应该有一个$\\frac1{i!}$的系数。$set(A)=\\sum_{i=0}^{\\infty}\\frac{A^i}{i!}=e^{A}$ 生成函数计数置换计数一个置换是由若干轮换组成的集合。$k$轮换的个数有$(k-1)!$个，对应$EGF$为$(k-1)!\\frac{x^k}{k!}=\\frac{x^k}k$于是全体轮换的$EGF=\\sum_{i=0}^{\\infty}\\frac{x^k}k$设$f(x)=\\sum_{i=0}^{\\infty}\\frac{x^k}k$那么$f’(x)=\\sum_{i=0}^{\\infty}x^k=\\frac1{1-x}$那么$f(x)=\\int f’(x)\\,dx=\\int\\frac1{1-x}\\,dx=-\\ln(1-x)$根据定义，全体置换的$EGF$为$e^{f(x)}=e^{-\\ln(1-x)}=\\frac1{1-x}$这样看来，$k$置换的个数有$k!$个符合事实。如果限制每个轮换的大小都在集合$S$内呢？那么可生成置换的$EGF=e^{\\sum_{k\\in S}\\frac{x^k}k}$ 多项式$exp$即可 背包计数 有$\\sum_{i=1}^na_i$种物品，体积为$i$的物品有$a_i$种，每种物品有无限个。 有$\\sum_{i=1}^na_i$种物品，体积为$i$的物品有$a_i$种，每种物品有无限个。 有$n$种物品，第$i$种物品体积为$i$，第$i$种物品有$a_i$个。 对于所有$1\\le i\\le n$，回答选取物品体积为$i$的方案数。 均可在$O(n\\log n)$的时间内求解。 Q1体积为$i$的物品的生成函数为$\\sum_{j=0}^{\\infty}(x^i)^j=1+x^i+x^{2i}+\\cdot\\cdot\\cdot$那么答案的生成函数为$F(x)=\\prod_{i=1}^n(1+x^i+x^{2i}+\\cdot\\cdot\\cdot)^{a_i}=\\prod_{i=1}^n(\\frac1{1-x^i})^{a_i}$ 构造生成函数$A(x)=\\sum_{i=1}^na_ix^i$ 考虑用$ln$和$exp$转化。 \\begin{aligned}\\ln F(x)=&\\sum_{i=1}^na_i\\times(-\\ln(1-x^i))\\\\=&\\sum_{i=1}^na_i\\times(\\int(\\sum_{j=0}^{\\infty}(x^i)^j)\\,dx)\\\\=&\\sum_{i=1}^na_i\\times(\\sum_{j=1}^{\\infty}\\frac{(x^i)^j}j)\\\\=&\\sum_{j=1}^{\\infty}\\frac1jA(x^j)\\\\F(x)=&e^{\\ln F(x)}\\\\=&e^{\\sum_{j=1}^{\\infty}\\frac1jA(x^j)}\\end{aligned}$A(x^j)$中只有$\\left\\lfloor\\frac nj\\right\\rfloor$项有贡献。所以暴力调和计数算出幂对应的多项式然后加一个多项式$exp$即可。复杂度$O(n\\log n)$ Q2\\begin{aligned}F(x)=&\\prod_{i=1}^n(1+x^i)^{a_i}\\\\\\ln F(x)=&\\sum_{i=1}^na_i\\times\\ln(1+x^i)\\\\=&\\sum_{i=1}^na_i\\times(\\sum_{j=1}^{\\infty}(-1)^{j+1}\\frac{(x^i)^j}j)\\\\=&\\sum_{j=1}^{\\infty}\\frac{(-1)^{j+1}}jA(x^j)\\\\F(x)=&e^{\\ln F(x)}\\\\=&e^{\\sum_{j=1}^{\\infty}\\frac{(-1)^{j+1}}jA(x^j)}\\end{aligned}同$Q1$处理即可。 Q3\\begin{aligned}A(x)=&\\sum_{i=1}^{n}x^i\\\\B(x)=&\\sum_{i=1}^nx^{a_ii}\\\\F(x)=&\\prod\\limits_{i=1}^n(1+x^i+x^{2i}+\\cdot\\cdot\\cdot+x^{a_ii})\\\\=&\\prod\\limits_{i=1}^n\\frac{1-x^{(a_i+1)i}}{1-x^i}\\\\\\ln F(x)=&\\sum_{i=1}^n(\\ln(1-x^{(a_i+1)i})-\\ln(1-x^i))\\\\=&\\sum_{j=1}^{\\infty}\\frac 1j(A(x^j)-B(x^j))\\\\F(x)=&e^{\\ln F(x)}\\\\=&e^{\\sum_{j=1}^{\\infty}\\frac 1j(A(x^j)-B(x^j))}\\end{aligned}$A(x^j),B(x^j)$中只有$\\left\\lfloor\\frac nj\\right\\rfloor$项有贡献。于是同$Q1,2$处理即可。 树的计数求$n$个点的树的个数。 有标号无根树计数利用$prufer$数列可以知道答案为$n^{n-2}$ 有标号有根树计数先生成有标号无根树，然后有$n$种方案选出根节点，答案为$n^{n-2}\\times n=n^{n-1}$ 无标号有根树计数我们设出答案的生成函数$F(x)=\\sum_{i=0}^{\\infty}f_ix^i$，那么$f_i$对应$i$个点的答案。现在假设已经推出$f_{1,2,3,…,n}$，要推$f_{n+1}$。 考虑到$n+1$个点的有根树相当于$n$个点的森林加上一个根。那么我们只需要求出$n$个点森林的方案数。 由于点无标号，因此相同大小的树之间没有顺序，我们应当按照树的大小归类分别求出其生成函数然后来拼接这个森林。 由于大小为$k$的树对应的生成函数为$\\sum\\limits_{i}x^{ik}=\\frac1{1-x^k}$所以所有大小为$k$的树形成森林的生成函数为$c$ 那么$F(x)=x\\prod\\limits_{i=1}^{\\infty}(\\frac1{1-x^i})^{f_i}$ 果断上多项式取对： \\begin{aligned}F(x)=&x\\prod\\limits_{i=1}^{\\infty}(\\frac1{1-x^i})^{f_i}\\\\\\ln F(x)=&\\ln x-\\sum_{i=1}^{\\infty}f_i\\ln (1-x^i)\\\\ (\\ln F(x))'=&(\\ln x-\\sum_{i=1}^{\\infty}f_i\\ln (1-x^i))'\\\\\\frac{F'(x)}{F(x)}=&\\frac1x+\\sum_{i=1}^{\\infty}f_ii\\frac{x^{i-1}}{1-x^i}\\\\xF'(x)=&F(x)+F(x)(\\sum_{i=1}^{\\infty}f_ii\\frac{x^i}{1-x^i})\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj([x^{n-i}]\\frac{x^j}{1-x^j})\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj([x^{n-i}](\\sum_{k=1}^{\\infty}[j|k]x^k))\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj[j|n-i]\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j=1}^{\\infty}f_jj[j|n-i]\\\\nf_n=&f_n+\\sum_{i=1}^{n-1}f_i\\sum_{j|n-i}f_jj\\\\f_n=&\\frac{\\sum_{i=1}^{n-1}f_i\\sum_{j|n-i}f_jj}{n-1}\\end{aligned}考虑令$g_n=\\sum_{i|n}f_ii$那么$f_n=\\frac{\\sum_{i=1}^{n-1}f_ig_{n-i}}{n-1}$于是可以分治$fft$处理$f$，枚举倍数更新$g$。时间复杂度$O(n\\log^2n)$ 无标号无根树计数你需要计算出有根树的答案，然后去世容斥。记$n$个点答案为$h_n$。 发现只有根节点是树的质心时我们才计算的话就不会算重。 若一个根不为质心，那么有且仅有一个子树大小大于$\\left\\lfloor\\frac n2\\right\\rfloor$，考虑容斥掉这些不合法的。然后要按$n$的奇偶性分类讨论一波： $n$为奇数：$h_n=f_n-\\sum\\limits_{i=1}^{\\left\\lfloor\\frac{n}2\\right\\rfloor}f_if_{n-i}$ $n$为偶数：此时可能存在两个质心，因此枚举到$i=\\frac n2$时只能减去两边不一样的情况，即$h_n=f_n-\\sum\\limits_{i=1}^{\\frac{n}2-1}f_if_{n-i}-\\binom{f_\\frac n2}2$ 时间复杂度$O(n\\log^2n)$ 概率生成函数对于一个随机离散变量 $X$ ，我们定义其概率生成函数 $f(z)=\\mathbb{E}(z^{X})=\\sum\\limits_{i=0}^{+\\infty}Pr(X=i)z^i$ 不难发现以下性质： \\begin{aligned}f(1)=&1\\\\f'(1)=&\\mathbb{E}(X)\\\\f^{(k)}(1)=&\\mathbb{E}(X^{\\underline{k}})\\\\Var(X)=&f''(1)+f'(1)-f'(1)^2\\end{aligned}对于掷骰子的问题我们一般用以下几种关系来建立等式： 设时刻 $i$ 结束的概率生成函数为 $F(x)$ ， 未结束的概率生成函数为 $G(x)$ 那么 \\begin{aligned}F(x)+G(x)=&\\cdot\\cdot\\cdot\\\\G(x)\\times(强制结束的概率)=&\\sum\\limits_{i}F(x)\\times(提前i步结束的概率)\\\\\\end{aligned}然后对第一个式子求导，对第二个等式带入 $x=1$ 即可 例题：[CTSC2006]歌唱王国,hdu4652 而在有多个终态的时候一般考虑如下方法变形： $min-max$ 容斥 利用 $\\sum\\limits_{i}F_i(1)=1$这个等式和之前的等式建立方程组跑高斯消元解方程 例题：[SDOI2017]硬币游戏","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"polynomial","slug":"poly","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-16T00:18:56.688Z","comments":true,"path":"poly/","link":"","permalink":"http://ldxcaicai.github.io/poly/","excerpt":"","text":"多项式的运算多项式的加减法，数乘这个大家应该都会吧不推了。 多项式乘法这个大家应该都会吧还是推一推吧。已知的：$A(x)=\\sum_{i=0}^na_ix^i$$B(x)=\\sum_{i=0}^mb_ix^i$要求的：$C(x)=A(x)B(x)=\\sum_{i=0}^{n+m}(\\sum_{j=0}^{min\\{i,n\\}}a_j\\times b_{i-j})x^i$ 显然直接暴力做是$O(n^2)$的，考虑如何优化。 那么我们使用$fft$或者$ntt$来实现点值表示法和系数表示法之间的快速转化。 为了方便起见，我们将$A,B$的最高次数统一成一个$2$的幂（对于超过$n/m$的项的系数看成0即可） 所谓的系数表示法就是我们平常用的那种。 而点值表示法，就是把这个多项式理解成一个函数，用这个函数上的若干个点的坐标来描述这个多项式:$f(x)=(x_0,y_0),(x_1,y_1),…,(x_n,y_n)=p_0,p_1,p_2,…,p_n$ 假设我们已经将$A,B$两个函数转化成了点值表示，于是就可以马上求出$C$的点值表示：$A(x)=(x_{a,0},y_{a,0}),(x_{a,1},y_{a,1}),…,(x_{a,n-1},y_{a,n-1})=p_{a,0},p_{a,1},…,p_{a,n-1}$$B(x)=(x_{b,0},y_{b,0}),(x_{b,1},y_{b,1}),…,(x_{b,n-1},y_{b,n-1})=p_{b,0},p_{b,1},…,p_{b,n-1}$那么$C(x)=p_{a,0}\\times p_{b,0}, p_{a,1}\\times p_{b,1},…,p_{a,n-1}\\times p_{b,n-1}=p_{c,0},p_{c,1},…,p_{c,n-1}$然后再把$C(x)$还原成系数表达式即可。注意：我们需要保证$x_{ai},x_{bi}$互不相同 现在就只用考虑如何实现点值表示和系数表示的互换了。也就是如何用更少的计算次数来求出$n$个不同的$x$值对应的$y$值。考虑有一个具有特殊性质的东西：单位根单位根保证了$w_n^0,w_n^1,…,w_n^{n-1}$是互不相同的并且有$w_n^{ij}=(w_n^i)^j$而原根在模数为质数$p$的时候也有$g^0,g^1,g^2,…,g^{n-1}$是互不相同的并且$g^{ij}\\equiv (g^i)^j \\mod p$这满足了我们上面的性质，因此我们考虑将$w_n^0,w_n^1,…w_n^{n-1}$作为$x_0,x_1,…x_{n-1}$带入求点值。 然后要用到两个引理： 折半引理：$w_n^{k\\times 2}=w_{\\frac n2}^k$(n为偶数 ) 消去引理：$w_n^{k}=-w_n^{k+\\frac n2}$ 这两个引理可以画个单位圆简单证明 然后利用按照下标的奇偶性来进行分治处理： $f(x)=\\sum_{i=0}^na_ix^i$$\\Rightarrow f(w_n^k)=\\sum_{i=0}^na_i w_n^{ik}$$\\Rightarrow f(w_n^k)=\\sum_{i=0}^{\\frac n2-1}a_{2i}w_n^{2ik}+w_n^k\\sum_{i=0}^{\\frac n2-1}a_{2i+1}w_n^{2ik}$ 同时又有： $f(w_n^{k+\\frac n2})=\\sum_{i=0}^{\\frac n2-1}a_{2i}w_n^{2ik}-w_n^k\\sum_{i=0}^{\\frac n2-1}a_{2i+1}w_n^{2ik}$ 这一步需要用到引理 所以我们只要算出两个重新分配了系数的多项式的值就可以了。显然一直分下去只有$log$层。于是总时间复杂度$O(nlogn)$ 注意到递归的效率很低，我们可以预处理最后一层的系数的位置然后用迭代的方式还原回去来优化常数 原理：我们发现分治完之后相当于将$i$和$i$对应的二进制数在$lim$下反转之后对应的新二进制数$i’$这两个位置的系数$a_i,a_i’$交换了位置。这就成功的实现了系数转点值。 下面来看点值转系数： 注：下面的图片有几点没写清楚： 最后的时候$e_{i,i}=0,e_{i,j|i\\not=j}$ 那个$I_n$指的就是 $n\\times n$ 的单位矩阵。 以上是$fft$的证明，$ntt$同理。 多项式求逆 定义：对于一个多项式$A(x)$，如果存在一个多项式$B(x)$，满足$B(x)$的次数小于等于$A(x)$且$A(x)B(x)≡1 \\mod x^n$，那么我们称B(x)为$A(x)$在模$x^n$意义下的逆元，简单记作$A^{−1}(x)$ 求法：$n=1?$那不就是$c$的逆元么。 $n&gt;1?$我们令$B(x)=A^{-1}(x)$ 那么有$A(x)B(x)\\equiv 1 \\mod x^n$然后可以用类似倍增的方法求。 假设我们已经知道$C(x)$满足$A(x)C(x)\\equiv 1\\mod x^{\\frac n2}$（这里的$\\frac n2$都是向上取整） 显然$A(x)B(x)\\equiv 1\\mod x^{\\frac n2}$是成立的。 我们将两式相减： $A(x)(B(x)-C(x))\\equiv 0\\mod x^{\\frac n2}$ 所以$B(x)-C(x)\\equiv 0\\mod x^{\\frac n2}$ 然后将两边平方： $B^2(x)-2B(x)C(x)+C^2(x)\\equiv 0\\mod x^{\\frac n2}$ =&gt;$B^2(x)-2B(x)C(x)+C^2(x)\\equiv 0\\mod x^n$ 这一步很关键，请神犇们仔细思考原因 然后两边同时乘上$A(x)$ =&gt;$B(x)-2C(x)+A(x)C^2(x)\\equiv 0\\mod x^n)$ 于是$B(x)\\equiv2C(x)-A(x)C^2(x)\\mod x^n$ 乘法可以用$fft/ntt$加速，因为每次递归的时候多项式最高次项都减少一半，所以总复杂度仍然是 $O(nlogn)$ 一道板题：洛谷4238 多项式求导默认大家都会函数求导 这个多项式求导属于最简单的那一种 对于一个多项式$f(x)=\\sum_{i=0}^na_ix^i$ 它求导的结果$f’(x)=\\sum_{i=0}^{n-1}(i+1)a_{i+1}x^i$ 于是直接模拟即可。 多项式积分相当于是多项式求导的逆运算。对于一个多项式$f(x)=\\sum_{i=0}^na_ix^i$ 它求导的结果$\\int\\mathrm f(x)dx=\\sum_{i=1}^{n+1}\\frac{a_{i-1}}ix^i$ 可以看出来一个函数的导函数积分起来等价于自己。 多项式取对我们令$g(x)=lnf(x)$那么根据链式法则求导知：$g’(x)=\\frac{f’(x)}{f(x)}$我们已经会多项式求逆和多项式积分，多项式求导了，于是就成功解决了多项式取对。 多项式取exp这个时候我们要提到一个重要的方法：牛顿迭代法 假设我们要求$h(B(x))\\equiv A(x) \\mod x^n$中的$B(x)$ 现在考虑构造有一个以多项式为变量的函数$g(f)=h(f)-A$ 那么要求的就是$g(f)$模$x^n$意义下的零点。 假设已经求出了$g(f)$模$x^{\\left\\lfloor\\frac x 2\\right\\rfloor}$的零点$f_0$那么现在$g(f_a)=g(f_0)+g’(f_0)(f_a-f_0)+\\frac{g’’(f_0)}2(f_a-f_0)^2+…$ 由于$f_0$是模$x^{\\left\\lfloor\\fracx 2\\right\\rfloor}$的零点，所以有：$g(f_a)\\equiv g(f_0)+g’(f_0)(f_a-f_0)\\equiv0\\mod x^{n}$ 所以移项后发现$f_a=f_0-\\frac{g(f_0)}{g’(f_0)}$ 这个东西有什么用呢？ 我们简单举个例子： 比如说多项式求逆，可以构造$g(f)=\\frac1f-A$，算出来$f_a=2f_0-Af_0^2$。 再比如说现在要求的多项式取$exp$:构造$g(f)=e^f-A$，算出来$f_a=f_0(1-lnf_0+A)$ 然后就做完了。 多项式开方直接使用上面所说的牛顿迭代的结论，令$g(x)=f^2-A$，带入得到:$f_a=\\frac{f_0^2+A}{2f_0}$ 然后用多项式求逆搞一搞即可。 多项式的除法/取模现在有两个多项式: $A(x)=\\sum_{i=0}^na_ix^i,B(x)=\\sum_{i=0}^mb_ix^i,n&gt;m$ 要求出$C(x)=\\sum_{i=0}^{n-m}c_ix^i,D(x)=\\sum_{i=0}^td_ix^i,d&lt;m$，满足$A(x)=B(x)C(x)+D(x)$，其中$C(x)$类比商,$D(x)$类比余数。 感觉想法比较神奇。 对于一个多项式$f(x)$，我们定义一个$f_R(x)$表示将这个多项式的系数翻转之后得到的新多项式，如$f(x)=2x^3+3x^2+x+5$时，$f_R(x)=5x^3+x^2+3x+2$然后可以惊奇的发现：$f_R(x)=x^nf(\\frac1x)$ 然后就有$A(\\frac 1x)=B(\\frac 1x)C(\\frac 1x)+D(\\frac 1x)$ 所以$x^nA(\\frac 1x)=x^nB(\\frac 1x)C(\\frac 1x)+x^mD(\\frac 1x)$ 所以$A_R(x)=B_R(x)C_R(x)+D_R(x)\\times x^{n-m}$ 因此$A_R(x)\\equiv B_R(x)C_R(x)\\mod x^{n-m}$ 所以$C_R(x)\\equiv A_R(x) (B_R(x))^{-1} \\mod x^{n-m}$ $D(x)=A(x)-B(x)C(x)$ 分治FFT一个\\times 听起来挺高大上\\times 的东西，然而很简单。 前置知识：cdq分治，fft 考虑这样一个转移式子$f_0=0,f_i=\\sum_{j=1}^if_{i-j}g_j$，其中$g$数组已知，让你求$f$数组。 容易观察到，这个转移式是一个卷积的形式。 然而并不能直接$fft$因为$f$的转移跟自身有关，当然你可以使用我们马上下面讲的生成函数秒掉。 生成函数做法 我们对$f,g$构造生成函数$F(x),G(x)$那么$F(x)-f_0=G(x)F(x)$ 所以$F(x)=\\frac{f_0}{G(x)-1}$，直接上多项式求逆即可，时间复杂度为$O(nlog_n)$吊打分治FFT。 新的做法：分治FFT 假设现在要求的$f$值的下标为$[l,r]$，我们可以利用类似$cdq$分治的思想，先递归求出$[l,mid]$这一段的$f$值，然后考虑$[l,mid]$对$[mid+1,r]$的贡献，最后递归$[mid+1,r]$即可。 那么现在要考虑的就只有$[l,mid]$对$[mid+1,r]$的贡献啦！ 对于$f_i,i\\in[mid+1,r],f_j,j\\in[l,mid],f_i+=f_j\\times g_{i-j}$，然后把所有的放在一起考虑就成了一个卷积的形式。 于是我们将$f_{l,l+1,…,mid}$构成的多项式和$g_{0,1,…,r-l}$构成的多项式乘起来更新$f_{mid+1,mid+2,…,r}$即可。 然而时间复杂度为$O(nlog^2_n)$ 生成函数 前置知识：泰勒展开我对于生成函数的理解：生成函数就相当于对一个集合的表示： 一般生成函数(Ordinary Generating Function) 也就是大家常说的$OGF$: $F(x)=\\sum_{i=0}^{\\infty}a_ix^i$ 指数生成函数(Exponential Generating Function) 也就是大家常说的$EGF$: $F(x)=\\sum_{i=0}^{\\infty}a_i\\frac{x^i}{i!}$ 它们可以帮助我们处理一些组合问题。 两个经常用到的公式： $1+x+x^2+…=\\frac{1}{1-x}$ $1+x+x^3+…+x^n=\\frac{1-x^{n+1}}{1-x}$小学的等比数列求和公式 以及我们的泰勒展开公式。 解决组合问题的时候我们通常将$x^i$的系数看成值为$i$的数被凑出的方案数 事实上，我认为加法原理和乘法原理在生成函数上同样对应了具体的运算。 比如说现在我们要从集合$A_1,A_2,A_3,..,A_n$中选一个值为$i$的数出来问有多少种选法（加法原理），那么考虑这$n$个生成函数的和$C$，$C$中$x^i$的系数就是答案。 再比如说我们要从$A_1,A_2,A_3,…,A_n$中各选一个数加起来，问加和为$i$的方案数（乘法原理），那么考虑这$n$个生成函数的积$C$，$C$中$x^i$的系数就是答案。 是不是有点感觉了？ 我们举一个例子：正整数集$N=\\{1,2,3,4,…\\}$，元素的大小定义为它的数值，定义$SEQ(A)$ 是由$A$的元素排成的序列组成的集合，一个序列的大小定义为其元素大小总和，现在让我们求一求$SEQ(N)$。 $SEQ(N) = \\{正整数有序拆分\\}=\\{0,1,1+1,2,1+1+1,1+2, 2+1,3\\}$ 考虑构造一个函数$N(x)=x+x^2+…=\\frac x{1-x}$ 于是$SEQ(N)=1+N(x)+N^2(x)+…=\\frac 1{1-N(x)}=1+\\frac x{1-2x}=1+x+2x+4x^2+…$ 是不是感觉挺好用的 两道板题：bzoj3028,poj3734 多项式多点求值现在已知$f(x)=\\sum_{i=0}^na_ix^i$与$m$个数$b_1,b_2,…,b_m$。 求$f(b_1),f(b_2),…,f(b_m)$ 有很显然的$O(nm)$暴力做法，这里直接略过。 考虑构造一个函数$g_{l,r}(x)=\\prod_{i=l}^r(x-b_i)$ 那么$\\forall x_0\\in[l,r]$，有$f(x_0)=(f\\%g_{l,r})(x_0)$ 证明： 令$f(x)=g_{l,r}(x)\\times B(x)+R(x)=(x-x_0)\\times (\\frac{g_{l,r}(x)}{x-x_0}\\times B(x))+R(x)$当$x=x_0$时：$f(x_0)=0+R(x_0)=R(x_0)=(f\\%g_{l,r})(x_0)$ 有了这个结论就可以分治处理了。 多项式快速插值给出$n$个点$(x_i,y_i)$，求对应多项式。 有一种叫做拉格朗日插值的东西需要了解一下。 并且要会上面的多项式多点求值。 仔细观察拉格朗日插值的代数式： f(x)=\\sum_{i=1}^ny_i\\prod_{j=\\not i}\\frac{x-x_j}{x_i-x_j}\\\\考虑如何快速求$val_i=\\prod_{j=\\not i}(x_i-x_j)$ 构造函数$M(x)=\\prod_i(x-x_i)$ 则$val_i=\\lim\\limits_{x\\rightarrow x_i}\\frac{M(x)}{x-x_i}=\\lim\\limits_{x\\rightarrow x_i}\\frac{M’(x)}{(x-x_i)’}=\\lim\\limits_{x\\rightarrow x_i}M’(x)=M’(x_i)$ 于是我们可以用多点求值求出$val$数组。 现在讲拉格朗日插值的代数式恒等变形： f(x)=\\sum_{i=1}^ny_i\\prod_{j=\\not i}\\frac{x-x_j}{x_i-x_j}\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =\\sum_{i=1}^n\\frac{y_i}{val_i}\\prod_{j=\\not i}(x-x_j)\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =(\\sum_{i=1}^{mid}\\frac{y_i}{val_i}\\prod_{j=\\not i}(x-x_j))(\\prod_{i=mid+1}^n(x-x_i))\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ +(\\sum_{i=mid+1}^{n}\\frac{y_i}{val_i}\\prod_{j=\\not i}(x-x_j))(\\prod_{i=1}^{mid}(x-x_i))用分治$ntt$解决即可。 下降幂多项式乘法考虑求出如下两个多项式的乘积： $A(x)=\\sum_{i=0}^na_ix^{\\underline i},B(x)=\\sum_{i=0}^mb_ix^{\\underline i}$ 然后考虑把它们转成点值形式然后乘起来再转回去。 设现在$F(x)=\\sum_{i=0}^nf_ix^{\\underline i}，\\hat F(x)$为其点值的生成函数。 现在先考虑$x^{\\underline n}$的$EGF$ =\\sum_{i=0}^{\\infty}\\frac{i^{\\underline n}}{i!}x^i=\\sum_{i=0}^{\\infty}\\frac{1}{(i-n)!}x^i=\\sum_{i=n}^{\\infty}\\frac{1}i!x^{i+n}=x^ne^x然后有 \\hat F(x)=\\sum_{i=0}^{\\infty}\\frac{F(i)}{i!}x^i\\hat F(x)=\\sum_{i=0}^{\\infty}\\frac{x^i}{i!}\\sum_{j=0}^{\\infty}f_jj^{\\underline i}\\hat F(x)=\\sum_{i=0}^{\\infty}f_i\\sum_{j=0}^{\\infty}\\frac{x^j}{j!}i^{\\underline j}\\hat F(x)=\\sum_{i=0}^{\\infty}f_x^ie^x\\hat F(x)=e^x\\sum_{i=0}^{\\infty}f_ix^i于是就转化成了常规多项式乘法问题。 我们把$\\sum_{i=0}^{n}f_ix^i$这个多项式与$e^x$相乘就能得到点值的生成函数，同理，点值的生成函数乘上$e^{-x}$就能还原多项式。 因此可以结合$ntt/$暴力多项式乘法在$O(n\\log n)/O(n^2)$的时间内完成下降幂多项式乘法。 普通多项式转下降幂多项式已知普通多项式$A(x)=\\sum_{i=0}^na_ix^i$ 现在求下降幂多项式$B(x)=\\sum_{i=0}^nb_ix^{\\underline i}$使得$A(x)=B(x)$ 思路：考虑先多点求值，然后$iffp$即可求出对应的下降幂多项式。 下降幂多项式转普通多项式已知下降幂多项式$A(x)=\\sum_{i=0}^na_ix^{\\underline i}$ 现在求普通多项式$B(x)=\\sum_{i=0}^nb_ix^i$使得$A(x)=B(x)$ 思路：考虑先$ffp$转点值，然后快速插值即可求出对应的普通多项式。","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"Berlekamp-Massey algorithm","slug":"bm-algorithm","date":"2019-09-25T14:25:20.000Z","updated":"2019-12-04T03:42:43.671Z","comments":true,"path":"bm-algorithm/","link":"","permalink":"http://ldxcaicai.github.io/bm-algorithm/","excerpt":"","text":"算法引入Berlekamp-Massey算法可以在$O(n^2)$的时间内求出长度为$n$的已知数列的最短递推式，再配合常系数齐次线性递推就可以快速求出数列的任意项。 现在给你一个数列，考虑如何构造出其最短递推式。 算法流程对于一个$n$项的数列 $A=\\{a_1,a_2,…,a_n\\}$ 和另一个$m$项的数列 $R=\\{r_1,r_2,…,r_m\\}(m\\le n)$ ，当$\\forall k&gt;m$，都满足$a_k=\\sum\\limits_{i=1}^mr_ia_{k-i}$时，我们称$R是$A的一个递推式，对于所有满足条件的$R$，我们将$m$最小的$R$称为$A$的最短线性递推式。 现在我们考虑用增量构造法构造一个$N$项的数列$A$的最短线性递推式$R$ 假设我们当前处理到位置$n$，$\\{a_1,a_2,…,a_{n-1}\\}$的最短线性递推式为$\\{r_1,r_2,…,r_m\\}$，记第$i$次更改最短线性递推式为$R_i$，特别的，$R_0=\\{\\emptyset\\},R_{cur}=\\{r_1,r_2,…,r_m\\}$即为当前最短线性递推式。 设$\\Delta n=a_n-\\sum\\limits_{i=1}^mr_ia_{n-i}$，现在按$\\Delta n$的取值分两种情况考虑 $\\Delta n=0$，则$R_{cur}$为$\\{a_1,a_2,…,a_n\\}$的最短线性递推式 $\\Delta n\\not=0$，则$R_{cur}$在位置$n$出错，我们要构造出$R_{cur+1}$来修正这个递推式。 修正递推式时又要分两种情况 $cur=0$，我们直接构造一个递推式 $R_1=\\{r_1,r_2,r_3,…,r_n\\}$，其中 $r_1=r_2=\\cdot\\cdot\\cdot=r_n=0$ $cur\\not=0$，考虑构造一个增量构造式$R_{\\Delta}$满足$R_{cur+1}=R_{cur}+R_{\\Delta}$，接下来我们将对如何构造$R_{\\Delta}$展开讨论。 定义$fail_{i}$表示递推式$R_{i}$出错的最早位置，那么此时按照定义$fail_{cur}=n$。 假设$R_{\\Delta}$一共有$m’$项，考虑$R_{\\Delta}$要满足的条件： $\\Delta n=\\sum\\limits_{i=1}^{m’}R_{\\Delta,i}a_{n-i}$ $\\forall m’&lt;k&lt;n,0=\\sum\\limits_{i=1}^{m’}R_{\\Delta,i}a_{k-i}$ 考虑到$R_{best}$这个递推式满足类似的条件，其中 $best$ 是满足 $fail_{best}-len_{best}$ 最小的一项： $\\Delta fail_{best}=a_{fail_{best}}-\\sum\\limits_{i=1}^{m_{best}}R_{best,i}a_{fail_{best}-i}$ $\\forall m_{best}&lt;k&lt;fail_{best},0=a_k-\\sum\\limits_{i=1}^{m_{best}}R_{best,i}a_{k-i}$ 我们设$t=\\frac{\\Delta n}{\\Delta fail_{best}},b=\\{t,-t\\times r_{best,1},-t\\times r_{best,2},…,-t\\times r_{best,m_{best}}\\}$ 这启示我们按照如下方式构造$R_{\\Delta}$： $\\forall fail_{best}&lt;k&lt;n$，我们给$a_{n-k}$分配$0$作为系数 $\\forall fail_{best}-m_{best}\\le k\\le fail_{best}$,我们给$a_{n-k}$分配$b_{fail_{best}-k+1}$作为系数。 这样构造出来的数列 R_{\\Delta}=\\{0,0,...,0,t,-t\\times r_{best,1},-t\\times r_{best,2},...,-t\\times r_{best,m_{best}}\\}满足条件 再让$R_{cur+1}=R_{cur}+R_{\\Delta}$即可。 由于最坏情况下可能会修改$O(n)$次，所以复杂度$O(n^2)$","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"old driver tree","slug":"ODT","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-11T15:33:20.414Z","comments":true,"path":"ODT/","link":"","permalink":"http://ldxcaicai.github.io/ODT/","excerpt":"","text":"ODT简介ODT(old driver tree 老驱动树)又名珂朵莉树 是由$codeforces$上一位叫做$ODT$的用户提出的一种基于平衡树的暴力数据结构。（实际上就是 $lxl$ 这个数据结构的玄妙之处在于它并没有稳定的时间复杂度，因此只有在数据随机/水的情况下才会有较好的表现。 实现前提&amp;&amp;实现原理前提是必须要有区间覆盖操作且数据较随机/水 实现原理：将元素相同的区间推平一起处理，即如果区间$[l,r]$中的所有数$[a_l,a_{l+1}…a_r]$全部相同的话就将这个区间的信息用一个节点表示。 从上述描述可以看出这个数据结构是非常暴力玄学的 初始化然后对于每段区间我们可以用一个三元组$[l,r,v]$来表示它的左/右端点和整个区间的值，然后对于这些区间的信息可以用一个$set$来维护。 下面谈谈$ODT$两个重要的操作$split$和$assign$ split操作$ODT$的$split$函数$split(pos)$表示把$pos$所在的这个区间$[l,r,v]$分成$[l,pos-1,v]$和$[pos,r,v]$并且返回后者的迭代器。 实现很简单直接二分找出$pos$所在的区间然后加几个小特判。 assign操作$ODT$最核心的操作$assign$，$assign(l,r,v)$表示把区间$[l,r]$全部赋值为$v$并且会将这$r-l+1$个点合并成一个$ODT$节点插入到$ODT$中，由于数据随机的时候$ODT$中节点会快速减少，因此$ODT$复杂度此时十分接近$O(n\\log n)$具体实现可以通过上面提到的$split$函数。 其它操作至此，与$ODT$相关的操作已经基本讲完了。 剩下的操作与$ODT$本身关系并不大，相当于就是遍历每一个$ODT$节点暴力进行修改和查询。它可以支持的操作（懒得放代码了）： 区间第k小区间加区间所有数的k次方和区间…","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]},{"title":"AAA tree","slug":"AAA-tree","date":"2019-09-25T14:25:20.000Z","updated":"2019-10-15T14:31:38.445Z","comments":true,"path":"AAA-tree/","link":"","permalink":"http://ldxcaicai.github.io/AAA-tree/","excerpt":"","text":"AAA树引入在学习了 $LCT$ 之后，树上一些常见的问题已经不能满足选手们的需求，从而出现了这样一道题： [bzoj3153]Sone1 它要求选手们维护子树覆盖，子树加，子树最值，子树和，链覆盖，链加，链最值，链和，换父亲，换根这十二个基本操作 假如没有换父亲的确是树链剖分的基本操作 假如没有子树修改与查询的确是 $LCT$ 的基本操作 然而现在都有了 于是就有了 $AAA$ 树和 $toptree$ 来解决上述问题，由于笔者现在并不会后者，因此该篇文章主要讲述 $AAA$ 树的原理与实现 原理 $LCT$ 无法解决子树问题的原因是它只维护了实链的信息而子树问题要涉及到虚子树的信息 在静态树问题中，有链分治这种分治方法，其原理是用不同的数据结构对重链和实链分开进行维护并及时合并轻重链信息 考虑对每个 $LCT$ 上的点建一个数据结构来统计其虚子树的信息，它要具备如下功能： 能够快速删除与加入新的节点 能够快速合并其管辖点的信息 不难想到建出一棵平衡树来维护其虚子树的信息，在这里笔者选择使用 $splay$ ，我们将原树进行改造，使得每个点 $p$ 有四个儿子，其中 $son_{p,0/1}$ 表示维护其实链 $LCT$ 的儿子，而 $son_{p,2/3}$ 分别是维护其虚子树的 $splay$ 的根，对于维护虚子树的节点，我们强制其在 $splay$ 的叶节点，下面是一个简单的例子： 原树：$AAA$ 树： 现在要实现加点和删点进其虚儿子所在的 $splay$ 加点：将该点插入 $splay$ 中（可能会新建一个如上图中的 $A$ 节点）删点：若该点父亲是 $A$ 点，就删掉该点和其父亲，并将自己的兄弟放到父亲的位置，否则直接删掉该点即可 然后 $access$ 操作就直接在换右儿子的时候利用上述两个函数即可，加点对应将实边换成虚边，删点对应将虚边换成实边 维护标记： 每个节点记录以下三种信息： $cha,sub,all$ 表示实链的信息，整棵实 $splay$ 上面挂着的所有虚子树的信息，以及整棵子树的信息 $pushup$ 操作： \\begin{aligned} cha=&son[0]->cha+son[1]->cha\\\\ sub=&son[0]->sub+son[1]->sub+son[2]->all+son[3]->all\\\\ all=&cha+sub\\\\ \\end{aligned}简单易懂 先要维护两个维护树形态的标记： $rev,inr$ 分别表示翻转标记以及其是否是 $A$ 点 然后要维护两个标记 $All,Cha$ $All$ 表示对整棵子树进行的修改，但不修改实链的信息， $Cha$ 表示对实链进行修改 $All$ 标记在传实儿子的时候不修改链，在传虚儿子的时候要修改链 $cut(v)$ 操作： $access(fa_v)$ ，然后在其虚 $splay$ 中删掉 $v$ $link(u,v)$ 操作：$access(v)$ ，然后把 $u$ 加进其虚 $splay$ 中 链操作同 $LCT$ ，不过只跟 $cha$ 有关 子树操作：修改/查询点 $u$ 的时候，直接 $access(u)$ ，然后其子树信息都在虚 $splay$ 中，用 $u$ 的单点信息和其虚子树信息拼接起来即可 这样就可以尝试解决该题或者直接去世了","categories":[{"name":"public","slug":"public","permalink":"http://ldxcaicai.github.io/categories/public/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://ldxcaicai.github.io/tags/学习笔记/"}]}]}